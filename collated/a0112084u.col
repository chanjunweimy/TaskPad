//@author: a0112084u



	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmExecutor.java
	 */


package com.taskpad.alarm;

import com.taskpad.ui.GuiManager;

/**
 * and note that: Alarm can only support 
 * 10 s, not 10s
 * 
 */
public class AlarmExecutor {
	
	private static final String ERROR_NEGATIVE_DELAY = "Time should be a positive integer";
	private static final int TIME_FORCE_WAIT = 1;
	private static TimerObject _forceWaitTimer = new TimerObject();
	
	private static String _desc = "";
	
	private AlarmExecutor(int time){
	}
	
	protected static void initializeAlarm(String desc, int time){
		_desc = desc;
		if (time >= 1){
			_forceWaitTimer.setForceStopTimer(TIME_FORCE_WAIT, time - TIME_FORCE_WAIT);
		} else {
			GuiManager.callOutput(ERROR_NEGATIVE_DELAY);
		}
	}
	
	protected static void launchAlarm(int time) {		
		try {
			AlarmManager.setAlarm(_desc, time);
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmExecutor.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmManager.java
	 */


package com.taskpad.alarm;

import java.awt.Color;

import javax.swing.JApplet;

import com.taskpad.ui.GuiManager;

public class AlarmManager extends JApplet{

	
	private static final long serialVersionUID = 4348001564533802036L;		//Randomly generated
	//private static final Exception EXCEPTION_ERROR = new Exception();
	private final static String SONG_DEFAULT = "pokemon.mid";
	private static Sound _alarm = null;
	private final static int ALARM_DURATION = 60;
	private static boolean _isPlaying = false;
	private static TimerObject _startAlarmTimer = new TimerObject();
	
	private static String _desc = "";
	private static final String MESSAGE_ALARM = "ALARM!! %s";
	private static final String MESSAGE_CANCEL_ALARM = "Cancelling Alarm";
	private static final String MESSAGE_STOP_ALARM = "Stopping Alarm";
	private static final String MESSAGE_NO_ALARM = "No alarm has been set";
	private static final String MESSAGE_UNABLE_SET_ALARM = "Error: Unable to set alarm";
	
	private AlarmManager(){
		/* deprecated, we no longer wants it to be an object
		try {
			initializeSong();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		*/
	}
	
	/* deprecated
	public AlarmManager(String otherSong) throws Exception{
		initializeSong(otherSong);
	}
	*/
	
	private static void initializeSong() throws Exception{
		_alarm = setUpSong();
	}
	
	public static void setAlarm(String desc, int time){
		_desc = desc;
		ensureInitialization();

		boolean isOn = true;
		_startAlarmTimer.setAlarmTimer(isOn, time);
	}  
	
	private static void ensureInitialization() {
		if (_alarm == null){
			try {
				initializeSong();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
		}
	}
	
	private static Sound setUpSong() throws Exception {
		Sound testSong = new Sound(SONG_DEFAULT);
		return testSong;
	}
	
	protected static void turnOnAlarm() throws Exception{
		showGuiWindow();
		outputAlarmDesc();
		
		if (_alarm == null){
			GuiManager.callOutput(MESSAGE_UNABLE_SET_ALARM);
			return;
			//throw EXCEPTION_ERROR;
		}
		
		if (!_isPlaying){
			_alarm.playSound();
			_isPlaying = true;
		} else {
			turnOffAlarm();
			_alarm.playSound();
			_isPlaying = true;
		}
	}
	
	private static void outputAlarmDesc() {
		String alarmOutput = String.format(MESSAGE_ALARM, _desc);
		GuiManager.showSelfDefinedMessage(alarmOutput, Color.RED, true);		
	}

	private static void showGuiWindow() {
		GuiManager.showWindow(true);		
	}

	public static void turnOffAlarm() throws Exception{
		
		if (_alarm == null){
			GuiManager.callOutput(MESSAGE_NO_ALARM);
			//throw EXCEPTION_ERROR;
			return;
		}
			
		if (_isPlaying){
			_alarm.stopSound();
			_isPlaying = false;
		} else{
			//throw EXCEPTION_ERROR;
			return;
		}
		GuiManager.callOutput(MESSAGE_STOP_ALARM);
	}
	
	public static void cancelAlarms() throws Exception{
		/*
		if (_alarm == null){
			//throw EXCEPTION_ERROR;
			return;
		}
		*/

				
		if (_isPlaying){
			_alarm.stopSound();
			TimerObject.cancelAlarms();
			_isPlaying = false;
		} else {
			TimerObject.cancelAlarms();
		}
		GuiManager.callOutput(MESSAGE_CANCEL_ALARM);

	}
	
	protected static void runAlarm() throws Exception{
		turnOnAlarm();
		boolean isOn = false;
		_startAlarmTimer.setAlarmTimer(isOn, ALARM_DURATION);
	}
	
	public static void initializeAlarm(String desc, int time){
		AlarmExecutor.initializeAlarm(desc, time);
	} 
	
	/* deprecated
	private void initializeSong(String otherSong) throws Exception{
		_alarm = setUpSong(otherSong);
	}*/
	
	/* deprecated
	protected void playSong(){
		assert (_alarm != null);
		_alarm.playSound();
		_isPlaying = true;
	}
	*/
	/* deprecated
	private Sound setUpSong(String otherSong) throws Exception {
		Sound testSong = new Sound(otherSong);
		return testSong;
	}
	*/
	
	/* test alarm
	public static void main(String[] args){
		AlarmManager alarm = null;
		try {
			alarm = new AlarmManager();
			alarm.runAlarm();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			System.err.println(e.getMessage());
			System.err.println("cannot start song");
			
		}
	}
	*/
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmOffTask.java
	 */


package com.taskpad.alarm;

import java.util.TimerTask;

/**
 * 
 * AlarmTask is the task that should be done
 * after the timer delay, which is stop playing sound. :D
 */



public class AlarmOffTask extends TimerTask {
	
	protected AlarmOffTask(){
	}
	
    public void run() {
    	try {
			AlarmManager.turnOffAlarm();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
    }

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmOffTask.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmOnTask.java
	 */


package com.taskpad.alarm;

import java.util.TimerTask;

/**
 * 
 * AlarmTask is the task that should be done
 * after the timer delay, which is stop playing sound. :D
 */

public class AlarmOnTask extends TimerTask {
	
	protected AlarmOnTask(){
	}
	
    public void run() {
    	try {
			AlarmManager.runAlarm();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
    }

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\AlarmOnTask.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\ForceWaitTask.java
	 */


package com.taskpad.alarm;

import java.util.TimerTask;

/**
 * 
 * Force user to wait to load sound
 *
 */

public class ForceWaitTask extends TimerTask {
	private int _time = -1;
	
	protected ForceWaitTask(int time){
		_time = time;
	}
	
    public void run() {
    	AlarmExecutor.launchAlarm(_time);
    }
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\ForceWaitTask.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\Sound.java
	 */


package com.taskpad.alarm;

import java.applet.Applet;
import java.applet.AudioClip;
import java.net.URL;

/**
 * 
 * This is a helper class
 * to play the sound
 *
 */


public class Sound {
	private AudioClip _song; // Sound player
	private URL _songPath; // Sound path
	
	protected Sound(String filename) throws Exception{
		assert (filename != null);
		setUpSong(filename);
	}

	private void setUpSong(String filename) throws Exception{
		_songPath = ClassLoader.getSystemResource(filename); // Get the Sound URL
		_song = Applet.newAudioClip(_songPath); // Load the Sound
	}
	
	protected void playSound(){
		_song.loop(); // Play
	}
	
	protected void stopSound(){
		_song.stop(); // Stop		
	}
	
	protected void playSoundOnce(){
		_song.play(); // Play only once
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\Sound.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\TimerObject.java
	 */


package com.taskpad.alarm;

import java.util.LinkedList;
import java.util.Timer;
import java.util.logging.Logger;

/**
 * 
 * TimerObject is the timer
 * that counts how long the 
 * song plays
 */

public class TimerObject {
	private final static Logger LOGGER = Logger.getLogger("TaskPad");
	private static LinkedList<Timer> _timers = new LinkedList<Timer>();

	protected TimerObject(){
	}
	
	/* DEPRECATED
    protected TimerObject(boolean isOn, int seconds) {
        initializeTimer(isOn, seconds);
	}
	*/

	protected void setAlarmTimer(boolean isOn, int seconds) {
		Timer alarmTimer = new Timer();
        seconds *= 1000;
        if (!isOn){
        	alarmTimer.schedule(new AlarmOffTask(), seconds);
        } else {
        	alarmTimer.schedule(new AlarmOnTask(), seconds);
        }
        
        _timers.add(alarmTimer);
	}

	protected void setForceStopTimer(int seconds, int time) {
		Timer forceStopTimer = new Timer();
    	forceStopTimer.schedule(new ForceWaitTask(time), seconds);
    	
    	_timers.add(forceStopTimer);
	}
	
	protected static void cancelAlarms(){
		LOGGER.info("cancelling...");
		LOGGER.info("timers number: " + _timers.size());
		for (int i = 0; i < _timers.size(); i++){
			_timers.get(i).cancel();
			_timers.get(i).purge();
			LOGGER.info("timer " + i + " " + _timers.get(i).toString());
		}
		_timers.clear();
	}
    
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\alarm\TimerObject.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTime.java
	 */


/* This helper class creates the date and time object */

package com.taskpad.dateandtime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateAndTime {	
	private Date _today;
	
	//date used in debugging
	private Date _debugDate = null;
	
	protected DateAndTime(){
	}

	/**
	 * 
	 */
	private void setupDateAndTime() {
		boolean isNotDebugging = _debugDate == null;
		if (isNotDebugging){
			_today = new Date();
		} else {
			_today = _debugDate;
		}
	}
	
	protected String getCurrentDate(){
		setupDateAndTime();
		
		SimpleDateFormat formater = new SimpleDateFormat("dd/MM/yyyy");
		return formater.format(_today);
	}
	
	protected String getCurrentTime(){
		setupDateAndTime();
		
		SimpleDateFormat formater = new SimpleDateFormat("HH:mm");
		return formater.format(_today);
	}
	
	protected String getCurrentDay(){
		setupDateAndTime();
		
		SimpleDateFormat formater = new SimpleDateFormat("EEEE");
		return formater.format(_today);
	}
	
	protected String getCurrentTimeAndDate(){
		setupDateAndTime();
		
		SimpleDateFormat formater = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		return formater.format(_today);
	}
	
	/**
	 * setDebugDate: setup a date for debugging. Used when debugging
	 * FORMAT : dd/MM/yyyy HH:mm
	 * @param dateString
	 * @throws ParseException
	 */
	protected void setDebugDate(String dateString) throws ParseException{
		SimpleDateFormat formater = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		_debugDate = formater.parse(dateString);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTime.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTimeRetriever.java
	 */


package com.taskpad.dateandtime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.logging.Logger;

import com.taskpad.ui.GuiManager;

/**
 * This class is for us to find the existence of Date and Time in an input
 * String
 * 
 * Supposed to put all the protected methods from DateAndTimeManager here
 * 
 */

public class DateAndTimeRetriever {
	
	private static final Logger LOGGER = Logger.getLogger("TaskPad");

	private static final int POSITION_DESCRIPTION = 3;
	private static final int POSITION_ENDTIME = 2;
	private static final int POSITION_STARTTIME = 1;
	private static final int POSITION_DEADLINE = 0;

	private static final String STRING_NULL = "null";
	private static final String STRING_EMPTY = "";
	private static final String STRING_QUOTES = "\"";
	private static final String STRING_SPACE = " ";

	private static final String DEADLINE = "DEADLINE";
	private static final String TIME_START = "STARTTIME";
	private static final String TIME_END = "ENDTIME";
	
	private static final String[] KEYWORD_DEADLINES = { "BY", "BEFORE", "BEF", "DUE" };
	private static final String[] KEYWORD_STARTTIME = { "AT", "AFTER", "ON",
			"IN", "FROM", "FRO" };
	private static final String[] KEYWORD_ENDTIME = { "UNTIL", "TILL", "TO",
			"TIL", "~", "FOR" };

	private static HashMap<String, String> _retrieverMap = new HashMap<String, String>();
	private static DateAndTimeRetriever _retriever = new DateAndTimeRetriever();

	/**
	 * @deprecated
	 */
	private static final String[] KEYWORD_TODAY = { "TODAY", "TDY", "2DAY" };

	/**
	 * @deprecated
	 */
	private static final String[] KEYWORD_NOW = { "NOW" };

	private DateAndTime _dateAndTimeObject = new DateAndTime();

	private DateAndTimeRetriever() {
		intializeRetrieverMap();
	}

	private void intializeRetrieverMap() {
		initializeStartTime();
		initializeEndTime();
		initializeDeadlines();
	}

	private void initializeStartTime() {
		for (String anyStartTime : KEYWORD_STARTTIME) {
			_retrieverMap.put(anyStartTime, TIME_START);
		}
	}

	private void initializeEndTime() {
		for (String anyEndTime : KEYWORD_ENDTIME) {
			_retrieverMap.put(anyEndTime, TIME_END);
		}

	}

	private void initializeDeadlines() {
		for (String anyDeadline : KEYWORD_DEADLINES) {
			_retrieverMap.put(anyDeadline, DEADLINE);
		}
	}

	protected static DateAndTimeRetriever getInstance() {
		return _retriever;
	}


	protected ArrayList<String> searchTimeAndDate(String desc)
			throws InvalidQuotesException {
		if (desc == null){
			return null;
		}
		
		String formattedString = convertStandardDateAndTime(desc);

		// System.err.println(formattedString);

		ArrayList<String> searchResult = extractAllDateAndTime(formattedString);

		return searchResult;
	}

	/**
	 * @param formattedString
	 */
	private ArrayList<String> extractAllDateAndTime(String formattedString) {
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		//String todayDate = datm.getTodayDate();

		String todayDate = getTodayDate();
		
		String recordTime = null;
		String recordDate = null;

		ArrayList<String> TimeAndDateRes = new ArrayList<String>();

		String[] formattedTokens = formattedString.split(STRING_SPACE);
		for (int i = 0; i < formattedTokens.length; i++) {
			String token = formattedTokens[i];
			if (isDate(token)) {
				if (recordDate != null) {
					String res;
					if (recordTime == null) {
						res = recordDate;
						recordDate = null;
					} else {
						res = recordTime + STRING_SPACE + recordDate;
						recordDate = null;
						recordTime = null;
					}
					TimeAndDateRes.add(res);
				}
				recordDate = token;
			} else if (isTime(token)) {
				if (recordTime != null) {
					String res;
					if (recordDate == null) {
						res = recordTime + STRING_SPACE + todayDate;
						recordTime = null;
					} else {
						res = recordTime + STRING_SPACE + recordDate;
						recordDate = null;
						recordTime = null;
					}
					TimeAndDateRes.add(res);
				}
				recordTime = token;
			}
		}

		String res = null;
		if (recordTime != null && recordDate != null) {
			res = recordTime + STRING_SPACE + recordDate;
		} else if (recordTime != null && recordDate == null) {
			res = recordTime + STRING_SPACE + todayDate;
		} else if (recordTime == null && recordDate != null) {
			res = recordDate;
		}

		if (res != null) {
			TimeAndDateRes.add(res);
		}
		return TimeAndDateRes;
	}

	/**
	 * format all the date and time in a string to standard format
	 * 
	 * @param desc
	 * @throws InvalidQuotesException
	 */
	protected String convertStandardDateAndTime(String desc)
			throws InvalidQuotesException {
		if (desc == null){
			return null;
		}
		
		String alphaNumericSpaceDesc = getAlphaNumericSpaceDesc(desc);

		LOGGER.info("alphaNumericSpaceDesc : " + alphaNumericSpaceDesc);

		String noQuoteDesc = removeParseFreeZone(alphaNumericSpaceDesc);

		LOGGER.info("noQuoteDesc : " + noQuoteDesc);

		String numberedInput = parseNumber(noQuoteDesc);

		LOGGER.info("numberedInput : " + numberedInput);

		String dateString = parseDate(numberedInput);

		LOGGER.info("dateString : " + dateString);

		String holidayString = parseHolidayDates(dateString);

		LOGGER.info("holidayString : " + holidayString);

		String dayString = parseDay(holidayString);

		LOGGER.info("dayString : " + dayString);

		String timeString = parseTime(dayString);
		LOGGER.info("timeString: " + timeString);

		String timeWordString = parseTimeWord(timeString);

		timeWordString = timeWordString.replaceAll(STRING_QUOTES, "").trim();

		LOGGER.info("timeWordString: " + timeWordString);
		return timeWordString;

		//String todayAndNowString = timeWordString;
		// String todayAndNowString = parseTodayAndNow(timeWordString);

		//LOGGER.info("todayAndNowString : " + todayAndNowString);

		//return todayAndNowString;
	}

	/**
	 * format DateAndTime as Deadline, StartTime, EndTime
	 * 
	 * @param desc
	 * @return desc | Deadline: | StartTime: Date then Time | EndTime: Date Then
	 *         Time
	 * @throws InvalidQuotesException
	 */
	protected String formatDateAndTimeInString(String desc)
			throws InvalidQuotesException {

		if (desc == null){
			return null;
		}
		
		String formattedString = convertStandardDateAndTime(desc);

		// System.err.println(formattedString);
		LOGGER.info("formattedString is " + formattedString);

		ArrayList<String> allDateAndTime = extractDateAndTime(formattedString);

		// System.err.println(allDateAndTime.get(POSITION_DEADLINE));
		// System.err.println(allDateAndTime.get(POSITION_STARTTIME));
		// System.err.println(allDateAndTime.get(POSITION_ENDTIME));

		desc = allDateAndTime.remove(POSITION_DESCRIPTION);

		allDateAndTime = modifyAllDateAndTime(allDateAndTime);

		String deadlineRes = allDateAndTime.get(POSITION_DEADLINE);
		String startTimeRes = allDateAndTime.get(POSITION_STARTTIME);
		String endTimeRes = allDateAndTime.get(POSITION_ENDTIME);

		// return that string to parse in respective Add/Addrem/Alarm classes -
		// already done with return input

		return desc + STRING_SPACE + deadlineRes + STRING_SPACE + startTimeRes + STRING_SPACE + endTimeRes;
	}

	/**
	 * @param timeString
	 * @return
	 */
	private String parseTimeWord(String timeString) {
		String[] timeWordTokens = timeString.split(DateAndTimeRetriever.STRING_SPACE);

		TimeWordParser twp = TimeWordParser.getInstance();
		SpecialWordParser swp = SpecialWordParser.getInstance();
		NumberParser np = NumberParser.getInstance();

		boolean[] isModified = new boolean[timeWordTokens.length];

		initializeArray(isModified);

		for (int i = 0; i < timeWordTokens.length; i++) {
			String firstToken = timeWordTokens[i];
			StringBuffer changedTokens = new StringBuffer();
			boolean isTimeWord = twp.isValidTimeWord(firstToken);
			if (twp.isTimeUnits(firstToken) || isTimeWord) {
				isModified[i] = true;
				String secondToken = null;

				for (int j = i - 1; j >= 0; j--) {
					if (isModified[j]) {
						break;
					}

					isModified[j] = true;
					String token = timeWordTokens[j];

					if (swp.isSpecialWord(token)) {
						changedTokens.append(token + STRING_SPACE);
						timeWordTokens[j] = null;
					} else if (j == i - 1 && np.isDigitString(token) && !isTimeWord) {
						timeWordTokens[j] = null;
						secondToken = token;
					} else {
						break;
					}

				}
				if (secondToken != null) {
					changedTokens.append(secondToken + STRING_SPACE);
				}
				changedTokens.append(firstToken);

				try {
					timeWordTokens[i] = STRING_QUOTES + twp
							.parseTimeWordWithSpecialWord(changedTokens
									.toString().trim());
				} catch (NullTimeUnitException | NullTimeValueException e) {
				}

			}
		}

		StringBuffer timeWordString = new StringBuffer();
		timeWordString = buildString(timeWordTokens, timeWordString);

		return timeWordString.toString().trim();
	}

	protected String removeParseFreeZone(String alphaNumericSpaceDesc)
			throws InvalidQuotesException {
		boolean removeStat = false;
		String[] descTokens = alphaNumericSpaceDesc.split(DateAndTimeRetriever.STRING_SPACE);
		for (int i = 0; i < descTokens.length; i++) {
			// don't allow ' ' for parse free zone because user might type it
			// who's

			if (DateAndTimeRetriever.STRING_QUOTES.equals(descTokens[i])) {
				if (!removeStat) {
					removeStat = true;
				} else {
					removeStat = false;
				}
				descTokens[i] = null;
				// descTokens[i] = "\"" + descTokens[i];
			} else {
				if (removeStat) {
					// descTokens[i] = null;
					descTokens[i] = DateAndTimeRetriever.STRING_QUOTES + descTokens[i];
				}
			}
		}

		if (removeStat) {
			throw new InvalidQuotesException();
		}

		StringBuffer tokensBuilder = new StringBuffer();
		tokensBuilder = buildString(descTokens, tokensBuilder);

		return tokensBuilder.toString().trim();
	}

	private boolean isParseFree(String token) {
		if (token == null) {
			return false;
		}
		return token.startsWith(DateAndTimeRetriever.STRING_QUOTES);
	}

	private void outputToGui(String outputString){
		GuiManager.callOutput(outputString);
	}
	
	/**
	 * @param allDateAndTime
	 */
	private ArrayList<String> modifyAllDateAndTime(
			ArrayList<String> allDateAndTime) {
		for (int i = 0; i < allDateAndTime.size(); i++) {
			if (allDateAndTime.get(i) == null
					|| allDateAndTime.get(i).trim().isEmpty()) {
				allDateAndTime.set(i, STRING_NULL + STRING_SPACE + STRING_NULL);
			} else if (allDateAndTime.get(i).split(STRING_SPACE).length == 1) {
				String element = allDateAndTime.get(i);
				allDateAndTime.set(i, element + STRING_SPACE + STRING_NULL);
			}
		}
		return allDateAndTime;
	}

	/**
	 * @param timeString
	 */
	private ArrayList<String> extractDateAndTime(String timeString) {
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		//String todayDate = datm.getTodayDate();
		//String now = datm.getTodayDateAndTime();

		String todayDate = getTodayDate();
		String now = getTodayDateAndTime();
		
		String[] flexiTokens = timeString.split(STRING_SPACE);

		String startDateEarliest = null;
		String startTimeEarliest = null;
		String startEarliest = null;

		LinkedList<String> startDates = new LinkedList<String>();
		LinkedList<String> startTimes = new LinkedList<String>();

		LinkedList<String> deadlineDates = new LinkedList<String>();
		LinkedList<String> deadlineTimes = new LinkedList<String>();

		LinkedList<String> endDates = new LinkedList<String>();
		LinkedList<String> endTimes = new LinkedList<String>();

		ArrayList<String> allDateAndTime = new ArrayList<String>();

		StringBuffer descBuilder = new StringBuffer();
		String desc;

		String recordDate = null;
		String recordTime = null;

		for (int i = flexiTokens.length - 1; i >= 0; i--) {
			String token = flexiTokens[i];

			/*
			if (isParseFree(token)) {
				if (recordDate != null || recordTime != null) {
					startDates.add(recordDate);
					startTimes.add(recordTime);

					recordDate = null;
					recordTime = null;
				}
			} else */
			if (isDate(token)) {
				//token = parseDate(token);

				if (recordDate == null) {
					recordDate = token;
				} else {
					startDates.add(recordDate);
					startTimes.add(recordTime);

					recordDate = token;
					recordTime = null;
				}

				flexiTokens[i] = null;

			} else if (isTime(token)) {
				//token = parseTime(token);

				if (recordTime == null) {
					recordTime = token;
				} else {
					startDates.add(recordDate);
					startTimes.add(recordTime);

					recordDate = null;
					recordTime = token;
				}

				flexiTokens[i] = null;

			} else if (isType(token)) {
				boolean isUsedWrong = (recordDate == null && recordTime == null);

				if (!isUsedWrong) {
					token = token.toUpperCase();
					String type = _retrieverMap.get(token);
					if (DEADLINE.equals(type)) {
						deadlineDates.add(recordDate);
						deadlineTimes.add(recordTime);
					} else if (TIME_START.equals(type)) {
						startDates.add(recordDate);
						startTimes.add(recordTime);
					} else if (TIME_END.equals(type)) {
						endDates.add(recordDate);
						endTimes.add(recordTime);
					}
					recordDate = null;
					recordTime = null;

					flexiTokens[i] = null;

				}
			} else {
				if (recordDate != null || recordTime != null) {
					startDates.add(recordDate);
					startTimes.add(recordTime);

					recordDate = null;
					recordTime = null;
				}
			}
		}

		// System.err.println(timeString + "\n" + startDates.toString());

		if (recordDate != null || recordTime != null) {
			startDates.add(recordDate);
			startTimes.add(recordTime);
		}

		startEarliest = retrieveStartEarliest(todayDate, now,
				startDateEarliest, startTimeEarliest, startEarliest,
				startDates, startTimes);

		if (startEarliest == null) {
			startDateEarliest = todayDate;
		} else {
			startDateEarliest = startEarliest.split(STRING_SPACE)[0];
			startEarliest = startEarliest.replaceAll(STRING_QUOTES, STRING_EMPTY);
		}

		LOGGER.info("startEarliest: " + startEarliest);

		String deadlineLatest = retrieveNotStartLatest(deadlineDates,
				deadlineTimes, startDateEarliest);
		String endLatest = retrieveNotStartLatest(endDates, endTimes,
				startDateEarliest);

		LOGGER.info("deadlineLatest: " + deadlineLatest);
		LOGGER.info("startDateEarliest: " + startDateEarliest);
		LOGGER.info("endLatest: " + endLatest);

		if (endLatest != null){
			endLatest = endLatest.replaceAll(STRING_QUOTES, STRING_EMPTY);
		}
		
		if (deadlineLatest != null){
			deadlineLatest = deadlineLatest.replaceAll(STRING_QUOTES, STRING_EMPTY);
		}
		
		String tempEnd = checkDateAndTimeWithStart(startEarliest, endLatest);
		if (tempEnd == null && endLatest != null){
			if (startEarliest != null){
				outputToGui("end time and date: " + endLatest + " is earlier than "
					+ "startTime: " + startEarliest + " or now: " + now);
			} else {
				outputToGui("end time and date: " + endLatest + " is earlier than "
						+ "now: " + now);
			}
		}
		endLatest = tempEnd;
		
		LOGGER.info("deadlineLatest: " + deadlineLatest);
		LOGGER.info("startEarliest: " + startEarliest);
		String tempDead = checkDateAndTimeWithStart(startEarliest,
				deadlineLatest);
		if (tempDead == null && deadlineLatest != null){
			if (startEarliest != null){
				outputToGui("deadline: " + deadlineLatest + " is earlier than "
					+ "startTime: " + startEarliest + " or now: " + now);
			} else {
				outputToGui("deadline: " + deadlineLatest + " is earlier than "
						+ "now: " + now);
			}
		}
		deadlineLatest = tempDead;

		descBuilder = buildString(flexiTokens, descBuilder);
		desc = descBuilder.toString().trim();

		allDateAndTime.add(deadlineLatest);
		allDateAndTime.add(startEarliest);
		allDateAndTime.add(endLatest);
		allDateAndTime.add(desc);

		return allDateAndTime;
	}

	/**
	 * @param startEarliest
	 * @param dateLatest
	 * @return
	 */
	protected String checkDateAndTimeWithStart(String startEarliest,
			String dateLatest) {
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		//String now = datm.getTodayDateAndTime();

		String now = getTodayDateAndTime();
		
		if (startEarliest != null && startEarliest.trim().isEmpty()){
			startEarliest = null;
		}
		
		if (dateLatest != null && dateLatest.trim().isEmpty()){
			return STRING_EMPTY;
		}
		
		if (dateLatest != null && startEarliest != null
				&& compareDateAndTime(dateLatest, startEarliest) <= 0) {
			dateLatest = null;
		} else if (dateLatest != null
				&& compareDateAndTime(dateLatest, now) <= 0) {
			dateLatest = null;
		}
		return dateLatest;
	}

	/**
	 * @param todayDate
	 * @param now
	 * @param startDateEarliest
	 * @param startTimeEarliest
	 * @param startEarliest
	 * @param startDates
	 * @param startTimes
	 * @return
	 */
	private String retrieveStartEarliest(String todayDate, String now,
			String startDateEarliest, String startTimeEarliest,
			String startEarliest, LinkedList<String> startDates,
			LinkedList<String> startTimes) {
		assert (startDates.size() == startTimes.size());

		for (int i = 0; i < startDates.size(); i++) {
			if (startDates.get(i) != null && startTimes.get(i) != null) {
				String start = startDates.get(i) + STRING_SPACE + startTimes.get(i);
				if (startEarliest == null
						|| compareDateAndTime(startEarliest, start) > 0) {
					startEarliest = start;
				}
			} else if (startDates.get(i) != null && startTimes.get(i) == null) {
				String startDate = startDates.get(i);
				if (startDateEarliest == null
						|| compareDate(startDateEarliest, startDate) > 0) {
					startDateEarliest = startDate;
				}
			} else if (startDates.get(i) == null && startTimes.get(i) != null) {
				String startTime = startTimes.get(i);
				if (startTimeEarliest == null
						|| compareTime(startTimeEarliest, startTime) > 0) {
					startTimeEarliest = startTime;
				}
			} else {
				// unreachable
				assert (false);
			}
		}

		if (startDateEarliest != null) {
			if (startTimeEarliest == null) {
				startTimeEarliest = "00:00";
			}

			String start = startDateEarliest + STRING_SPACE + startTimeEarliest;
			if (startEarliest == null
					|| compareDateAndTime(startEarliest, start) > 0) {
				startEarliest = start;
			}
		} else if (startTimeEarliest != null) {
			String start = todayDate + STRING_SPACE + startTimeEarliest;
			if (startEarliest == null
					|| compareDateAndTime(startEarliest, start) > 0) {
				startEarliest = start;
			}
		} else if (startEarliest == null) {
			// startEarliest = now;
			return null;
		}
		return startEarliest.trim();
	}

	private String retrieveNotStartLatest(LinkedList<String> Dates,
			LinkedList<String> Times, String startDateEarliest) {
		assert (Dates.size() == Times.size());
		String latest = null;
		String dateLatest = null;
		String timeLatest = null;

		for (int i = 0; i < Dates.size(); i++) {
			if (Dates.get(i) != null && Times.get(i) != null) {
				String notStart = Dates.get(i) + STRING_SPACE + Times.get(i);
				if (latest == null || compareDateAndTime(latest, notStart) < 0) {
					latest = notStart;
				}
			} else if (Dates.get(i) != null && Times.get(i) == null) {
				String dateGet = Dates.get(i);
				if (dateLatest == null || compareDate(dateLatest, dateGet) < 0) {
					dateLatest = dateGet;
				}
			} else if (Dates.get(i) == null && Times.get(i) != null) {
				String timeGet = Times.get(i);
				if (timeLatest == null || compareTime(timeLatest, timeGet) < 0) {
					timeLatest = timeGet;
				}
			} else {
				// unreachable
				assert (false);
			}
		}

		if (dateLatest != null) {
			if (timeLatest == null) {
				timeLatest = "23:59";
			}
			String cur = dateLatest + STRING_SPACE + timeLatest;
			if (latest == null || compareDateAndTime(latest, cur) < 0) {
				latest = cur;
			}
		} else if (timeLatest != null) {
			String cur = startDateEarliest + STRING_SPACE + timeLatest;
			if (latest == null || compareDateAndTime(latest, cur) < 0) {
				latest = cur;
			}
		}
		if (latest != null) {
			latest = latest.trim();
		}

		return latest;
	}

	private boolean isType(String token) {
		return _retrieverMap.containsKey(token.toUpperCase());
	}

	protected int compareDate(String firstDateString, String secondDateString) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date firstDate = new Date();
		Date secondDate = new Date();
		try {
			firstDate = sdf.parse(firstDateString);
			secondDate = sdf.parse(secondDateString);
		} catch (ParseException e) {
			// should not use this function if it hasn't been converted
			assert (false);
		}
		return firstDate.compareTo(secondDate);
	}

	protected int compareTime(String firstTimeString, String secondTimeString) {
		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm");
		Date firstTime = new Date();
		Date secondTime = new Date();
		try {
			firstTime = sdf.parse(firstTimeString);
			secondTime = sdf.parse(secondTimeString);
		} catch (ParseException e) {
			// should not use this function if it hasn't been converted
			assert (false);
		}
		return firstTime.compareTo(secondTime);
	}

	protected int compareDateAndTime(String firstDateString,
			String secondDateString) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		Date firstDate = new Date();
		Date secondDate = new Date();
		try {
			firstDate = sdf.parse(firstDateString);
			secondDate = sdf.parse(secondDateString);
		} catch (ParseException e) {
			// should not use this function if it hasn't been converted
			assert (false);
		}
		return firstDate.compareTo(secondDate);
	}

	protected int compareDateAndTimeExecutor(String firstDateString,
			String secondDateString) {
		if (firstDateString == null || secondDateString == null) {
			return -2;
		}

		firstDateString = firstDateString.trim();
		secondDateString = secondDateString.trim();

		firstDateString = addTimeCap(firstDateString);
		secondDateString = addTimeCap(secondDateString);

		if (firstDateString == null || secondDateString == null) {
			return -2;
		}

		return compareDateAndTime(firstDateString, secondDateString);
	}

	/**
	 * @param firstDateString
	 * @return
	 */
	private String addTimeCap(String dateString) {
		if (!isDateAndTime(dateString)) {
			if (isDate(dateString)) {
				dateString = dateString + " 00:00";
			} else if (isTimeAndDate(dateString)) {
				String[] tokens = dateString.split(DateAndTimeRetriever.STRING_SPACE);
				dateString = tokens[1] + DateAndTimeRetriever.STRING_SPACE + tokens[0];
			} else {
				dateString = null;
			}
		}
		return dateString;
	}

	private boolean isTimeAndDate(String dateString) {
		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm dd/MM/yyyy");

		try {
			sdf.parse(dateString);
		} catch (ParseException e) {
			return false;
		}

		return true;
	}

	private boolean isDateAndTime(String dateString) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");

		try {
			sdf.parse(dateString);
		} catch (ParseException e) {
			return false;
		}

		return true;
	}

	protected String parseTime(String dateString) {
		String[] timeTokens = dateString.split(STRING_SPACE);
		StringBuffer timeString = new StringBuffer();
		boolean[] isModified = new boolean[timeTokens.length];

		int maxJoinWord = 4;
		for (int i = maxJoinWord; i >= 1; i--) {
			initializeArray(isModified);
			changeNTimeWords(timeTokens, isModified, i);
		}
		timeString = buildString(timeTokens, timeString);

		return timeString.toString().trim();
	}

	/**
	 * @param dateTokens
	 * @param isModified
	 */
	private void changeNTimeWords(String[] timeTokens, boolean[] isModified,
			int n) {
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		NumberParser np = NumberParser.getInstance();
		for (int i = n - 1; i < timeTokens.length; i++) {
			String token = timeTokens[i];
			StringBuffer wholeString = new StringBuffer();
			String timeInput;

			if (isParseFree(token)) {
				isModified[i] = true;
				continue;
			}

			// combine n words:
			if (allNotModified(isModified, i, n)) {
				boolean twoNumTgt = false;
				for (int j = i - n + 1; j <= i - 1; j++) {
					wholeString.append(timeTokens[j]);
					
					if (np.isDigitString(timeTokens[j]) && np.isDigitString(timeTokens[j + 1])){
						twoNumTgt = true;
						isModified[j] = true;
						break;
					}
				}
				
				if (twoNumTgt){
					continue;
				}
				
				wholeString.append(token);
				timeInput = wholeString.toString().trim();

				// System.err.println(dateInput);
				if (isTime(timeInput)) {
					LOGGER.info("TIMEWORDS " + n + STRING_SPACE + token);

					try {
						timeInput = parseOnlyTimeInput(timeInput);
						//timeInput = datm.parseTimeInput(timeInput);
						// timeInput = datm.parseTime(timeInput);
					} catch (TimeErrorException | InvalidTimeException e) {
						assert (false);
					}

					allNWordsModified(isModified, i, n);
					timeTokens[i] = STRING_QUOTES + timeInput;

					for (int j = i - n + 1; j <= i - 1; j++) {
						timeTokens[j] = null;
					}
				}
			}
		}
	}

	/**
	 * 
	 * @param dayString
	 * @return
	 */
	protected String parseDate(String dayString) {
		String[] dateTokens = dayString.split(STRING_SPACE);
		StringBuffer dateString = new StringBuffer();
		boolean[] isModified = new boolean[dateTokens.length];

		int maxJoinWord = 5;
		for (int i = maxJoinWord; i >= 1; i--) {
			initializeArray(isModified);
			changeNDateWords(dateTokens, isModified, i);
		}
		dateString = buildString(dateTokens, dateString);

		return dateString.toString().trim();
	}

	/**
	 * @param dateTokens
	 * @param isModified
	 */
	private void changeNDateWords(String[] dateTokens, boolean[] isModified,
			int numWordJoin) {
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		NumberParser np = NumberParser.getInstance();
		for (int i = numWordJoin - 1; i < dateTokens.length; i++) {
			String token = dateTokens[i];
			StringBuffer wholeString = new StringBuffer();
			String dateInput;

			if (dateTokens[i] == null){
				isModified[i] = true;
				continue;
			}
			
			if (isParseFree(token)) {
				isModified[i] = true;
				continue;
			}

			// combine n words:
			if (allNotModified(isModified, i, numWordJoin)) {
				boolean twoNumTgt = false;
				for (int j = i - numWordJoin + 1; j <= i - 1; j++) {
					wholeString.append(dateTokens[j]);
					if (np.isDigitString(dateTokens[j]) && np.isDigitString(dateTokens[j+1])){
						twoNumTgt = true;
						isModified[j] = true;
						break;
					}
				}
				
				LOGGER.info("wholeString is: " + wholeString.toString());
								
				if (twoNumTgt){
					LOGGER.severe("two numbers sticked together!");
					continue;
				}
				
				wholeString.append(token);
				dateInput = wholeString.toString().trim();
				// System.err.println(dateInput);
				if (isDate(dateInput)) {
					try {
						//dateInput = datm.parseDate(dateInput);
						dateInput = parseOnlyDate(dateInput);
					} catch (InvalidDateException e) {
						assert (false);
					}
					allNWordsModified(isModified, i, numWordJoin);
					dateTokens[i] = STRING_QUOTES + dateInput;
					for (int j = i - numWordJoin + 1; j <= i - 1; j++) {
						dateTokens[j] = null;
					}
				}
			}
		}
	}

	/**
	 * 
	 * @param isModified
	 * @param idx
	 * @param num
	 */
	private void allNWordsModified(boolean[] isModified, int idx, int num) {
		for (int i = idx; i >= idx - num + 1; i--) {
			isModified[i] = true;
		}
	}

	/**
	 * @param isModified
	 * @param i
	 * @return
	 */
	private boolean allNotModified(boolean[] isModified, int idx, int num) {
		for (int i = idx; i >= idx - num + 1; i--) {
			if (isModified[i]) {
				return false;
			}
		}
		return true;
	}

	
	/**
	 * @param input
	 */
	protected String getAlphaNumericSpaceDesc(String input) {
		Scanner sc = new Scanner(input);
		StringBuffer alphaNumericSpaceString = new StringBuffer();
		while (sc.hasNext()) {
			String token = sc.next();
			token = splitNonAlphaNumericCharacter(token);
			alphaNumericSpaceString.append(token + STRING_SPACE);
		}
		sc.close();
		return alphaNumericSpaceString.toString().trim();
	}
	
	/**
	 * split all the non numeric or alphaberts!
	 * by default: isDateAndTimePreserved is false. 
	 * @param token
	 * @param isDateAndTimePreserved
	 * @return
	 */
	private String splitNonAlphaNumericCharacter(String token) {
		// token = token.replaceAll("!", "");
		// token = token.replaceAll(".", "");
		// token = token.replaceAll(",", " ");
		// token = token.replaceAll(";", " ");
		// token = token.replaceAll("?", "");
		// token = token.replaceAll("\"", " \" ");
		// token = token.replaceAll("\'", " \' ");
		// token = token.replaceAll("(", "");
		// token = token.replaceAll(")", "");
		// token = token.replaceAll("~", " until ");
		// token = token.replaceAll("*", "");

		Scanner sc = new Scanner(token);
		// sc.useDelimiter("[^A-Za-z0-9]");
		StringBuffer tokenBuilder = new StringBuffer();
		String anyCharacter;
		while ((anyCharacter = sc.findInLine("[^A-Za-z0-9]")) != null) {
			int splitIndex = token.indexOf(anyCharacter);
			String tempTokens = token.substring(0, splitIndex);
			token = token.substring(splitIndex + 1, token.length());
			tokenBuilder.append(tempTokens + STRING_SPACE + anyCharacter + STRING_SPACE);
		}
		if (token != null) {
			tokenBuilder.append(token);
		}
		sc.close();
		return tokenBuilder.toString().trim();
	}

	private boolean isTime(String input) {
		input = input.trim();
		TimeParser tp = TimeParser.getInstance();
		try {
			tp.parseTimeInput(input);
			LOGGER.info("TIME PARSED: " + input);
		} catch (TimeErrorException | InvalidTimeException e) {
			LOGGER.info("TIME EXCEPTION: " + e.getMessage());
			return false;
		} catch (Exception e) {
			LOGGER.info("ERROR: " + input);
			return false;
		}
		return true;
	}

	private boolean isDate(String input) {
		input = input.trim();
		DateParser dateParser = DateParser.getInstance();
		try {
			dateParser.parseDate(input);
		} catch (InvalidDateException e) {
			return false;
		}
		return true;
	}

	/**
	 * 
	 * @param holidayString
	 */
	private String parseDay(String holidayString) {

		String dayString = getDayNtTmrYtd(holidayString);

		LOGGER.info("NT TMR YTD : " + dayString);

		dayString = getTmrYtd(dayString);

		LOGGER.info("TMR YTD : " + dayString);

		return dayString;
	}

	/**
	 * @param dayString
	 * @return
	 */
	private String getTmrYtd(String dayString) {
		String[] dayTokens = dayString.split(STRING_SPACE);
		StringBuffer dayBuilder = new StringBuffer(STRING_SPACE);

		SpecialWordParser swp = SpecialWordParser.getInstance();
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();

		String tmrTdyStr = STRING_EMPTY;

		boolean isStart = false;

		for (int i = 0; i < dayTokens.length; i++) {
			String token = dayTokens[i];
			boolean isTmrYtdVariation = swp.isTmrYtd(token);

			LOGGER.info("tmrYtd: " + token);

			if (isParseFree(token)) {
				if (isStart) {
					isStart = false;
					String passString = dayBuilder.toString().trim();
					try {
						//dayTokens[i - 1] = datm.parseDayToDate(passString);
						dayTokens[i - 1] = STRING_QUOTES + parseOnlyDayToDate(passString);
					} catch (InvalidDayException e) {
						// unreachable
						assert (false);
					}
					dayBuilder = new StringBuffer();
				}
			} else if (isTmrYtdVariation && !isStart) {
				dayBuilder.append(token + DateAndTimeRetriever.STRING_SPACE);
				dayTokens[i] = null;
				isStart = true;

				LOGGER.info("isTmrYtdVariation && !isStart: "
						+ dayBuilder.toString());
			} else if (isTmrYtdVariation && isStart) {
				dayTokens[i] = null;
				dayBuilder.append(token + DateAndTimeRetriever.STRING_SPACE);

				LOGGER.info("isTmrYtdVariation && isStart: "
						+ dayBuilder.toString());
			} else {
				if (isStart) {
					isStart = false;
					String passString = dayBuilder.toString().trim();
					try {
						//dayTokens[i - 1] = datm.parseDayToDate(passString);
						dayTokens[i - 1] = STRING_QUOTES + parseOnlyDayToDate(passString);
					} catch (InvalidDayException e) {
						// unreachable
						assert (false);
					}
					dayBuilder = new StringBuffer();
				}
			}
		}

		if (isStart) {
			String passString = dayBuilder.toString().trim();
			try {
				//tmrTdyStr = datm.parseDayToDate(passString);
				tmrTdyStr = STRING_QUOTES + parseOnlyDayToDate(passString);
			} catch (InvalidDayException e) {
				// unreachable
				assert (false);
			}
		}

		dayBuilder = new StringBuffer();

		LOGGER.info("DAYTOKENS: " + dayTokens.length);

		dayBuilder = buildString(dayTokens, dayBuilder);
		dayBuilder.append(tmrTdyStr);

		dayString = dayBuilder.toString().trim();
		return dayString;
	}

	/**
	 * @param dayTokens
	 * @param dayString
	 * @param swp
	 * @param datm
	 * @param dp
	 * @param isModified
	 * @return
	 */
	private String getDayNtTmrYtd(String holidayString) {
		String[] dayTokens = holidayString.split(DateAndTimeRetriever.STRING_SPACE);
		StringBuffer dayBuilder = new StringBuffer();
		SpecialWordParser swp = SpecialWordParser.getInstance();
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		DayParser dp = DayParser.getInstance();
		boolean[] isModified = new boolean[dayTokens.length];
		boolean isTdyOnce = false;
		boolean isNowOnce = false;

		initializeArray(isModified);

		for (int i = 0; i < dayTokens.length; i++) {
			String firstToken = dayTokens[i];
			StringBuffer changedTokens = new StringBuffer();

			if (isParseFree(firstToken)) {
				isModified[i] = true;
				continue;
			}

			if (dp.isDay(firstToken) || swp.isWk(firstToken)) {
				isModified[i] = true;

				if (dp.isTdy(firstToken)) {
					if (isTdyOnce) {
						dayTokens[i] = null;
						continue;
					} else {
						changedTokens.append(firstToken);
						isTdyOnce = true;
					}
				} else if (dp.isNow(firstToken)) {
					if (isNowOnce) {
						dayTokens[i] = null;
						continue;
					} else {
						changedTokens.append(firstToken);
						isNowOnce = true;
					}
				} else {

					for (int j = i - 1; j >= 0; j--) {
						if (isModified[j]) {
							break;
						}

						isModified[j] = true;
						String token = dayTokens[j];
						if (swp.isSpecialWord(token)) {
							changedTokens.append(token + STRING_SPACE);
							dayTokens[j] = null;
							isModified[j] = true;
						} else {
							break;
						}
					}
					changedTokens.append(firstToken);
				}

				try {
					// System.err.println(changedTokens.toString());
					//dayTokens[i] = datm.parseDayToDate(changedTokens.toString()
					//		.trim());
					dayTokens[i] = DateAndTimeRetriever.STRING_QUOTES + parseOnlyDayToDate(changedTokens.toString());
				} catch (InvalidDayException e) {
					assert (false);
				}
			}
		}

		dayBuilder = buildString(dayTokens, dayBuilder);
		return dayBuilder.toString().trim();
	}

	/**
	 * 
	 * @param numberedInput
	 * @return
	 */
	private String parseHolidayDates(String numberedInput) {
		String[] numberInputTokens = numberedInput.split(DateAndTimeRetriever.STRING_SPACE);
		boolean[] isModified = new boolean[numberInputTokens.length];
		StringBuffer holidayString = new StringBuffer();

		for(int noOfWords = 3; noOfWords >= 1; noOfWords--){
			initializeArray(isModified);
			parseNHoliday(numberInputTokens, isModified, noOfWords);
		}
		holidayString = buildString(numberInputTokens, holidayString);
		
		return holidayString.toString().trim();
	}

	/**
	 * @param numberInputTokens
	 * @param isModified
	 */
	private void parseNHoliday(String[] numberInputTokens, boolean[] isModified, int noOfWords) {
		LOGGER.info("In parseNHoliday, noOfWords are " + noOfWords);
		
		HolidayDatesParser holidayParser = HolidayDatesParser.getInstance();
		for (int i = noOfWords - 1; i < numberInputTokens.length; i++) {
			String token = numberInputTokens[i];
			LOGGER.info("currect token is " + token);

			String holidayInput = null;
			
			if (isParseFree(token)) {
				isModified[i] = true;
				continue;
			}

			// search 3 words:
			if (allNotModified(isModified, i, noOfWords)) {
				StringBuffer holidayBuilder = new StringBuffer();
				for (int j = i - noOfWords + 1 ;j <= i - 1; j++) {
					String pastToken = numberInputTokens[j];
					LOGGER.info("pastToken is " + pastToken);
					holidayBuilder.append(pastToken + STRING_SPACE);
				}
				holidayBuilder.append(token);
				
				LOGGER.info("constructed string is " + holidayBuilder.toString());
				
				holidayInput = holidayParser.replaceHolidayDate(holidayBuilder.toString());
				
				LOGGER.info("after parsing, holidayInput is " + holidayInput);
				if (holidayInput != null) {
					numberInputTokens[i] = STRING_QUOTES + holidayInput;
					isModified[i] = true;
					for (int j = i - 1; j >= i - noOfWords + 1; j--) {
						numberInputTokens[j] = null;						
						isModified[j] = true;
					}
					
					// holidayString.append(holidayInput + " ");
				}
			}
		}
	}

	/**
	 * @param numberInputTokens
	 * @param holidayString
	 */
	private StringBuffer buildString(String[] anyTokens, StringBuffer anyString) {
		for (String token : anyTokens) {
			if (token != null) {
				anyString.append(token + DateAndTimeRetriever.STRING_SPACE);
			}
		}
		return anyString;
	}

	/**
	 * @param isModified
	 */
	private void initializeArray(boolean[] isModified) {
		for (int i = 0; i < isModified.length; i++) {
			isModified[i] = false;
		}
	}

	/**
	 * @param input
	 * @param datmParser
	 */
	protected String parseNumber(String input) {
		NumberParser np = NumberParser.getInstance();
		Scanner sc = new Scanner(input);
		StringBuffer changedString = new StringBuffer();
		StringBuffer numberString = new StringBuffer();
		boolean isNumberContinue = false;

		while (sc.hasNext()) {
			String token = sc.next();
			if (isParseFree(token) || !isNumber(token)) {
				if (isNumberContinue) {
					String realNumber = parseOnlyNumber(numberString
							.toString().trim());
					changedString.append(realNumber + DateAndTimeRetriever.STRING_SPACE);
					numberString = new StringBuffer();
				}

				changedString.append(token + DateAndTimeRetriever.STRING_SPACE);
				isNumberContinue = false;
			} else if (np.isDigitString(token)) {
				if (isNumberContinue) {
					String realNumber = parseOnlyNumber(numberString
							.toString().trim());
					changedString.append(realNumber + DateAndTimeRetriever.STRING_SPACE);
					numberString = new StringBuffer();
				}

				// System.err.println("AAA: " + token);
				isNumberContinue = false;
				String realNumber = parseOnlyNumber(token, false);
				changedString.append(realNumber + DateAndTimeRetriever.STRING_SPACE);
				numberString = new StringBuffer();
			} else {
				if (!isNumberContinue) {
					isNumberContinue = true;
				}
				numberString.append(token + DateAndTimeRetriever.STRING_SPACE);
			}
		}

		String realNumber = parseOnlyNumber(numberString.toString()
				.trim(), false);
		if (realNumber != null) {
			changedString.append(realNumber + DateAndTimeRetriever.STRING_SPACE);
		}

		sc.close();
		return changedString.toString().trim();
	}
	
	/**
	 * parseOnlyHoliday only can parse holiday...
	 * @param input
	 * @return
	 */
	protected String parseOnlyHoliday(String input){
		HolidayDatesParser hdp = HolidayDatesParser.getInstance();
		return hdp.replaceHolidayDate(input);
	}
	
	/**
	 * parseNumber: parse a language number to a real number String, ex: one to
	 * 1. It returns null when error occurs.
	 * 
	 * @param numberString
	 *            : language number or normal number
	 * @return String
	 */
	private String parseOnlyNumber(String numberString) {
		return parseOnlyNumber(numberString, true);
	}
	
	/**
	 * can only parse one to 1
	 * @param numberString
	 * @param isStrict
	 * @return
	 */
	private String parseOnlyNumber(String numberString, boolean isStrict) {
		NumberParser parser = NumberParser.getInstance();
		return parser.parseTheNumbers(numberString, isStrict);
	}

	protected boolean isNumber(String numberString) {
		NumberParser parser = NumberParser.getInstance();
		return parser.parseTheNumbers(numberString, true) != null;
	}
	
	/**
	 * To parse day to date
	 * @throws DatePassedException 
	 * @throws InvalidDayException 
	 */
	protected String parseOnlyDayToDate(String input) throws InvalidDayException{
		DayParser dayParser = DayParser.getInstance();
		return dayParser.parseDayToDate(input);
	}
	
	/**
	 * convertToSecond: convert time from any unit to second
	 * 
	 * @param timeString
	 *            : time value + time unit, ex: 1 min, one min, 1s
	 * @return: String
	 * @throws NullTimeUnitException
	 *             : User did not key in time unit
	 * @throws NullTimeValueException
	 *             : User did not key in time value / not valid time value
	 */
	protected String convertToSecond(String timeString)
			throws NullTimeUnitException, NullTimeValueException {
		TimeWordParser twp = TimeWordParser.getInstance();
		return twp.parseTimeWord(timeString);
	}
	
	/**
	 * parseOnlyDate: parse different formats of Date
	 * 
	 * @return timeString, in dd/mm/yyyy 
	 * @throws InvalidDateException 
	 */
	protected String parseOnlyDate(String dateString) throws InvalidDateException{
		DateParser dateParser = DateParser.getInstance();
		return dateParser.parseDate(dateString);
	}
	
	/**
	 * only can parse normal time, such as 1am, 11:00 ......
	 * but can parse next hour, 1 hour later......
	 * @param timeString
	 * @return
	 * @throws TimeErrorException
	 * @throws InvalidTimeException
	 */
	protected String parseOnlyTimeInput(String timeString) throws TimeErrorException, InvalidTimeException {
		TimeParser tp = TimeParser.getInstance();
		return tp.parseTimeInput(timeString);
	}
	
	protected String parseOnlyTimeWord(String input) throws NullTimeUnitException, NullTimeValueException{
		return TimeWordParser.getInstance().parseTimeWordWithSpecialWord(input);
	}
	
	/**
	 * getTodayTime: return the current time.
	 * 
	 * @return String
	 */
	protected String getTodayTime() {
		//_dateAndTimeObject = new DateAndTime();
		return _dateAndTimeObject.getCurrentTime();
	}

	/**
	 * getTodayDate: return today's date
	 * 
	 * @return String
	 */
	protected String getTodayDate() {
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		return _dateAndTimeObject.getCurrentDate();
	}

	/**
	 * getTodayDay: return today's day
	 * 
	 * @return String
	 */
	protected String getTodayDay() {
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		return _dateAndTimeObject .getCurrentDay();
	}

	/**
	 * getTodayDateAndTime: to get today's date and the current time
	 * 
	 * @return String
	 */
	protected String getTodayDateAndTime() {
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		return _dateAndTimeObject.getCurrentTimeAndDate();
	}
	
	/**
	 * format: dd/MM/yyyy HH:mm
	 * @param dateString
	 * @throws ParseException
	 */
	protected void setDebug(String dateString) throws ParseException{
		_dateAndTimeObject.setDebugDate(dateString);
	}
	
	/**
	 * ==================BELOW is DEPRECATED method================================================================ 
	 */
	
	/**
	 * In an input string, check if there is valid time
	 * @deprecated
	 * @param inputString
	 * @return time
	 */
	protected TimeObject findTime(String inputString) {
		TimeObject timeObject = null;

		String parsedTime = isValidTime(inputString);
		if (isNotEmptyParsedString(parsedTime)) {
			timeObject = createNewTimeObject(parsedTime, inputString);
		}
		return timeObject;
	}

	/**
	 * Helper methods for checking valid time in a String
	 * @deprecated
	 * @param input
	 * @return
	 */
	private String isValidTime(String input) {
		input = trimInput(input);
		TimeParser tp = TimeParser.getInstance();
		try {
			return tp.parseTimeInput(input);
		} catch (TimeErrorException | InvalidTimeException e) {
			return STRING_EMPTY;
		}
	}
	
	/**
	 * @deprecated
	 * @param parsedTime
	 * @param inputTime
	 * @return
	 */
	private TimeObject createNewTimeObject(String parsedTime, String inputTime) {
		return new TimeObject(parsedTime.trim(), inputTime.trim());
	}

	/**
	 * In an input string, check if there is valid date
	 * @deprecated
	 * 
	 * @param inputString
	 * @return date
	 */
	protected DateObject findDate(String inputString) {
		DateObject dateObject = null;

		String parsedDate = isValidDate(inputString);
		if (isNotEmptyParsedString(parsedDate)) {
			dateObject = createDateObject(parsedDate, inputString);
		}
		return dateObject;
	}


	/**
	 * Helper method for checking valid date in a String 
	 * @deprecated
	 * @param input
	 * @return
	 */
	private String isValidDate(String input) {
		input = trimInput(input);
		DateParser dateParser = DateParser.getInstance();
		try {
			return dateParser.parseDate(input);
		} catch (InvalidDateException e) {
			return STRING_EMPTY;
		}
	}

	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private String trimInput(String input) {
		input = input.trim();
		return input;
	}

	/**
	 * @deprecated
	 * @param parsedDate
	 * @param input
	 * @return
	 */
	private DateObject createDateObject(String parsedDate, String input) {
		return new DateObject(parsedDate, input.trim());
	}

	/**
	 * @deprecated
	 * @param parsedString
	 * @return
	 */
	private boolean isNotEmptyParsedString(String parsedString) {
		return !parsedString.equals(STRING_EMPTY);
	}
	
	/**
	 * @deprecated
	 * @param input
	 */
	@SuppressWarnings("unused")
	private String createDesc(String input) {
		String desc = input.trim();

		if (!desc.startsWith(DateAndTimeRetriever.STRING_QUOTES)) {
			desc = DateAndTimeRetriever.STRING_QUOTES + desc;
		}

		if (!input.endsWith(DateAndTimeRetriever.STRING_QUOTES)) {
			desc = desc + DateAndTimeRetriever.STRING_QUOTES;
		}

		return desc;
	}

	/**
	 * @deprecated : moved to DayParser
	 * @param dayString
	 * @return
	 */
	@SuppressWarnings("unused")
	private String parseTodayAndNow(String dayString) {
		String[] todayAndNowTokens = dayString.split(DateAndTimeRetriever.STRING_SPACE);
		StringBuffer todayAndNowBuilder = new StringBuffer();
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		//String todayDate = datm.getTodayDate();
		//String now = datm.getTodayDateAndTime();
		
		String todayDate = getTodayDate();
		String now = getTodayDateAndTime();

		for (int i = 0; i < todayAndNowTokens.length; i++) {
			String token = todayAndNowTokens[i];
			if (isToday(token)) {
				todayAndNowTokens[i] = todayDate;
			} else if (isNow(token)) {
				todayAndNowTokens[i] = now;
			}
		}

		todayAndNowBuilder = buildString(todayAndNowTokens, todayAndNowBuilder);

		return todayAndNowBuilder.toString().trim();
	}
	
	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private boolean isToday(String input) {
		input = input.toUpperCase();
		for (int i = 0; i < KEYWORD_TODAY.length; i++) {
			if (KEYWORD_TODAY[i].equals(input)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private boolean isNow(String input) {
		input = input.toUpperCase();
		for (int i = 0; i < KEYWORD_NOW.length; i++) {
			if (KEYWORD_NOW[i].equals(input)) {
				return true;
			}
		}
		return false;
	}
	
	/*
	public static void main(String[] args) {
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		/*
		 * System.out .println(datr.getAlphaNumericSpaceDesc(
		 * "I am looking for Lynnette. She is going home on Monday."));
		 * System.out .println(datr.getAlphaNumericSpaceDesc(
		 * "I am looking for Lynnette. She is going home on 1/4/15 12:00."));
		 * System.out.println(datr.parseNumber("one one one aaa one one one"));
		 * System.out.println(datr.parseNumber("one one one aaa"));
		 * System.out.println(datr.parseNumber("aaa")); System.out
		 * .println(datr.
		 * parseHolidayDates("last Christmas I gave you my heart Christmas"));
		 * System.out .println(datr.parseHolidayDates(
		 * "last New Year I gave you my heart Christmas")); System.out
		 * .println(datr
		 * .parseHolidayDates("last April Fool Day I gave you my heart Christmas"
		 * )); System.out.println(datr.parseDay("Monday I want to eat Monday"));
		 * System.out .println(datr.parseDay(
		 * "next nxt NXT prev Monday I want to catch Pokemon!")); System.out
		 * .println
		 * (datr.parseDay("next ASH nxt Monday I want to catch Pokemon nxt Fri !"
		 * )); System.out
		 * .println(datr.parseDate("1 / 11 / 2014 , I watch movie in 1 December"
		 * )); System.out.println(datr.parseTime("1 am"));
		 * System.out.println(datr.parseDate("11/11/2015"));
		 * System.out.println(datr.parseTime("11:00"));
		 * System.out.println(datr.formatDateAndTimeInString("aaa"));
		 */
		/*
		 * try { System.out.println(datr.formatDateAndTimeInString(
		 * "aaa at 11/3 by 3/4 11pm")); } catch (InvalidQuotesException e) { //
		 * TODO Auto-generated catch block e.printStackTrace(); }
		 

		try {
			String noQuoteDesc = datr.removeParseFreeZone("\" aaaa \" bbbb ");
			System.out.println(noQuoteDesc);
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		/*
		 * try { System.out .println(datr.formatDateAndTimeInString(
		 * "do cs2010 assignment by nxt nxt Wk")); } catch
		 * (InvalidQuotesException e) { // TODO Auto-generated catch block
		 * e.printStackTrace(); }
		 

		try {
			System.out.println(datr.formatDateAndTimeInString("11:00"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// VERY IMP TEST CASE
		try {
			System.out.println(datr.searchTimeAndDate("12:00 06/04/2014")
					.toString());
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		System.out.println(datr.parseTimeWord("1 hour"));

		System.out.println(datr.parseTodayAndNow("find Lynnette by Today"));

		try {
			System.out
					.println(datr
							.formatDateAndTimeInString("\"FRIDAY\" asked me to deliver potion to Ivy nxt nxt Tue"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		try {
			System.out.println(datr
					.formatDateAndTimeInString("one one one 1 one one "));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// VERY IMP TEST CASE
		try {
			System.out.println(datr.searchTimeAndDate(
					"20:14 05/04/2014 03/02/2014").toString());
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		try {
			System.out.println(datr
					.formatDateAndTimeInString("aaa tmr 11.59pm"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		/*BUG HAPPENS when two numbers come together*/
		
		/*
		try {
			System.out.println(datr
					.formatDateAndTimeInString("use calculator 570 11/11/15"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			System.out.println(datr
					.formatDateAndTimeInString("use calculator 570 11:11"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		*
		*//*
		
		//System.out.println(datr.parseNumber("one one one 1 aaa one one one"));
		//System.out.println(datr.parseNumber("one one one aaa"));
		//System.out.println(datr.parseDay("a today"));
		
		try {
			System.out.println(datr
					.formatDateAndTimeInString("a today"));
		} catch (InvalidQuotesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// System.out.println("AAA".split(" ").length);
	}
	*/
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTimeRetriever.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DayParser.java
	 */


package com.taskpad.dateandtime;

import java.util.HashMap;
import java.util.Map;

/**
 * DayParser: a singleton parser that parses day such as Monday, Tuesday,
 * and also BigFestival such as Christmas and New Year
 * 
 */

public class DayParser {

	private static final String SPACE = " ";

	//private static final String DAY_INVALID = "Not a valid day";
	
	private static Map<String, Integer> _mapWeek = new HashMap<String, Integer>();
	
	
	private static final String[] DAY_TODAY = {
		"today", 
		"tdy",
		"2day"
	};
	
	private static final String[] DAY_NOW = { 
		"now",
		"nw"
	};
	
	private static final String[] DAY_IN_WEEK = {
		"sunday", 
		"monday",
		"tuesday",
		"wednesday",
		"thursday",
		"friday",
		"saturday",
		
		"sun",
		"mon",
		"tue",
		"wed",
		"thu",
		"fri",
		"sat",
		
		"sund",
		"mond",
		"tues",
		"wedn",
		"thur",
		"frid",
		"satd",
		
		"sunda",
		"monda",
		"tuesd",
		"wedne",
		"thurs",
		"frida",
		"satur"
	};
	
	private static DayParser _parseDay = new DayParser();
	
	private DayParser(){
		initializeMapWeek();
	}
	
	protected boolean isDay(String input){
		if( _mapWeek.containsKey(input.toLowerCase())){
			return true;
		} else {
			for (String todayVariation : DAY_TODAY){
				if (todayVariation.equals(input)){
					return true;
				}
			}
			
			for (String nowVariation : DAY_NOW){
				if (nowVariation.equals(input)){
					return true;
				}
			}
		}
		
		return false;
	}

	protected boolean isTdy(String input) {
		for (String nowVariation : DAY_NOW){
			if (nowVariation.equals(input)){
				return true;
			}
		}

		return false;
	}
	
	protected boolean isNow(String input) {
		for (String todayVariation : DAY_TODAY) {
			if (todayVariation.equals(input)) {
				return true;
			}
		}

		return false;
	}

	private void initializeMapWeek() {		
		for (int i = 0; i < DAY_IN_WEEK.length; i++){
			_mapWeek.put(DAY_IN_WEEK[i], i % 7);
		}
	}

	protected static DayParser getInstance(){
		return _parseDay;
	}
	
	
	/**
	 * parseDayToDate: to get the date of the day
	 * @param input String
	 * @return String
	 * @throws InvalidDayException 
	 * @throws DatePassedException 
	 */
	protected String parseDayToDate(String input) throws InvalidDayException{
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		
		if (input == null || input.trim().isEmpty()){
			throw new InvalidDayException();
		}
		
		input = input.toLowerCase();
		for (String todayVariation : DAY_TODAY){
			if (todayVariation.equals(input)){
				return datr.getTodayDate();
			}
		}
		
		for (String nowVariation : DAY_NOW){
			if (nowVariation.equals(input)){
				return datr.getTodayDateAndTime();
			}
		}
		
		SpecialWordParser swp = SpecialWordParser.getInstance();
		String specialDay = null;

		String[] analyzes = input.split(SPACE);
		int len = analyzes.length;

		int userDay = -1;
		try {
			userDay = parseDayToInt(analyzes[len - 1]);
		} catch (InvalidDayException e) {
			//do nothing
			//because it maybe is word like tmr
		}

		specialDay = input.substring(0, input.lastIndexOf(analyzes[len - 1])).trim();
		boolean isDay = userDay >= 0 && userDay < 7;
		if (isDay){
			specialDay = swp.parseSpecialDay(specialDay, userDay);
		} else {
			specialDay = swp.parseSpecialDay(specialDay, analyzes[len - 1]);
		}
		
		specialDay = discardTime(specialDay);

		return specialDay;
	}

	/**
	 * @param specialDay
	 * @return
	 */
	private String discardTime(String specialDay) {
		if (specialDay != null){
			specialDay = specialDay.split(SPACE)[0];
		}
		return specialDay;
	}
	
	/**
	 * should pass in String like Sunday, Monday
	 * Mon, Monday and parses them to int
	 * @param input
	 * @return int
	 * @throws InvalidDayException 
	 */
	protected int parseDayToInt(String input) throws InvalidDayException{
		//initializeMapWeek();
		
		if (input == null){
			throw new InvalidDayException();
		}
		
		Integer value = _mapWeek.get(input.toLowerCase());
		
		if (value == null){
			throw new InvalidDayException();
		}
		
		return value.intValue();
	}
	
	public static void main(String[] args){
		DayParser a = DayParser.getInstance();
		
		/*
		String input = "next next prev Sun";
		String sub = "";
		for (int i=0; i<input.length(); i++){
			for (int j=1; j<=input.length()-i; j++){
				sub = input.substring(i, i+j);
				try {
					System.out.println(a.parseDayToDate(sub));
				} catch (InvalidDayException | DatePassedException e) {
					// TODO Auto-generated catch block
					//e.printStackTrace();
				}
			}
		}
		*/
		
		try {
			System.out.println(a.parseDayToDate("MAN"));
		} catch (InvalidDayException e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DayParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidDayException.java
	 */


package com.taskpad.dateandtime;


public class InvalidDayException extends Exception{
	/**
	 * generated
	 */
	private static final long serialVersionUID = 2392793659585047867L;	
	
	private static final String MESSAGE = "Error: Invalid Day";
		
	public InvalidDayException() {
		super(MESSAGE);
	}

	public InvalidDayException(String message) {
		super(MESSAGE + ": " + message);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidDayException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidQuotesException.java
	 */


package com.taskpad.dateandtime;

public class InvalidQuotesException extends Exception{
	/**
	 * generated
	 */
	private static final long serialVersionUID = 1973772979261355980L;
	
	private static final String MESSAGE = "Error: Cannot have odd numbers of quotes";
		
	public InvalidQuotesException() {
		super(MESSAGE);
	}

	public InvalidQuotesException(String message) {
		super(MESSAGE + ": " + message);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidQuotesException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NullTimeUnitException.java
	 */


package com.taskpad.dateandtime;

import java.util.logging.Logger;

/**
 * 
 * NullTimeUnitException: an exception thrown when users did not
 * key in time unit
 */

public class NullTimeUnitException extends Exception{
	/**
	 * generated
	 */
	private static final long serialVersionUID = -4075294108323634736L;
	
	private static final String MESSAGE = "Error: Please enter a time unit";
	
	protected static Logger _logger = Logger.getLogger("TaskPad");
	
	public NullTimeUnitException(){
		super(MESSAGE);
		_logger.info(MESSAGE);
	}
	
	public NullTimeUnitException(String Message){
		super (MESSAGE);
		_logger.info(MESSAGE);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NullTimeUnitException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NumberParser.java
	 */


package com.taskpad.dateandtime;


import java.util.HashMap;
import java.util.Map;

public class NumberParser {

	private Map<String, Integer>  _numberMap = new HashMap<String, Integer>();
	
	private final Integer singleDigitChecker = 10;
	private final String STRING_EMPTY = "";
	private final String[] _tensNames = {
		"zero",
		"ten",
		"twenty",
		"thirty",
		"forty",
		"fifty",
		"sixty",
		"seventy",
		"eighty",
		"ninety"
	};


	private final String[] _numNames = {
		"zero",
		"one",
		"two",
		"three",
		"four",
		"five",
		"six",
		"seven",
		"eight",
		"nine",
		"ten",
		"eleven",
		"twelve",
		"thirteen",
		"fourteen",
		"fifteen",
		"sixteen",
		"seventeen",
		"eighteen",
		"nineteen"
	};

	private static NumberParser _numberParser = new NumberParser();
	
	private NumberParser(){	
		initializeNumberMap();
	}
	
	protected static NumberParser getInstance(){
		return _numberParser;
	}

	private void initializeNumberMap() {
		initializeWithNumNames();
		initializeWithTensNames();
	}

	private void initializeWithTensNames() {
		for (int i = 1; i < _tensNames.length; i++){
			String key = _tensNames[i];
			Integer value = i * 10;
			_numberMap.put(key, value);
		}
	}

	private void initializeWithNumNames() {
		for (int i = 0; i < _numNames.length; i++){
			String key = _numNames[i];
			Integer value = i;
			_numberMap.put(key, value);
		}
	}

	//this method returns null when error occurs
	protected String parseTheNumbers(String input, boolean isStrict){
		//cannot reach here if input is null
		assert (input != null);
		
		//System.err.println(input + " " + isDigitString(input));
		
		if (isDigitString(input)){
			if (!isStrict){
				//System.err.println("DD " + input);
				return input;
			} else {
				return STRING_EMPTY + Integer.parseInt(input);
			}
			//return STRING_EMPTY + Integer.parseInt(input);
			//return STRING_EMPTY + Double.parseDouble(input);
		}
		
		String[] numWords = input.split(" ");
		Integer total = null;
		int space = 0;
		boolean isFirstPass = true;
		
		for (int i = numWords.length - 1 ; i >= 0; i--){
			String key = getKey(numWords, i); 
						
			boolean hasSuchNumber = _numberMap.containsKey(key);
			boolean isEmptyString = STRING_EMPTY.equals(key);
			
			if(isEmptyString){
				space++;
				continue;
			}
			
			if (!hasSuchNumber){
				return null;
			}
			
			Integer value = _numberMap.get(key);
			
			if (isFirstPass){
				total = value;
				isFirstPass = false;
			} else {
				total = combineNumbers(numWords, total, i, value, space);
			}
		}
		
		//is either empty string or string with spaces
		if (total == null){
			return null;
		}
		
		return STRING_EMPTY + total;
	}

	protected boolean isDigitString(String input) {
		if (input != null){
			input = input.trim();
		}
		
		try{
			Integer.parseInt(input);
			//Double.parseDouble(input);
			return true;
		} catch (NumberFormatException e){
			return false;
		}
	}

	private String getKey(String[] numWords, int pos) {
		String key = numWords[pos];
		key = key.toLowerCase();
		return key;
	}
	
	private Integer combineNumbers(String[] numWords, Integer total, int i,
			Integer value, int space) {
		boolean isNotSingleDigit = singleDigitChecker.compareTo(value) < 0;
		if (isNotSingleDigit){
			total += value;
		} else {
			Integer digitLocation = (int)Math.pow(10, (int) numWords.length - i - 1 - space);
			total += value * digitLocation;
		}
		return total;
	}

	/*testing
	public static void main(String[] args){
		NumberParser parseNumWord = new NumberParser();
		System.out.println(parseNumWord.parseTheNumbers("one")); 
		System.out.println(parseNumWord.parseTheNumbers("ONe"));
		System.out.println(parseNumWord.parseTheNumbers("Twenty one"));
		System.out.println(parseNumWord.parseTheNumbers("One ONe"));
		System.out.println(parseNumWord.parseTheNumbers("One ONe ONE"));
		System.out.println(parseNumWord.parseTheNumbers("One    ONE"));
		
		/*
		 * expected output:
		 * 1
		 * 1
		 * 21
		 * 11
		 * 111
		 * 11
		 *//*
	}
	//*/

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NumberParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\SpecialWordParser.java
	 */


package com.taskpad.dateandtime;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * SpecialWordParser: parses special words like next and previous
 *  
 */



public class SpecialWordParser {
	
	private static final String SPACE = " ";

	private static final int DAY_WEEK = 7;

	private static final String EMPTY = "";

	//private static Map<Integer, String[]> MAP_SPECIAL_WORD = new HashMap<Integer, String[]>();
	private static Map<String, Integer> MAP_SPECIAL_WORD = new HashMap<String, Integer>();
	private static Map<String, Integer> MAP_DAY = new HashMap<String, Integer>();
		
	private static final String[] MAP_TMR = {
		"TMR", "TOMORROW", "TOMORRO", "TOM"
	};
	
	private static final String[] MAP_YTD = {
		"YTD", "YESTERDAY", "YEST"
	};
	
	private static final String[] MAP_WK = {
		"WK", "WEEK", "WEK"
	};
	
	private static final String[] MAP_NXT = {
		"NEXT", "NXT", "FOLLOWING", "COMING"
	};
	
	private static final String[] MAP_PREV = {
		"PREVIOUS", "PREV", "PAST", "LAST", "YESTERDAY"
	};
	
	private static final String[] MAP_THIS = {
		"THIS"
	};
	
	private static SpecialWordParser _specialWordParser = new SpecialWordParser();
	
	private SpecialWordParser(){
		initialiseSpecialWordMap();
	}
	
	protected static SpecialWordParser getInstance(){
		return _specialWordParser;
	}
	
	protected String parseSpecialDay(String specialDay, String lastWord) throws InvalidDayException{
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		//String todayDay = datm.getTodayDay();
		String todayDay = datr.getTodayDay();
		int userDay = -1;
		lastWord = lastWord.toUpperCase();
		
		userDay = getTodayDay(todayDay);
		for (String myWk : MAP_WK){
			if (myWk.equals(lastWord)){
				if (specialDay == null || specialDay.trim().isEmpty()){
					throw new InvalidDayException();
				}
				
				return parseSpecialDay(specialDay, userDay);
			}
		}
		
		int day = 0;
		int chance = 2;
		for (String myYtd : MAP_YTD){
			if (myYtd.equals(lastWord)){
				day--;
			}
		}
		
		if (day == 0){
			chance--;
		}
		
		for (String myTmr : MAP_TMR){
			if (myTmr.equals(lastWord)){
				day++;
			}
		}
		
		if (day == 0){
			chance--;
		}
		
		if (chance == 0){
			throw new InvalidDayException();
		}
		
		specialDay = specialDay.toUpperCase();
		String[] tokens = specialDay.split(SPACE);
		
		for (int i = tokens.length - 1; i >=0 ; i--){
			Integer value = MAP_DAY.get(tokens[i]);
			
			if (value == null){
				break;
			}
			
			day += value.intValue();
			
		}
		
		/*
		if (day < 0){
			throw new InvalidDayException();
		}
		*/
		
		TimeWordParser twp = TimeWordParser.getInstance();
		String ans = null;
		try {
			ans = twp.timeWord(day + "d");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			//it won't happen
			assert (false);
		}
		
		if (ans != null){
			return ans;
		} else {
			throw new InvalidDayException();
		}
		
	}
	
	protected String parseSpecialDay(String specialDay, int userDay){
		//DateAndTimeManager datm = DateAndTimeManager.getInstance();
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		TimeWordParser twp = TimeWordParser.getInstance();
		
		//String todayDay = datm.getTodayDay();
		String todayDay = datr.getTodayDay();
		int todayDayStat = getTodayDay(todayDay);
		int nxt = 1;
		
		//System.out.println(todayDay + " " + todayDayStat);
		
		if (specialDay.equals(EMPTY)){
			if (userDay < todayDayStat){
				nxt++;
			}
			return getNextDay(userDay, twp, todayDayStat, nxt, "d");
		}

		specialDay = specialDay.toUpperCase();
		
		nxt = calculateNext(specialDay, nxt);
		
		/*
		if (nxt <= 0){
			throw new DatePassedException();
		}
		*/
		
		return getNextDay(userDay, twp, todayDayStat, nxt, "d");
	}

	protected boolean isTmrYtd(String input){
		for (String tmr : MAP_TMR){
			if (tmr.equals(input.toUpperCase())){
				return true;
			}
		}
		
		for (String ytd : MAP_YTD){
			if (ytd.equals(input.toUpperCase())){
				return true;
			}
		}
		
		return false;
	}

	protected boolean isWk(String input){
		for (String myWk : MAP_WK){
			if (myWk.equals(input.toUpperCase())){
				return true;
			}
		}
		return false;
	}
	/**
	 * @param specialDay
	 * @param nxt
	 * @return
	 */
	private int calculateNext(String input, int nxt) {
		Scanner sc = new Scanner(input);
		
		while (sc.hasNext()){
			String specialToken = sc.next();

			Integer ans = MAP_SPECIAL_WORD.get(specialToken.toUpperCase());
			
			if (ans == null){
				break;
			}
			
			nxt += ans.intValue();
		}
		sc.close();
		return nxt;
	}

	/**
	 * @param userNum
	 * @param twp
	 * @param systemNum
	 * @param nxt
	 */
	private String getNextDay(int userNum, TimeWordParser twp, int systemNum, int nxt, String unit) {
		userNum -= systemNum;
		
		//if (userNum <= 0){
		//	userNum += DAY_WEEK;
		//}
		
		nxt--;
		userNum += DAY_WEEK * nxt;
		
		try {
			return twp.timeWord(userNum + unit);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assert (false);
		}
		return null;
	}

	private int getTodayDay(String todayDay) {
		DayParser dp = DayParser.getInstance();
		int todayDayStat = 0;
		try {
			todayDayStat = dp.parseDayToInt(todayDay);
		} catch (InvalidDayException e) {
			assert (false);
		}
		return todayDayStat;
	}
	
	/**
	 * parseSpecialWord parses special sentence like
	 * next next hour.
	 * 
	 * It can solve types like 
	 * next next hour
	 * (special words... + TimeUnit)
	 * 
	 * or
	 * 
	 * next next 1 hour 
	 * (sepcial words... + integer + TimeUnit)
	 * 
	 * It is the only method that parses words like next and prev.
	 * 
	 * @param specialWord String
	 * @return int
	 */
	protected String parseSpecialWord(String specialWord, int seconds){
		int nxt = 0;
		nxt = calculateNext(specialWord, nxt);
		
		seconds *= nxt;
		
		return seconds + EMPTY;
	}
	
	/**
	 * getTimeWordWithoutNext split special words
	 * with TimeWord
	 * @param input
	 * @return
	 */
	protected String getTimeWordWithoutSpecialWords(String input){
		String[] inputs = input.split(SPACE);
		
		for (int i = inputs.length - 1; i >= 0 ; i--){
			if (MAP_SPECIAL_WORD.containsKey(inputs[i].toUpperCase())){
				return inputs[i];
			}
		}
		
		return null;
	}
	
	private void initialiseSpecialWordMap() {
		initializeNextMap();
		initializePrevMap();
		initializeThisMap();
		initializeYtdMap();
		initializeTmrMap();
	}

	
	private void initializeTmrMap() {
		for (String myTmr : MAP_TMR){
			MAP_DAY.put(myTmr, +1);
		}
	}

	private void initializeYtdMap() {
		for (String myYtd : MAP_YTD){
			MAP_DAY.put(myYtd, -1);
		}
	}
	

	private void initializeThisMap() {
		for (String myThis : MAP_THIS){
			MAP_SPECIAL_WORD.put(myThis, 0);
		}
		
	}

	private void initializePrevMap() {
		//MAP_SPECIAL_WORD.put(+1, MAP_NXT);
		
		for (String next : MAP_NXT){
			MAP_SPECIAL_WORD.put(next, +1);
		}
		
	}

	private void initializeNextMap() {
		//MAP_SPECIAL_WORD.put(-1, MAP_PREV);		
		
		for (String prev : MAP_PREV){
			MAP_SPECIAL_WORD.put(prev, -1);
		}
	}
	
	protected boolean isSpecialWord(String input){
		return MAP_SPECIAL_WORD.containsKey(input.toUpperCase());
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\SpecialWordParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeWordParser.java
	 */


package com.taskpad.dateandtime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.logging.Logger;

/**
 *
 * make TimeWordParser to be a singleton to increase efficiency.
 */

public class TimeWordParser{
	private final static Logger LOGGER = Logger.getLogger("TaskPad");
	
	private static Map<String, String[]> _timewordsMap = new HashMap<String, String[]>();
	private static Map<String, Integer> _timeunitMap = new HashMap<String, Integer>();
	private static NumberParser _numberparser = NumberParser.getInstance();
	
	private static final String TIME_SEC = "SECOND";
	private static final String TIME_MIN = "MIN";
	private static final String TIME_HOURS = "HOUR";
	private static final String TIME_DAY = "DAY";
	private static final String TIME_WEEKS = "WEEK";
	private static final String TIME_MONTH = "MONTH";
	private static final String TIME_YEAR = "YEAR";
	private static final String ERROR_NULL_UNIT = "Does not contain time unit!";
	private static final String ERROR_NULL_VALUE = "Please key in time value!";
	private static final String SPACE = " ";
	private static final String BLANK = "";
	
	private final int CONSTANT_SECOND = 1;
	private final int CONSTANT_MINUTE = CONSTANT_SECOND * 60;
	private final int CONSTANT_HOURS = CONSTANT_MINUTE * 60;
	private final int CONSTANT_DAY = CONSTANT_HOURS * 24;
	private final int CONSTANT_WEEK = CONSTANT_DAY * 7;
	
	private static String _timeword = TimeWordParser.BLANK;
	private static String _numberword = TimeWordParser.BLANK;
	private String _userTimeword = TimeWordParser.BLANK;
	//private static int _index = -2;
	
	private static TimeWordParser _timewordParser = new TimeWordParser();
	
	private TimeWordParser(){
		initialiseTimewords();
		initializeTimeUnitMap();
	}

	private void initializeTimeUnitMap() {		
		_timeunitMap.put(TIME_SEC, CONSTANT_SECOND);
		_timeunitMap.put(TIME_MIN, CONSTANT_MINUTE);
		_timeunitMap.put(TIME_HOURS, CONSTANT_HOURS);
		_timeunitMap.put(TIME_DAY, CONSTANT_DAY);
		_timeunitMap.put(TIME_WEEKS, CONSTANT_WEEK);
	}
	
	protected static TimeWordParser getInstance(){
		return _timewordParser;
	}
	
	/*
	public static void main(String[] args){
		String input = "20 hours";
		TimeWordParser twp = TimeWordParser.getInstance();
		try {
			System.out.println(twp.timeWord(input));
		} catch (NullTimeUnitException | NullTimeValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	*/
	
	/**
	 * use to add time, but not parsing time! 
	 * @param input
	 * @return
	 * @throws NullTimeUnitException
	 * @throws NullTimeValueException
	 */
	protected String timeWord(String input) throws NullTimeUnitException, NullTimeValueException{	
		String time = parseTimeWord(input);
		Date futureDate = addTime(time, TIME_SEC);
		return formatTime(futureDate);
	}
	
	/*
	protected String timeWord(String input){	
		String time = TimeWordParser.BLANK;
		if (hasTimeWord(input)){
			input = removeTimeWord(input);
			_numberword = _numberparser.parseNumber(input);
			Date newTime = addTime();
			time = formatTime(newTime);
		}
		
		return time;
	}
	 */
	
	protected String parseTimeWordWithSpecialWord(String input) throws NullTimeUnitException, NullTimeValueException{	
		if (input == null || input.trim().isEmpty()){
			LOGGER.severe(input + " is null or empty!");
			throw new NullTimeUnitException(ERROR_NULL_UNIT);
		}
		
		String timeWord = null;
		String specialWord = null;
		
		SpecialWordParser swp = SpecialWordParser.getInstance();
		
		String splitWord = swp.getTimeWordWithoutSpecialWords(input);
		LOGGER.info("splitWord is " + splitWord);
		
		if (splitWord == null){
			splitWord = parseTimeWord(input);
			timeWord = splitWord + SPACE + TIME_SEC;
			
			LOGGER.info("No special word ex nxt!");
			LOGGER.info("input is " + input);
			LOGGER.info("timeWord is " + timeWord);
			return timeWord(timeWord);
		}
		
		int splitPlace = input.lastIndexOf(splitWord) + splitWord.length() + 1;
		int num = 0;
		
		LOGGER.info("splitPlace is " + splitPlace);
		
		specialWord = input.substring(0, splitPlace).trim();
		timeWord = input.substring(splitPlace, input.length()).trim();
		
		LOGGER.info("specialWord is " + specialWord);
		LOGGER.info("timeWord is " + timeWord);
		
		try {
			timeWord = parseTimeWord(timeWord);
			num = Integer.parseInt(timeWord);
			
			LOGGER.info("PARSED TIME WORD!");
			LOGGER.info("timeWord is " + timeWord);
			LOGGER.info("num is " + num);
			
			timeWord = swp.parseSpecialWord(specialWord, num);
			
			LOGGER.info("PARSED SPECIAL WORD!");
			LOGGER.info("timeWord is " + timeWord);
		} catch (NullTimeValueException e) {
			LOGGER.info("Caught NullTimeValueException!");
			LOGGER.warning(e.getMessage());
			
			num = calculateTimeWord(input);
			timeWord = swp.parseSpecialWord(specialWord, num);
			
			LOGGER.info("PARSED SPECIAL WORD!");
			LOGGER.info("timeWord is " + timeWord);
			LOGGER.info("num is " + num);
		}
		timeWord = timeWord + SPACE + TIME_SEC;
		
		LOGGER.info("Ready to return!!");
		LOGGER.info("timeWord is " + timeWord);

		return timeWord(timeWord);
	}
	
	protected String parseTimeWord(String input) throws NullTimeUnitException, NullTimeValueException{	
		if (input == null || input.equals(SPACE)){
			throw new NullTimeUnitException(ERROR_NULL_UNIT);
		}
		
		int realTime = 0;
		
		realTime = calculateEachTimeValues(realTime, input);
		return BLANK + realTime;
	}

	private int calculateEachTimeValues(int realTime,
			String input) throws NullTimeValueException, NullTimeUnitException {
		Scanner sc = new Scanner(input);
		StringBuffer tempTime = new StringBuffer(BLANK);
		while (sc.hasNext()){
			String oneSubstring = sc.next();
			tempTime.append(oneSubstring);
			
			int secondConvertion = calculateTimeWord(oneSubstring);
			
			LOGGER.info(oneSubstring + "\'s secondConvertion is " + secondConvertion);
			boolean hasTimeUnit = secondConvertion > 0;
			if (hasTimeUnit){
				StringBuffer oneSubStringAns = parseOneTimeWord(tempTime.toString());
				realTime += Integer.parseInt(oneSubStringAns.toString());
				tempTime = new StringBuffer(BLANK);
			} else {
				tempTime.append(SPACE);
			}
		}
		sc.close();
		
		boolean isTempTimeEmpty = tempTime.toString().equals(BLANK);
		if (!isTempTimeEmpty){
			throw new NullTimeUnitException(ERROR_NULL_UNIT);
		}
		return realTime;
	}

	private StringBuffer parseOneTimeWord(String input)
			throws NullTimeValueException, NullTimeUnitException {
		StringBuffer time = new StringBuffer();
		int exactTimeSecond = 0;
		int secondConvertion = calculateTimeWord(input);
		boolean hasTimeUnit = secondConvertion > 0;
		if (hasTimeUnit){
			input = removeTimeWord(input);
			input = input.trim();
			
			if (input == BLANK) {
				throw new NullTimeValueException(ERROR_NULL_VALUE);
			}
			
			boolean isStrict = false;
			_numberword = _numberparser.parseTheNumbers(input, isStrict);
			
			//System.err.println("DE: " + _numberword + " " + input);
			if (_numberword == null){
				throw new NullTimeValueException(ERROR_NULL_VALUE);
			}
			
			exactTimeSecond = convertSecond(secondConvertion);
			time.append(exactTimeSecond);
		} else {
			throw new NullTimeUnitException(ERROR_NULL_UNIT);
		}
		return time;
	}

	private int convertSecond(int secondConvertion) {
		return Integer.parseInt(_numberword) * secondConvertion;
	}
	
	private int calculateTimeWord(String input){
		String variations[];
		int multiply = 0;

		for (Map.Entry<String, String[]> entry : _timewordsMap.entrySet()){
			variations = entry.getValue();
			for (int i = 0; i < variations.length; i++){
				if (isValueFound(variations[i], input)){
					_timeword = entry.getKey();
					
					LOGGER.info("timeword is " + _timeword);
					
					Integer value = _timeunitMap.get(_timeword);
					
					if (value != null){
						multiply = value.intValue();
					}

					return multiply;
				}
			}
		}
		
		return multiply;
	}
	
	/*
	private boolean hasTimeWord(String input){
		String variations[];

		for (Map.Entry<String, String[]> entry : _timewordsMap.entrySet()){
			variations = entry.getValue();
			for (int i=0; i<variations.length; i++){
				if (isValueFound(variations[i], input)){
					_timeword = entry.getKey();
					return true;
				}
			}
		}
		
		return false;
	}*/

	private void initialiseTimewords() {
		initialiseSecString();
		initialiseMinString();
		initialiseHoursString();
		initialiseDayString();
		initialiseWeekString();
		initialiseMonthString();
		initialiseYearString();
	}
	
	protected boolean isValidTimeWord(String input){
		try {
			parseTimeWord(input);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			LOGGER.info(input + " is not a valid TimeWord");
			return false;
		}
		LOGGER.info(input + " is a valid TimeWord");
		return true;
	}
	
	protected boolean isTimeUnits(String input){
		return _timewordsMap.containsKey(input.toUpperCase());
	}

	private void initialiseSecString() {
		String secString[] = {"SEC", "SECONDS", "SECOND", "SECS", "S"};
		_timewordsMap.put(TIME_SEC, secString);
	}
	
	private void initialiseMinString() {
		String minString[] = {"MIN", "MINUTES", "MINUTE", "MINS", "M"};
		_timewordsMap.put(TIME_MIN, minString);
	}

	private void initialiseHoursString() {
		String hourString[] = {"HOUR", "HOURS", "HR", "HRS", "H"};
		_timewordsMap.put(TIME_HOURS, hourString);
		
	}

	private void initialiseDayString() {
		String dayString[] = {"DAY", "D", "DAYS"};
		_timewordsMap.put(TIME_DAY, dayString);
		
	}

	private void initialiseWeekString() {
		String weekString[] = {"WEEK", "WEEKS", "WK", "WKS"};
		_timewordsMap.put(TIME_WEEKS, weekString);
		
	}
	
	private void initialiseMonthString(){
		String monthString[] = {"MONTH", "MONTHS", "MTH", "MTHS"};
		_timewordsMap.put(TIME_MONTH, monthString);
	}

	private void initialiseYearString() {
		String yearString[] = {"YEAR", "YEARS", "YR", "YRS"};
		_timewordsMap.put(TIME_YEAR, yearString);
	}
	
	private boolean isInteger(String unknown){
		try {
			Integer.parseInt(unknown);
		} catch (NumberFormatException e){
			return false;
		}
		return true;
	}
	
	private boolean isValueFound(String value, String input) {
		if (input == null || input.trim() == BLANK){
			return false;
		}
				
		String timeValue;
		//int idx = 0;
		input = input.trim();
		input = input.toUpperCase();
		String[] numArr = input.split(SPACE);
		
		LOGGER.info("value is " + value + " while the input is " + input);

		
		/**
		 * Let's search for unit that is separated by SPACE first.
		 * The last word should be the time unit,
		 * but maybe it is "", so need to check.
		 */
		for (int i = numArr.length - 1; i >= 0; i--){
			
			if (numArr[i].equals(BLANK)){
				continue;
			} else {
				if (numArr[i].equals(value)){
					_userTimeword = value;
					return true;
				} else {
					//idx = i;
					break;
				}
			}
		}
				
		/**
		 * If it is not separated by SPACE, then it probably be something like this:
		 * num + unit, ex: 1s, 10m
		 */
		//timeValue = numArr[idx].substring(0, numArr[idx].length() - 1);
		//if (isInteger(timeValue)){
		boolean hasUnit = input.endsWith(value);
		if (hasUnit){
			timeValue = input.replace(value, BLANK);
			if (isInteger(timeValue)){
				_userTimeword = value;
				return true;
			}
		} 
		//}
		
		return false;
	}
	
	private  String removeTimeWord(String input){
		input = input.toUpperCase();
		int idx = input.lastIndexOf(_userTimeword);
		 
		//we should ensure we have already checked what is the _timeword before proceeding
		assert (idx >= 0);
		
		return input.substring(0, idx);
		/**
		 * below can only delete time unit 
		 * that is with SPACE which is no longer suitable
		 */
		/*
		int index = input.indexOf(' ', _index);
		String replace;
		if (index == -1){
			replace = input.substring(0, _index);
		} else {
			String temp = input.substring(_index, input.indexOf(' ', _index));
			replace = input.replace(temp, "");
		}
		*/ 
				
//		return input.replaceAll("(?i)"+_timewordOriginal, "").trim();
	}
	
	private String formatTime(Date time){
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		return sdf.format(time);
	}
	
	private Date addTime(String value, String unit){
		Date date = getCurrentTime();
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		
		int increment = Integer.parseInt(value);
		
		switch (unit){
		case TIME_SEC:
			cal.add(Calendar.SECOND, increment);
			break;
		case TIME_MIN:
			cal.add(Calendar.MINUTE, increment);
			break;
		case TIME_HOURS:
			cal.add(Calendar.HOUR, increment);
			break;
		case TIME_DAY:
			cal.add(Calendar.DAY_OF_YEAR, increment);
			break;
		case TIME_WEEKS:
			cal.add(Calendar.WEEK_OF_MONTH, increment);
			break;
		case TIME_MONTH:
			cal.add(Calendar.MONTH, increment);
			break;
		case TIME_YEAR:
			cal.add(Calendar.YEAR, increment);
			break;
		default:
			break;
	}
	
	return cal.getTime();
	}
	
	/*
	private Date addTime(){
		Date date = getCurrentTime();
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		
		int increment = Integer.parseInt(_numberword);
		
		switch (_timeword){
			case TIME_SEC:
				cal.add(Calendar.SECOND, increment);
				break;
			case TIME_MIN:
				cal.add(Calendar.MINUTE, increment);
				break;
			case TIME_HOURS:
				cal.add(Calendar.HOUR, increment);
				break;
			case TIME_WEEKS:
				cal.add(Calendar.WEEK_OF_MONTH, increment);
				break;
			case TIME_MONTH:
				cal.add(Calendar.MONTH, increment);
				break;
			case TIME_YEAR:
				cal.add(Calendar.YEAR, increment);
				break;
			default:
				break;
		}
		
		return cal.getTime();
	}
	*/
	
	private Date getCurrentTime(){
		Date date;
		//DateAndTimeManager dtm = DateAndTimeManager.getInstance();
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		//String todayTime = dtm.getTodayDateAndTime();
//		String todayTime = dtm.getTodayTime();	
		String todayTime = datr.getTodayDateAndTime();
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		try {
			date = sdf.parse(todayTime);
		} catch (ParseException e) {
			return null;	//To do: Handle exception
		}
		
		return date;
	}
	
	public static void main (String[] args){
		try {
			System.out.println(TimeWordParser.getInstance().parseTimeWordWithSpecialWord("next next 2 hour"));
		} catch (NullTimeUnitException | NullTimeValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeWordParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\TaskDeadlineComparator.java
	 */


package com.taskpad.execute;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;

import com.taskpad.storage.Task;

/**
 * TaskDeadlineComparator
 *
 * This is a comparator to compare two tasks according to their deadline
 */
public class TaskDeadlineComparator implements Comparator<Task>{
	/**
	 * compare: compare two tasks' Date
	 * 
	 * @param e1
	 *            : task1
	 * @param e2
	 *            : task2
	 * @return int
	 */
	@Override
	public int compare(Task e1, Task e2) {
		SimpleDateFormat dateConverter = new SimpleDateFormat(
				"dd/MM/yyyy HH:mm");
		Date d1, d2;
		try {
			d1 = dateConverter.parse(e1.getDeadline() + e1.getEndTime());
			d2 = dateConverter.parse(e2.getDeadline() + e2.getEndTime());
		} catch (ParseException e) {
			System.err.println(e.getMessage());
			return 0;
		}
		return d1.compareTo(d2);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\TaskDeadlineComparator.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Alarm.java
	 */


package com.taskpad.input;

import java.util.logging.Logger;

import com.taskpad.alarm.AlarmManager;
import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.NullTimeUnitException;
import com.taskpad.dateandtime.NullTimeValueException;


/**
 *
 * To implement an alarm
 * 
 * Syntax: alarm <desc> <time count> <time unit>
 * 
 * 
 */


public class Alarm{	
	private final static Logger LOGGER = Logger.getLogger("TaskPad");

	private static final String SPACE = " ";

	
	private static final String MESSAGE_NUMBER_ERROR = "Error: Invalid time format %s";
		
	public Alarm(String input, String fullInput) {
		initializeAlarm(input, fullInput);
	}

	private void initializeAlarm(String input, String fullInput) {
		String numberString = null;
		int time = -1;
		
		String[] splitInput = input.split(SPACE);
		numberString = findTimeUnit(splitInput);
		//numberString = successParseTime(input, numberString);
		LOGGER.info("initializing alarm......");
		LOGGER.info("numberString is : " + numberString);
		
		if (numberString == null){
			LOGGER.severe("can't find time unit...");
			return;
		}
		
		time = successParseInt(numberString);
		
		if (time == -1){
			LOGGER.severe("can't parse numberString to int... time = -1");
			return;
		}
		
		LOGGER.info("time is " + time);
		
		//String desc = findDesc(fullInput);
		String desc = findDesc(splitInput);
		
		LOGGER.info("desc is " + desc);
		
		InputManager.outputToGui("Creating alarm... " + fullInput);
		
		AlarmManager.initializeAlarm(desc, time);		
	}
	


	/**
	 * @param numberString
	 * @param time
	 * @return
	 */
	//error happens when time = -1 
	public int successParseInt(String numberString) {
		int time = -1;
		try{
			time = Integer.parseInt(numberString);
		} catch (NumberFormatException e){
			InputManager.outputToGui(String.format(MESSAGE_NUMBER_ERROR, numberString));
			time = -1;
		}
		return time;
	}

	/**
	 * @param splitInput
	 * @return
	 */
	private String findTimeUnit(String[] splitInput) {
		int sec = 0;
		
		LOGGER.info("findTimeUnit returns seconds...... Now starting to find! ");
		
		for (int i = splitInput.length - 1; i >= 0; i--){
			String numberString = successParseTime(splitInput[i]);
			
			LOGGER.info("1st: numberString is " + numberString);
			
			if (i == 0 && numberString == null){
				break;
			}
			
			if (numberString == null){
				String newNumberString = splitInput[i - 1] + " " + splitInput[i];
				numberString = successParseTime(newNumberString);
				
				LOGGER.info("2nd: numberString is " + numberString);
				
				if (numberString == null){
					LOGGER.info("has ntg");
					continue;
				} else {
					int num = successParseInt(numberString);
					sec += num;
					
					splitInput[i] = null;
					splitInput[i - 1] = null;
					
					LOGGER.info("num is " + num);
					LOGGER.info("sec is " + sec);
					i--;
				}
			} else {
				splitInput[i] = null;
				int num = successParseInt(numberString);
				sec += num;
				LOGGER.info("num is " + num);
				LOGGER.info("sec is " + sec);
			}
			
		}

		LOGGER.info("Overall time is " + sec);
		/* DEPRECATED
		try {
			numberString = successParseTime(splitInput[splitInput.length - 1], numberString);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			String newNumberString = "";
			//Currently alarm only supports 1m and 1s and not 1y etc.
			try{
				newNumberString = splitInput[splitInput.length-2] + " " + splitInput[splitInput.length-1];
			} catch (Exception e2){
				//InputManager.outputToGui("Error: Not a valid Alarm format");
				return numberString;
			}
			try {
				numberString = successParseTime(newNumberString, numberString);
			} catch (NullTimeUnitException | NullTimeValueException e1) {
				InputManager.outputToGui(e.getMessage());
			}
		}
		*/
		
		return "" + sec;
	}

	/**
	 * 
	 * @param input
	 * @param numberString
	 * @return
	 * @throws NullTimeUnitException
	 * @throws NullTimeValueException
	 */
	private String successParseTime(String input){
		DateAndTimeManager parser = DateAndTimeManager.getInstance();
		String numberString = "";
		try {
			LOGGER.info("parsing time word. Input is " + input);
			numberString = parser.convertToSecond(input);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			LOGGER.severe("Parse failed! :( return null!");
			return null;
		}
		LOGGER.info("PARSED! numberString is " + numberString);

		return numberString;
	}
	
	/**
	 * findDesc(String[]) replaced findDesc(String)
	 * @param splitInput
	 * @return
	 */
	private String findDesc(String[] splitInput) {
		StringBuffer descBuilder = new StringBuffer();
		
		for (String token : splitInput){
			if (token != null){
				descBuilder.append(token + SPACE);			
			}
		}
		return descBuilder.toString().trim();
	}

	/**
	 * replaced by findDesc(String[])
	 * @deprecated
	 * @param fullInput
	 * @return
	 */
	@SuppressWarnings("unused")
	private String findDesc (String fullInput){
		LOGGER.info("finding description in... " + fullInput);
		
		String inputString[] = fullInput.split(SPACE);
		int length = inputString.length;
		
		LOGGER.info("Size of InputString[] is " + inputString.length);
		
		String description = "";
		if (length == 4){
			for (int i = 1; i < length - 2; i++){
				description = description + inputString[i] + SPACE;
			}
		} else if (length == 3){
			for (int i = 1; i < length - 1; i++){
				description = description + inputString[i] + SPACE;
			}
		} 
		
		LOGGER.info("description is " + description);

		description = description.trim(); 
		return description;
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Alarm.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\TaskPadLauncher.java
	 */


package com.taskpad.launcher;



import java.util.logging.Logger;

import javax.swing.SwingUtilities;

import com.taskpad.execute.ExecutorManager;
import com.taskpad.ui.GuiManager;

public class TaskPadLauncher implements Runnable {
	private final String MESSAGE_WELCOME = "Welcome to Taskpad! Type a command or type \"help\"";
	private final static Logger LOGGER = Logger.getLogger("TaskPad");


	//TaskPadLauncher is meant to use in launcher package only
	protected TaskPadLauncher(){
	}
	
	
	@Override
	public void run() {
		//initialStorage(); DEPRECATED
		setUpGui();
		ExecutorManager.showReminder();
	}

	/* DEPRECATED
	private void initialStorage() {
		DataManager.initializeXml();
	}
	 */


	private void setUpGui() {
		GuiManager.callOutput(MESSAGE_WELCOME);
		GuiManager.startRemindingUser();
		LOGGER.info("SwingUtilities.isEventDispatchThread: " + SwingUtilities.isEventDispatchThread());
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\TaskPadLauncher.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\TaskPadMain.java
	 */


package com.taskpad.launcher;


import javax.swing.SwingUtilities;

import com.taskpad.ui.GuiManager;
 
/**
 * 
 * Author: Chan Jun Wei, Lynnette Ng Hui Xian, Wang Taining
 * Product: TaskPad
 * Team: W13-3j
 *
 */
public class TaskPadMain{
	
	private TaskPadMain(){
	}
	
	public static void main(String[] args){
		setUpLogging();
		runProgram();
	}
	  
	public static void runProgram() {
		GuiManager.initialGuiManager();
		
		Runnable runTaskPad = new TaskPadLauncher();
		SwingUtilities.invokeLater(runTaskPad);
	} 

	private static void setUpLogging() {
		LogManager.getInstance().setUpGlobalLogger();
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\TaskPadMain.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDateAndTimeRetriever.java
	 */


package com.taskpad.tests;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.util.ArrayList;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidQuotesException;

public class TestDateAndTimeRetriever {

	private DateAndTimeManager _datm = DateAndTimeManager.getInstance();
	
	/*below is testDebugDateFlag*/
	@Test
	public void testValidDebugDate1() {
		setupDebugEnvironment("11/04/2013 11:00");
		testDebugDateFlag("11/04/2013 12:00 later","1 hour later");
		testDebugDateFlag("11/04/2013 13:00 later","2 hour later");
		testDebugDateFlag("11/04/2013 12:00","nxt hour");
	}
	private void testDebugDateFlag(String expected, String input){
		try {
			assertEquals(expected, _datm.convertDateAndTimeString(input));
		} catch (InvalidQuotesException e) {
			fail();
		}
	}
	/*above is testDebugDateFlag*/	
	
	/*below is testFormatDateAndTimeInString*/
	@Test
	public void testValidFormatDateAndTimeInString1() {
		testFormatDateAndTimeInString(" null null null null null null", "", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString2() {
		testFormatDateAndTimeInString(" null null null null null null", " ", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString3() {
		testFormatDateAndTimeInString(null, null, "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString4() {
		testFormatDateAndTimeInString("I want to have lunch . null null 12/04/2014 00:00 null null", 
				"I want to have lunch now.", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString5() {
		testFormatDateAndTimeInString("I want to have lunch but not . null null 12/04/2014 00:00 null null", 
				"I want to have lunch now but not at today 1pm.", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString6() {
		testFormatDateAndTimeInString("I want to have lunch but not . null null 12/04/2014 00:00 null null", 
				"I want to have lunch now but not at  1pm today.", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString7() {
		testFormatDateAndTimeInString("I want to have lunch . 12/04/2014 13:00 12/04/2014 00:00 null null", 
				"I want to have lunch now by 1pm today.", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString8() {
		testFormatDateAndTimeInString("I want to have lunch . null null 12/04/2014 00:00 12/04/2014 13:00", 
				"I want to have lunch now until 1pm today.", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString9() {
		testFormatDateAndTimeInString("I want to have lunch but not null null 11/04/2014 13:00 null null", 
				"I want to have lunch now but not yesterday 1pm", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString10() {
		testFormatDateAndTimeInString("I want to have lunch but not null null 11/04/2014 13:00 null null", 
				"I want to have lunch now but not yesterday 1pm", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString11() {
		testFormatDateAndTimeInString(", null null 12/04/2014 00:00 null null", 
				"today,now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString12() {
		testFormatDateAndTimeInString(", null null 12/04/2014 00:00 null null", 
				"12am,now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString13() {
		testFormatDateAndTimeInString(", null null 13/04/2014 01:00 null null", 
				"tmr,1am", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString14() {
		testFormatDateAndTimeInString(", null null 13/04/2014 00:00 null null", 
				"tmr,", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString15() {
		testFormatDateAndTimeInString(", null null 13/04/2014 00:00 null null", 
				"tmr,tmr tmr", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString16() {
		testFormatDateAndTimeInString(", null null 12/04/2014 13:00 null null", 
				"1pm,3pm", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString17() {
		testFormatDateAndTimeInString(", , null null 11/04/2014 00:00 null null", 
				"yest,tmr tmr, now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString18() {
		testFormatDateAndTimeInString(", , null null 12/04/2014 00:01 null null", 
				"1pm,3pm, now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString19() {
		testFormatDateAndTimeInString(", 12/04/2014 23:59 null null null null", 
				"by today, by now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString20() {
		testFormatDateAndTimeInString(", 13/04/2014 00:01 null null null null", 
				"by tmr 12am,by tmr 00:01", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString21() {
		testFormatDateAndTimeInString(", 13/04/2014 01:00 null null null null", 
				"by tmr, by 1am", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString22() {
		testFormatDateAndTimeInString(", 13/04/2014 23:59 null null null null", 
				"by tmr,", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString23() {
		testFormatDateAndTimeInString(", 14/04/2014 23:59 null null null null", 
				"by tmr,by tmr tmr", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString24() {
		testFormatDateAndTimeInString(", 12/04/2014 15:00 null null null null", 
				"by 1pm,by 3pm", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString25() {
		testFormatDateAndTimeInString(", , 14/04/2014 23:59 null null null null", 
				"by yest,by tmr tmr,by now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString26() {
		testFormatDateAndTimeInString(", , 12/04/2014 15:00 null null null null", 
				"by 1pm,by 3pm,by now", "12/04/2014 00:01");
	}
	
	@Test
	public void testValidFormatDateAndTimeInString27() {
		testFormatDateAndTimeInString(", null null null null null null", 
				"by 12am,by now", "12/04/2014 00:01");
	}
	
	@Test
	public void testInvalidFormatDateAndTimeInString1() {
		testFailFormatDateAndTimeInString("Error: Cannot have odd numbers of quotes", 
				"One ppl named \"two\" want \" to have 1.", "12/04/2014 00:00");
	}
	
	private void testFormatDateAndTimeInString(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			String actual = _datm.formatDateAndTimeInString(input);
			assertEquals(expected, actual);
		} catch (InvalidQuotesException e) {
			fail();
		}		
	}
	
	private void testFailFormatDateAndTimeInString(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			_datm.formatDateAndTimeInString(input);
		} catch (InvalidQuotesException e) {
			assertEquals(expected, e.getMessage());
		}		
	}
	/*above is testFormatDateAndTimeInString*/
	
	/*below is testSearchTimeAndDate*/
	@Test
	public void testValidSearchTimeAndDate1() {
		ArrayList<String> expected = new ArrayList<String>();	
		testSearchTimeAndDate(expected, "", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate2() {
		ArrayList<String> expected = new ArrayList<String>();	
		expected.add("13:00 13/04/2014");
		testSearchTimeAndDate(expected, "tmr 1pm", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate3() {
		ArrayList<String> expected = new ArrayList<String>();	
		expected.add("13/04/2014");
		expected.add("13/04/2014");
		testSearchTimeAndDate(expected, "tmr, tmr", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate4() {
		ArrayList<String> expected = new ArrayList<String>();	
		expected.add("13:00 12/04/2014");
		expected.add("14:00 12/04/2014");
		testSearchTimeAndDate(expected, "1pm 2pm", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate5() {
		ArrayList<String> expected = new ArrayList<String>();	
		expected.add("13:00 13/04/2014");
		expected.add("14:00 13/04/2014");
		testSearchTimeAndDate(expected, "tmr 1pm tmr 2pm", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate6() {
		ArrayList<String> expected = new ArrayList<String>();	
		expected.add("13:00 13/04/2014");
		expected.add("14:00 13/04/2014");
		testSearchTimeAndDate(expected, "1pm tmr 2pm tmr", "12/04/2014 00:00");
	}
	
	@Test
	public void testValidSearchTimeAndDate7() {
		testSearchTimeAndDate(null, null, "12/04/2014 00:00");
	}
	
	@Test
	public void testInvalidSearchTimeAndDate1() {
		testFailSearchTimeAndDate("Error: Cannot have odd numbers of quotes", 
				"One ppl named \"two\" want \" to have 1.");
	}
	
	private void testSearchTimeAndDate(ArrayList<String> expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			ArrayList<String> actual = _datm.searchTimeAndDate(input);
			
			if (actual == null){
				assertEquals(expected, actual);
			} else {
				assertEquals (expected.size(), actual.size());
				
				for (int i = 0; i < expected.size(); i++){
					assertEquals(expected.get(i), actual.get(i));
				}
			}
		} catch (InvalidQuotesException e) {
			fail();
		}		
	}
	
	private void testFailSearchTimeAndDate(String expected, String input){
		try {
			_datm.searchTimeAndDate(input);
		} catch (InvalidQuotesException e) {
			assertEquals(expected, e.getMessage());
		}
		
	}
	/*above is testSearchTimeAndDate*/
	
	/*below is testConvertDateAndTimeString*/
	@Test
	public void testValidConvertDateAndTimeString1() {
		testConvertDateAndTimeString("find Lynnette on 14/04/2014","find Lynnette on Monday", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString2() {
		testConvertDateAndTimeString("next ASH 14/04/2014 I want to catch Pokemon 18/04/2014 !",
				"next ASH nxt Monday I want to catch Pokemon nxt Fri !", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString3() {
		testConvertDateAndTimeString("21/04/2014 I want to catch Pokemon !",
				"next nxt NXT prev Monday I want to catch Pokemon!", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString4() {
		testConvertDateAndTimeString("01/11/2014 , I watch movie in 01/12/2014",
				"1 / 11 / 2014 , I watch movie in 1 December", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString5() {
		testConvertDateAndTimeString("aaa at 11/03/2014 by 03/04/2014 23:00",
				"aaa at 11/3 by 3/4 11pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString6() {
		testConvertDateAndTimeString("do cs2010 assignment by 25/04/2014",
				"do cs2010 assignment by nxt nxt Wk", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString7() {
		testConvertDateAndTimeString("use calculator 570 11:11",
				"use calculator 570 11:11", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString8() {
		testConvertDateAndTimeString("use calculator 570 11/11/2015",
				"use calculator 570 11Nov 15", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString9() {
		testConvertDateAndTimeString("aaa 12/04/2014 23:59",
				"aaa tmr 11.59pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString10() {
		testConvertDateAndTimeString("Having CS2010 test with One May on : 17/04/2014 .",
				"Having CS2010 test with \"One May\" on :17April.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString11() {
		testConvertDateAndTimeString("We tried to fool Ms Lee on 01/04/2015 .",
				"We tried to fool Ms Lee on April    FOOL.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString12() {
		testConvertDateAndTimeString("We tried to fool Ms Lee on 01/04/2015 .",
				"We tried to fool Ms Lee on April FOOL day.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString13() {
		testConvertDateAndTimeString("This 25/12/2014 , I want to stay with my family !",
				"This christmas, I want to stay with my family!", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString14() {
		testConvertDateAndTimeString("We tried to fool Christmas on 01/04/2015 .",
				"We tried to fool \"Christmas\" on April FOOL day.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString15() {
		testConvertDateAndTimeString("We tried to fool Christmas 11/04/2014 11/04/2014 00:00 .",
				"We tried to fool \"Christmas\" tdy nw.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString16() {
		testConvertDateAndTimeString("We tried to fool Christmas nxt 11/04/2014 11/04/2014 00:00 , 22/04/2014 .",
				"We tried to fool \"Christmas\" nxt tdy nw, nxt  nxt prev nxt Tues.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString17() {
		testConvertDateAndTimeString("We tried to fool Christmas 11/04/2014 .",
				"We tried to fool \"Christmas\" tdy tdy tdy.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString18() {
		testConvertDateAndTimeString("We tried to fool Christmas 11/04/2014 00:00 .",
				"We tried to fool \"Christmas\" nw nw nw.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString19() {
		testConvertDateAndTimeString("We tried to fool Christmas nxt nxt 11/04/2014 00:00 15/04/2014 .",
				"We tried to fool \"Christmas\" nxt nxt nw Tues.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString20() {
		testConvertDateAndTimeString("We tried to fool Christmas 22/04/2014 11/04/2014 00:00 .",
				"We tried to fool \"Christmas\" nxt nxt Tues nw.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString21() {
		testConvertDateAndTimeString("We tried to fool Christmas 22/04/2014 nw .",
				"We tried to fool \"Christmas\" nxt nxt Tues \"nw\".", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString22() {
		testConvertDateAndTimeString("We tried to fool tdy 13/04/2014 13:00 .",
				"We tried to fool \"tdy\" tmr tmr 1pm.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString23() {
		testConvertDateAndTimeString("We tried to fool tdy 12/04/2014 13:00 .",
				"We tried to fool \"tdy\" tmr tmr ytd 1pm.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString24() {
		testConvertDateAndTimeString("We tried to fool tmr 12/04/2014",
				"We tried to fool \"tmr\" tmr tmr ytd", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString25() {
		testConvertDateAndTimeString("We tried to fool tmr 12/04/2014 13:00",
				"We tried to fool \"tmr\" tmr 1pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString26() {
		testConvertDateAndTimeString("We tried to fool tmr 12/04/2014 13:00",
				"We tried to fool \"tmr\" tmr 1.00pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString27() {
		testConvertDateAndTimeString("We tried to fool tmr 12/04/2014 13:00",
				"We tried to fool \"tmr\" tmr 13:00", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString28() {
		testConvertDateAndTimeString("We tried to fool 1pm 12/04/2014 13:00",
				"We tried to fool \"1pm\" tmr 1:00 pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString29() {
		testConvertDateAndTimeString("We tried to fool hour",
				"We tried to fool hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString30() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 01:00",
				"We tried to fool 1 hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString31() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 01:00",
				"We tried to fool next next prev hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString32() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 04:00",
				"We tried to fool next next 2 hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString33() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 01:00",
				"We tried to fool 1h", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString34() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 01:00",
				"We tried to fool 1hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString35() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 01:00",
				"We tried to fool nxt 1hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString36() {
		testConvertDateAndTimeString("We tried to fool nxt 1 11/04/2014 01:00",
				"We tried to fool nxt 1 1hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString37() {
		testConvertDateAndTimeString("We tried to fool 11/04/2014 04:00",
				"We tried to fool nxt nxt 2hour", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString38() {
		testConvertDateAndTimeString("For 25/12/2014 , Friday goes to camp from 11/04/2014 01:00 ~ "
				+ "14/04/2014 13:00 then come back by 01/04/2014 .",
				"For christmas, \"Friday\" goes to camp from nxt 1h ~ "
				+ "Monday one pm then come back by 1/4.", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString39() {
		testConvertDateAndTimeString("aaa 12/04/2014 23:59",
				"aaa 12/04/2014 11.59pm", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidConvertDateAndTimeString40() {
		testConvertDateAndTimeString(null,
				null, "11/04/2014 00:00");
	}
	
	@Test
	public void testInvalidConvertDateAndTimeString1() {
		testExceptionConvertDateAndTimeString("Error: Cannot have odd numbers of quotes", 
				"One ppl named \"two\" want \" to have 1.", "11/04/2014 00:00");
	}
	
	private void testConvertDateAndTimeString(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			assertEquals(expected, _datm.convertDateAndTimeString(input));
		} catch (InvalidQuotesException e) {
			fail();
		}
	}
	
	private void testExceptionConvertDateAndTimeString(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			 _datm.convertDateAndTimeString(input);
			fail();
		} catch (InvalidQuotesException e) {
			assertEquals(expected, e.getMessage());
		}
	}
	/*above is testConvertDateAndTimeString*/
	
	/*below is to test checkDateAndTimeWithStart*/
	@Test
	public void testValidCheckDateAndTimeWithStart1() {
		testCheckDateAndTimeWithStart(null, "18/10/1993 00:00", "18/08/1994 00:00", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart2() {
		testCheckDateAndTimeWithStart(null, "18/10/1993 15:00", null, "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart3() {
		testCheckDateAndTimeWithStart(null, null, null, "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart4() {
		testCheckDateAndTimeWithStart("18/10/2014 00:00", null, "18/10/2014 00:00", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart5() {
		testCheckDateAndTimeWithStart(null, null, "18/10/2011 00:00", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart6() {
		testCheckDateAndTimeWithStart("18/08/2015 00:00", "18/7/2015 00:00", "18/08/2015 00:00", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart7() {
		testCheckDateAndTimeWithStart("", "18/10/1993 15:00", " ", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart8() {
		testCheckDateAndTimeWithStart("", "", " ", "11/04/2014 00:00");
	}
	
	@Test
	public void testValidCheckDateAndTimeWithStart9() {
		testCheckDateAndTimeWithStart("18/10/2014 00:00", "", "18/10/2014 00:00", "11/04/2014 00:00");
	}
	
	
	private void testCheckDateAndTimeWithStart(String expected, String startEarliest, String dateLatest, String dateString){
		setupDebugEnvironment(dateString);
		assertEquals(expected, _datm.checkDateAndTimeWithStart(startEarliest, dateLatest));
	}
	/*above is to test checkDateAndTimeWithStart*/
	
	/*below is to test parseNumberString*/
	@Test
	public void testValidNumberString1() {
		testParseNumberString("I want to have 1 apple", "I want to have one apple");
	}
	
	@Test
	public void testValidNumberString2() {
		testParseNumberString("I want to have 1 , thanks", "I want to have one,thanks");
	}
	
	@Test
	public void testValidNumberString3() {
		testParseNumberString("1 ppl named two want to have 1 .", "One ppl named \"two\" want to have 1.");
	}
	
	@Test
	public void testValidNumberString4() {
		testParseNumberString("111 aaa 111", "one one one aaa one one one");
	}
	
	@Test
	public void testValidNumberString5() {
		testParseNumberString("11/11/2015 11/11/2015 , 11:11 12:00 ,", "11/11/15 11/11/15, 11:11 12:00,");
	}
	
	@Test
	public void testValidNumberString6() {
		testParseNumberString("111 1 111", "one one one 1 one one one");
	}
	
	@Test
	public void testInvalidNumberString1() {
		testInvalidParseNumberString("Error: Cannot have odd numbers of quotes", 
				"One ppl named \"two\" want\" to have 1.");
	}
	
	private void testParseNumberString(String expected, String input){
		try {
			assertEquals(expected, _datm.parseNumberString(input));
		} catch (InvalidQuotesException e) {
			fail();
		}
	}
	
	private void testInvalidParseNumberString(String expected, String input){
		try {
			_datm.parseNumberString(input);
			fail();
		} catch (InvalidQuotesException e) {
			assertEquals(expected, e.getMessage());
		}
	}
	/*above is to test parseNumberString*/
	
	/*below is to test DateAndTime*/
	@Test
	public void testDateAndTime1() {
		testDateAndTimeObject("11/04/2014", "08:13", "friday", "11/04/2014 08:13");
	}
	
	private void testDateAndTimeObject(String date, String time, String day, String dateString){
		//String dateString = "11/04/2014 08:13";
		setupDebugEnvironment(dateString);

		assertEquals(date, _datm.getTodayDate());
		assertEquals(time, _datm.getTodayTime());
		assertEquals(day.toUpperCase(), _datm.getTodayDay().toUpperCase());
		assertEquals(dateString, _datm.getTodayDateAndTime());
	}
	/*above is to test DateAndTime*/
	
	/*below is testCompareDateAndTimeExecutor*/
	@Test
	public void testCompareDateAndTimeExecutorValidBigger1() {
		testCompareDateAndTimeExecutor(1, "10/12/2014", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidBigger2() {
		testCompareDateAndTimeExecutor(1, "10/12/2014 11:00", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidBigger3() {
		testCompareDateAndTimeExecutor(1, "19/10/2014 00:01", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidBigger4() {
		testCompareDateAndTimeExecutor(1, "00:01 19/10/2014", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidBigger5() {
		testCompareDateAndTimeExecutor(1, "00:01 18/10/2014", "00:01 18/8/2014", "18/10/2014 00:00");
	}
	
	/**
	 * this is compared with 18/10/2014 23:59
	 */
	@Test
	public void testCompareDateAndTimeExecutorValidSmaller2() {
		testCompareDateAndTimeExecutor(-1, "00:01 18/10/2014", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidSmaller1() {
		testCompareDateAndTimeExecutor(-1, "00:01 18/8/2014",  "00:01 18/10/2014", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorValidSame1() {
		testCompareDateAndTimeExecutor(0, "00:01 18/10/2014",  "00:01 18/10/2014", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorInvalid1() {
		testCompareDateAndTimeExecutor(-2, null, null, "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorInvalid2() {
		testCompareDateAndTimeExecutor(-2, null, "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorInvalid3() {
		testCompareDateAndTimeExecutor(-2, "00:01 18/10/2014", null, "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorInvalid4() {
		testCompareDateAndTimeExecutor(-2, "00:01 18/10/2014", "AA", "18/10/2014 00:00");
	}
	
	@Test
	public void testCompareDateAndTimeExecutorInvalid5() {
		testCompareDateAndTimeExecutor(-2, "BB", "00:01 18/10/2014", "18/10/2014 00:00");
	}
	
	private void testCompareDateAndTimeExecutor(int expected, String input1, String dateString){
		setupDebugEnvironment(dateString);

		assertEquals(expected, _datm.compareDateAndTime(input1));

	}
	
	private void testCompareDateAndTimeExecutor(int expected, String input1, String input2, String dateString){
		setupDebugEnvironment(dateString);

		assertEquals(expected, _datm.compareDateAndTime(input1, input2));

	}
	/*above is testCompareDateAndTimeExecutor*/
	
	private void setupDebugEnvironment(String dateString){
		try {
			_datm.setDebug(dateString);
		} catch (ParseException e) {
			//wrong date causes failed
			fail();
		}
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDateAndTimeRetriever.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDayParser.java
	 */


package com.taskpad.tests;

import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidDayException;

public class TestDayParser {
	private static final String DAY_INVALID = "Error: Invalid Day";

	/*We test all cases at least once to ensure full path coverage*/
	@Test
	public void test1() {
		testValidDay("Monday", 1);
	}
	
	@Test
	public void test2() {
		testValidDay("Mon", 1);
	}
	
	@Test
	public void test3() {
		testValidDay("TueSday", 2);
	}
	
	@Test
	public void test4() {
		testValidDay("TUES", 2);
	}
	
	@Test
	public void test5() {
		testValidDay("WedNesday", 3);
	}
	
	@Test
	public void test6() {
		testValidDay("WED", 3);
	}
	
	@Test
	public void test7() {
		testValidDay("Thurs", 4);
	}
	
	@Test
	public void test8() {
		testValidDay("Thursday", 4);
	}
	
	@Test
	public void test9() {
		testValidDay("fri", 5);
	}
	
	@Test
	public void test10() {
		testValidDay("FriDay", 5);
	}
	
	@Test
	public void test11() {
		testValidDay("Saturday", 6);
	}
	
	@Test
	public void test12() {
		testValidDay("SAT", 6);
	}
	
	@Test
	public void test13() {
		testValidDay("Sunday", 0);
	}
	
	@Test
	public void test14() {
		testValidDay("Sun", 0);
	}
	
	/*boundary case: when it is null*/
	@Test
	public void test15() {
		testInvalidDay(null);
	}
	
	@SuppressWarnings("deprecation")
	private void testValidDay(String input, int expected){
		try {
			assertEquals(DateAndTimeManager.getInstance().parseDayToInt(input), expected);
		} catch (InvalidDayException e) {
			fail();
		}
	}
	
	@SuppressWarnings("deprecation")
	private void testInvalidDay(String input){
		try {
			DateAndTimeManager.getInstance().parseDayToInt(input);
			fail();
		} catch (InvalidDayException e) {
			assertEquals(e.getMessage(), DAY_INVALID);
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDayParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestGuiManager.java
	 */


package com.taskpad.tests;

import java.util.Timer;
import java.util.TimerTask;

import com.taskpad.ui.GuiManager;

public class TestGuiManager {
	public static void main(String[] args){
		GuiManager.initialGuiManager();
		
		GuiManager.callOutput("a");

		new Reminder(5);
		
	}
}


class Reminder {
    Timer timer;

    public Reminder(int seconds) {
        timer = new Timer();
        timer.schedule(new RemindTask(), 0, seconds*1000);
        
	}

    static class RemindTask extends TimerTask {
    	private int t = 0;
        public void run() {
        	GuiManager.callOutput("b");
        	t++;
        	if(t == 3){
            	GuiManager.callExit();
            }
        }
    }
}

/**
 * test if the input shown in displayBox. (true)
 * test if everything is closed. (true)
 */

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestGuiManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestHolidayDatesParser.java
	 */


package com.taskpad.tests;

import static org.junit.Assert.*;

import java.text.ParseException;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;

/**
 * 
 * 
 * TestHolidayDatesParser is to test whether HolidayDatesParser works fine!
 */
public class TestHolidayDatesParser {
	private DateAndTimeManager _datm = DateAndTimeManager.getInstance();
	
	/* We test all cases at least once to ensure full path coverage */
	@Test
	public void testValid1() {
		testValidHoliday("CHRISTMas", "25/12/2014", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid2() {
		testValidHoliday("NATIONAL DAY", "09/08/2014", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid3() {
		testValidHoliday("April FOOLS", "01/04/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid4() {
		testValidHoliday("April FOOL", "01/04/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid5() {
		testValidHoliday("APRIL FOOLS DAY", "01/04/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid6() {
		testValidHoliday("APRIL FOOL DAY", "01/04/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid7() {
		testValidHoliday("INDEPDENCE DAY", "04/07/2014", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid8() {
		testValidHoliday("LABOUR DAY", "01/05/2014", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid9() {
		testValidHoliday("LABOR DAY", "01/05/2014", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid10() {
		testValidHoliday("NEW YEAR", "01/01/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testValid11() {
		testValidHoliday("NEW YEAR Day", "01/01/2015", "09/04/2014 00:00");
	}
	
	@Test
	public void testInValid1() {
		testValidHoliday("JustForFun", null, "09/04/2014 00:00");
	}
	
	@Test
	public void testInValid2() {
		testValidHoliday(" ", null, "09/04/2014 00:00");
	}
	
	@Test
	public void testInValid3() {
		testValidHoliday("", null, "09/04/2014 00:00");
	}
	
	@Test
	public void testInValid4() {
		testValidHoliday(null, null, "09/04/2014 00:00");
	}

	/**
	 * 
	 */
	private void setupDebug(String date) {
		try {
			_datm.setDebug(date);
		} catch (ParseException e1) {
			fail();
		}
	}

	private void testValidHoliday(String input, String expected, String date) {
		setupDebug(date);
		assertEquals(DateAndTimeManager.getInstance().parseHolidayString(input), expected);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestHolidayDatesParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestNumberParser.java
	 */


package com.taskpad.tests;



import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;

public class TestNumberParser {

	//private NumberParser _parseNumWord = new NumberParser();
	private String _description = "";
	
	/*100% coverage in NumberParser*/

	@SuppressWarnings("deprecation")
	@Test
	public void test1() {
		_description = "base case";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("one"), "1");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test2() {
		_description = "case insensitive";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("ONe"), "1");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test3() {
		_description = "case insensitive and can accept words like twenty";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("Twenty one"), "21");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test4() {
		_description = "can accept some broken English";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("One ONe"), "11");
	}

	@SuppressWarnings("deprecation")
	@Test
	public void test5() {
		_description = "can accept some broken English";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("One ONe ONE"), "111");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test6() {
		_description = "can accept many spaces";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("One    ONE"), "11");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test7() {
		_description = "can handle error: spaces only";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("  "), null);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test8() {
		_description = "can handle error: empty string";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber(""), null);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test9() {
		_description = "can handle error: no such number";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("gfg"), null);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test10() {
		_description = "only support English, can't support \"one\" in chinese";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber(""), null);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test11() {
		_description = "only support English, can't support \"one\" in malay";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("satu"), null);
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test12() {
		_description = "can accept integers";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("111"), "111");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test13() {
		_description = "can accept integers";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("000"), "0");
	}
	
	@SuppressWarnings("deprecation")
	@Test
	public void test14() {
		_description = "can accept integers";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("000", false), "000");
	}

	@SuppressWarnings("deprecation")
	@Test
	public void test15() {
		_description = "can't accept combination";
		assertEquals(_description, DateAndTimeManager.getInstance().parseNumber("one 1"), null);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestNumberParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSpecialWordParser.java
	 */


package com.taskpad.tests;

/**
 * For testing special word and time word parser
 */

import static org.junit.Assert.*;

import java.text.ParseException;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidDayException;
import com.taskpad.dateandtime.NullTimeUnitException;
import com.taskpad.dateandtime.NullTimeValueException;

public class TestSpecialWordParser {

	private static final String MESSAGE_INVALID_TIME = "Error: Please enter a time unit";	
	private static final String MESSAGE_INVALID_DAY = "Error: Invalid Day";

	private DateAndTimeManager _specialWordParser = DateAndTimeManager.getInstance();
	
	/*below is dayParser part */
	/*100% path coverage*/
	@Test
	public void validTestDay1() {
		testWordCommand("24/03/2014", "MOND", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay2() {
		testWordCommand("07/04/2014", "NXT NXT MONDay", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay3() {
		testWordCommand("07/04/2014", "NXT NXT NXT PREV MONda", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay4() {
		testWordCommand("30/03/2014", "NXT WK", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay5() {
		testWordCommand("23/03/2014", "THIS WK", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay6() {
		testWordCommand("24/03/2014", "THIS MON", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay7() {
		testWordCommand("24/03/2014", "TMR", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay8() {
		testWordCommand("26/03/2014", "TMR TMR TMR", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay9() {
		testWordCommand("25/03/2014", "tmr tmr TOMORRO TOM TOMORROW YTD YEST YESTERDAY", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay10(){
		testWordCommand("08/04/2014", "next Next Prev Next Tues", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay11(){
		testWordCommand("22/03/2014", "yesterday", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay12(){
		testWordCommand("23/03/2014 00:01", "Now", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay13(){
		testWordCommand("23/03/2014", "toDAY", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestDay14(){
		testWordCommand("01/04/2014", "prev Tues", "09/04/2014 00:01");
	}
	
	@Test
	public void invalidTestDay1() {
		testInvalidWordCommand(MESSAGE_INVALID_DAY, "MAN", "23/3/2014 00:01");
	}
	
	@Test
	public void invalidTestDay2() {
		testInvalidWordCommand(MESSAGE_INVALID_DAY, "WEEK", "23/03/2014 00:01");
	}
	
	@Test
	public void invalidTestDay3() {
		testInvalidWordCommand(MESSAGE_INVALID_DAY, null, "23/3/2014 00:01");
	}
	
	@Test
	public void invalidTestDay4() {
		testInvalidWordCommand(MESSAGE_INVALID_DAY, " ", "23/3/2014 00:01");
	}
	
	@Test
	public void invalidTestDay5() {
		testInvalidWordCommand(MESSAGE_INVALID_DAY, "", "23/3/2014 00:01");
	}
	/*above is dayParser part */

	
	/*below is Time Word Parser*/
	/*?% path coverage*/
	//For hours
	@Test
	public void validTestTimeWord1(){
		testTimeWordCommand("23/03/2014 01:01", "1h", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord2(){
		testTimeWordCommand("23/03/2014 01:01", "next hour", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord3(){
		testTimeWordCommand("23/03/2014 00:01", "next previous hour", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord4(){
		testTimeWordCommand("23/03/2014 01:01", "next 1 hour", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord5(){
		testTimeWordCommand("23/03/2014 02:01", "next next 1 hour", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord6(){
		testTimeWordCommand("23/03/2014 04:01", "next next 2 hours", "23/03/2014 00:01");
	}
	
	//For minutes
	@Test
	public void validTestTimeWord7(){
		testTimeWordCommand("23/03/2014 00:01", "next previous min", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord8(){
		testTimeWordCommand("23/03/2014 01:01", "next next 30 min", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord9(){
		testTimeWordCommand("22/03/2014 23:01", "prev h", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord10(){
		testTimeWordCommand("22/03/2014 23:01", "-1 h", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord11(){
		testTimeWordCommand("23/03/2014 00:01", "0 h", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord12(){
		testTimeWordCommand("22/03/2014 23:01", "-1h", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord13(){
		testTimeWordCommand("23/03/2014 01:01", "0  d 1 h 1m -60s", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord14(){
		testTimeWordCommand("23/03/2014 02:01", " next nxt prev next 0  d 1 h 1m -60s", "23/03/2014 00:01");
	}
	
	@Test
	public void validTestTimeWord15(){
		testTimeWordCommand("23/03/2014 01:01", "1hour", "23/03/2014 00:01");
	}
	
	@Test
	public void invalidTestTimeWord1(){
		testInvalidTimeWordCommand(MESSAGE_INVALID_TIME, null, "23/03/2014 00:01");
	}
	
	@Test
	public void invalidTestTimeWord2(){
		testInvalidTimeWordCommand(MESSAGE_INVALID_TIME, "", "23/03/2014 00:01");
	}
	
	@Test
	public void invalidTestTimeWord3(){
		testInvalidTimeWordCommand(MESSAGE_INVALID_TIME, "   ", "23/03/2014 00:01");
	}
	
	@Test
	public void invalidTestTimeWord15(){
		testInvalidTimeWordCommand(MESSAGE_INVALID_TIME, " 1s1m1h", "23/03/2014 00:01");
	}

	/*above is Time Word Parser*/
	
	
	
	private void testWordCommand (String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		
		try {
			assertEquals(expected, _specialWordParser.parseDayToDate(input));
		} catch (InvalidDayException e) {
			fail();
		}
	}
	
	private void testInvalidWordCommand(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		
		try {
			_specialWordParser.parseDayToDate(input);
			fail();
		} catch (InvalidDayException e) {
			assertEquals(e.getMessage(), expected);
		}
	}
	
	private void testTimeWordCommand(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			assertEquals(expected,_specialWordParser.parseTimeWord(input));
		} catch (NullTimeUnitException | NullTimeValueException e) {
			fail();
		}
	}
	
	private void testInvalidTimeWordCommand(String expected, String input, String dateString){
		setupDebugEnvironment(dateString);
		try {
			_specialWordParser.parseTimeWord(input);
			fail();
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertEquals(e.getMessage(), expected);
		}
	}
	
	private void setupDebugEnvironment(String dateString){
		try {
			_specialWordParser.setDebug(dateString);
		} catch (ParseException e) {
			//wrong date causes failed
			fail();
		}
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSpecialWordParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestTimeWordParser.java
	 */


package com.taskpad.tests;

import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.NullTimeUnitException;
import com.taskpad.dateandtime.NullTimeValueException;

/**
 * 
 *
 * @category
 * TestTimeWordParser: a Junit test case written to test TimeWordParser
 */
public class TestTimeWordParser {

	DateAndTimeManager parser = DateAndTimeManager.getInstance();
	
	@Test
	public void test1() {
		try {
			assertEquals(parser.convertToSecond("1s"), "1");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			fail();
		}
	}
	
	@Test
	public void test2() {
		try {
			parser.convertToSecond("");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time value"));
		}
	}
	
	@Test
	public void test3() {
		try {
			parser.convertToSecond("s");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time value"));
		}
	}
	
	@Test
	public void test4() {
		try {
			assertEquals(parser.convertToSecond("1 s"), "1");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			fail();
		}
	}

	@Test
	public void test5() {
		try {
			parser.convertToSecond(null);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test6() {
		try {
			parser.convertToSecond("a");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test7() {
		try {
			parser.convertToSecond("1");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test8() {
		try {
			parser.convertToSecond("1                m");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}

	@Test
	public void test9() {
		try {
			assertEquals(parser.convertToSecond("1 s 1 m"), "61");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			fail();
		}
	}
	
	@Test
	public void test10() {
		try {
			parser.convertToSecond("1                m 2");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test11() {
		try {
			parser.convertToSecond("1  month");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test12() {
		try {
			parser.convertToSecond("one one ones");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time unit"));
		}
	}
	
	@Test
	public void test13() {
		try {
			assertEquals(parser.convertToSecond("one one one s"), "111");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			fail();
		}
	}
	
	@Test
	public void test14() {
		try {
			parser.convertToSecond("1 1 1 s");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			assertTrue(e.getMessage().equals("Error: Please enter a time value"));
		}
	}
	
	@Test
	public void test15() {
		try {
			assertEquals(parser.convertToSecond("one one s 1 m"), "71");
		} catch (NullTimeUnitException | NullTimeValueException e) {
			fail();
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestTimeWordParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\BarScroller.java
	 */


package com.taskpad.ui;



import javax.swing.JScrollBar;

public class BarScroller implements Runnable {
		
		private boolean _forward;
		private JScrollBar _anyScrollBar;
	
		protected BarScroller(){
		}
		
		protected BarScroller(boolean forward, JScrollBar anyScrollBar){
			initializeBarScroller(forward, anyScrollBar);
		}

		private void initializeBarScroller(boolean forward, JScrollBar anyScrollBar) {
			_forward = forward;
			_anyScrollBar = anyScrollBar;
		}
	
		public void run(){
			if (_anyScrollBar.isEnabled()){
				int current = scroll();
				_anyScrollBar.setValue(current);
			}
		}

		private int scroll() {
			int increment = _anyScrollBar.getBlockIncrement();
			int current = _anyScrollBar.getValue();
			if (_forward){//down, right
				current -= increment;
			} else if (!_forward){//up, left
				current += increment;
			}
			return current;
		}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\BarScroller.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\ComponentMover.java
	 */


package com.taskpad.ui;



import java.awt.Component;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ComponentMover extends MouseAdapter{
	private Point _mouseDownPoint = null;
	private Point _currPoint = null;
	private Point _movePoint = null;
	private JFrame _movingFrame = null;
	
	/**
	 * To make sure it cannot be used by other package
	 */
	protected ComponentMover(JFrame ListenFrame){
		setMovingFrame(ListenFrame);
	}

	/**
	 *  Remove listeners from the specified component
	 *
	 *  @param component  the component the listeners are removed from
	 */
	protected void deregisterComponent(Component... components){
		for (Component component : components){
			component.removeMouseListener(this);
			component.removeMouseMotionListener(this);
		}
	}

	/**
	 *  Add the required listeners to the specified component
	 *
	 *  @param component  the component the listeners are added to
	 */
	protected void registerComponent(Component... components){
		for (Component component : components){
			component.addMouseListener(this);
			component.addMouseMotionListener(this);
		}
	}
	
	@Override
	public void mousePressed(final MouseEvent e) {
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				setMouseDownPoint(e.getPoint());
			}
			
		});
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				setMouseDownPoint(null);
			}
			
		});
	}
	
	@Override
	public void mouseDragged(final MouseEvent e) {
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				initializedPoints(e);
				move();
			}
			
		});
		
	}
	
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	private void initializedPoints(MouseEvent e) {
		setCurrPoint(e.getLocationOnScreen());
		setMovePoint(new Point(_currPoint.x - _mouseDownPoint.x, _currPoint.y - _mouseDownPoint.y));
	}

	private void move() {
		_movingFrame.setLocation(_movePoint);
	}

	private void setMouseDownPoint(Point mouseDownPoint) {
		_mouseDownPoint = mouseDownPoint;
	}

	private void setCurrPoint(Point _currPoint) {
		this._currPoint = _currPoint;
	}
	
	private void setMovePoint(Point _movePoint) {
		this._movePoint = _movePoint;
	}

	private void setMovingFrame(JFrame _movingFrame) {
		this._movingFrame = _movingFrame;
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\ComponentMover.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\ComponentResizer.java
	 */


package com.taskpad.ui;



import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.SwingUtilities;

/**
 *  reference: http://tips4java.wordpress.com/2009/09/13/resizing-components/
 *  
 *  The ComponentResizer allows you to resize a component by dragging a border
 *  of the component.
 *  
 *  MouseAdapter is better because it is more OO-oriented.
 */
public class ComponentResizer extends MouseAdapter{
	private final static Dimension MINIMUM_SIZE = new Dimension(10, 10);
	private final static Dimension MAXIMUM_SIZE =
		new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);

	private static Map<Integer, Integer> _cursors = new HashMap<Integer, Integer>(); {
		_cursors.put(1, Cursor.N_RESIZE_CURSOR);
		_cursors.put(2, Cursor.W_RESIZE_CURSOR);
		_cursors.put(4, Cursor.S_RESIZE_CURSOR);
		_cursors.put(8, Cursor.E_RESIZE_CURSOR);
		_cursors.put(3, Cursor.NW_RESIZE_CURSOR);
		_cursors.put(9, Cursor.NE_RESIZE_CURSOR);
		_cursors.put(6, Cursor.SW_RESIZE_CURSOR);
		_cursors.put(12, Cursor.SE_RESIZE_CURSOR);
	}

	private Insets _dragInsets;
	private Dimension _snapSize;

	private int _direction;
	protected static final int NORTH = 1;
	protected static final int WEST = 2;
	protected static final int SOUTH = 4;
	protected static final int EAST = 8;

	private Cursor sourceCursor;
	private boolean _isResizing;
	private Rectangle _bounds;
	private Point _pressed;
	private boolean _autoscrolls;

	private Dimension minimumSize = MINIMUM_SIZE;
	private Dimension maximumSize = MAXIMUM_SIZE;

	/**
	 *  Convenience contructor. All borders are resizable in increments of
	 *  a single pixel. Components must be registered separately.
	 */
	protected ComponentResizer() {
		this(new Insets(5, 5, 5, 5), new Dimension(1, 1));
	}

	/**
	 *  Convenience contructor. All borders are resizable in increments of
	 *  a single pixel. Components can be registered when the class is created
	 *  or they can be registered separately afterwards.
	 *
	 *  @param components components to be automatically registered
	 */
	protected ComponentResizer(Component... components){
		this(new Insets(5, 5, 5, 5), new Dimension(1, 1), components);
	}

	/**
	 *  Create a ComponentResizer.
	 *
	 *  @param _dragInsets Insets specifying which borders are eligible to be
	 *                    resized.
	 *  @param _snapSize Specify the dimension to which the border will snap to
	 *                  when being dragged. Snapping occurs at the halfway mark.
	 *  @param components components to be automatically registered
	 */
	private ComponentResizer(Insets _dragInsets, Dimension _snapSize, Component... components){
		setDragInsets( _dragInsets );
		setSnapSize( _snapSize );
		registerComponent( components );
	}

	/**
	 *  Set the drag _dragInsets. The insets specify an area where mouseDragged
	 *  events are recognized from the edge of the border inwards. A value of
	 *  0 for any size will imply that the border is not resizable. Otherwise
	 *  the appropriate drag cursor will appear when the mouse is inside the
	 *  resizable border area.
	 *
	 *  @param  _dragInsets Insets to control which borders are resizeable.
	 */
	protected void setDragInsets(Insets _dragInsets){
		validateMinimumAndInsets(minimumSize, _dragInsets);

		this._dragInsets = _dragInsets;
	}
	
	/**
	 * Set the _dragInsets by using the insetSize
	 * create an inset that has same top, left, right, bottom
	 * @param insetSize: number that determines the inset that controls which borders are resizeable.
	 */
	protected void setDragInsets(int insetSize){
		Insets _dragInsets = new Insets(insetSize, insetSize, insetSize, insetSize);
		validateMinimumAndInsets(minimumSize, _dragInsets);

		this._dragInsets = _dragInsets;
	}

	/**
	 *  Remove listeners from the specified component
	 *
	 *  @param component  the component the listeners are removed from
	 */
	protected void deregisterComponent(Component... components){
		for (Component component : components){
			component.removeMouseListener(this);
			component.removeMouseMotionListener(this);
		}
	}

	/**
	 *  Add the required listeners to the specified component
	 *
	 *  @param component  the component the listeners are added to
	 */
	protected void registerComponent(Component... components){
		for (Component component : components){
			component.addMouseListener(this);
			component.addMouseMotionListener(this);
		}
	}

	/**
	 *  Control how many pixels a border must be dragged before the size of
	 *  the component is changed. The border will snap to the size once
	 *  dragging has passed the halfway mark.
	 *
	 *  @param _snapSize Dimension object allows you to separately spcify a
	 *                  horizontal and vertical snap size.
	 */
	private void setSnapSize(Dimension _snapSize){
		this._snapSize = _snapSize;
	}

	/**
	 *  When the components minimum size is less than the drag insets then
	 *	we can't determine which border should be resized so we need to
	 *  prevent this from happening.
	 */
	private void validateMinimumAndInsets(Dimension minimum, Insets drag){
		int minimumWidth = drag.left + drag.right;
		int minimumHeight = drag.top + drag.bottom;

		if (minimum.width  < minimumWidth
		||  minimum.height < minimumHeight){
			String message = "Minimum size cannot be less than drag insets";
			throw new IllegalArgumentException( message );
		}
	}

	/**
	 */
	@Override
	public void mouseMoved(final MouseEvent e){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				Component source = e.getComponent();
				Point location = e.getPoint();
				_direction = 0;

				if (location.x < _dragInsets.left){
					_direction += WEST;
				}

				if (location.x > source.getWidth() - _dragInsets.right - 1){
					_direction += EAST;
				}

				if (location.y < _dragInsets.top){
					_direction += NORTH;
				}

				if (location.y > source.getHeight() - _dragInsets.bottom - 1){
					_direction += SOUTH;
				}

				//  Mouse is no longer over a resizable border

				if (_direction == 0){
					source.setCursor( sourceCursor );
				}
				else { // use the appropriate resizable cursor
					int cursorType = _cursors.get( _direction );
					Cursor cursor = Cursor.getPredefinedCursor( cursorType );
					source.setCursor( cursor );
				}
			}
			
		});
		
	}

	@Override
	public void mouseEntered(final MouseEvent e){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				if (!_isResizing){
					Component source = e.getComponent();
					sourceCursor = source.getCursor();
				}
			}
			
		});
		
	}

	@Override
	public void mouseExited(final MouseEvent e){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				if (!_isResizing){
					Component source = e.getComponent();
					source.setCursor( sourceCursor );
				}
			}
			
		});
		
	}

	@Override
	public void mousePressed(final MouseEvent e){
		
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
//				The mouseMoved event continually updates this variable

				if (_direction == 0){
					return;
				}

				Component source;
				
				//  Setup for _isResizing. All future dragging calculations are done based
				//  on the original _bounds of the component and mouse pressed location.
				source = setupForResizing(e);

				//  Making sure autoscrolls is false will allow for smoother resizing
				//  of components
				disableAutoScrolls(source);
			}
			
		});
		
	}

	private Component setupForResizing(MouseEvent e){
		Component source;
		_isResizing = true;

		source = e.getComponent();
		_pressed = e.getPoint();
		SwingUtilities.convertPointToScreen(_pressed, source);
		_bounds = source.getBounds();
		return source;
	}

	private void disableAutoScrolls(Component source) {
		if (source instanceof JComponent){
			JComponent jc = (JComponent)source;
			_autoscrolls = jc.getAutoscrolls();
			jc.setAutoscrolls( false );
		}
	}

	/**
	 *  Restore the original state of the Component
	 */
	@Override
	public void mouseReleased(final MouseEvent e){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				_isResizing = false;

				Component source = e.getComponent();
				source.setCursor( sourceCursor );

				restoreAutoScroll(source);
			}
			
		});
		
	}

	private void restoreAutoScroll(Component source) {
		if (source instanceof JComponent){
			((JComponent)source).setAutoscrolls(_autoscrolls);
		}
	}

	/**
	 *  Resize the component ensuring location and size is within the _bounds
	 *  of the parent container and that the size is within the minimum and
	 *  maximum constraints.
	 *
	 *  All calculations are done using the _bounds of the component when the
	 *  _isResizing started.
	 */
	@Override
	public void mouseDragged(final MouseEvent e){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				if (!_isResizing){
					return;
				}

				Component source = e.getComponent();
				Point dragged = e.getPoint();
				SwingUtilities.convertPointToScreen(dragged, source);

				changeBounds(source, _direction, _bounds, _pressed, dragged);
			}
			
		});
		
	}

	protected void changeBounds(Component source, int _direction, Rectangle _bounds, Point _pressed, Point current){
		//  Start with original locaton and size

		int x = _bounds.x;
		int y = _bounds.y;
		int width = _bounds.width;
		int height = _bounds.height;

		//  Resizing the West or North border affects the size and location

		if (WEST == (_direction & WEST)){
			int drag = getDragDistance(_pressed.x, current.x, _snapSize.width);
			int maximum = Math.min(width + x, maximumSize.width);
			drag = getDragBounded(drag, _snapSize.width, width, minimumSize.width, maximum);

			x -= drag;
			width += drag;
		}

		if (NORTH == (_direction & NORTH)){
			int drag = getDragDistance(_pressed.y, current.y, _snapSize.height);
			int maximum = Math.min(height + y, maximumSize.height);
			drag = getDragBounded(drag, _snapSize.height, height, minimumSize.height, maximum);

			y -= drag;
			height += drag;
		}

		//  Resizing the East or South border only affects the size

		if (EAST == (_direction & EAST)){
			int drag = getDragDistance(current.x, _pressed.x, _snapSize.width);
			Dimension boundingSize = getBoundingSize( source );
			int maximum = Math.min(boundingSize.width - x, maximumSize.width);
			drag = getDragBounded(drag, _snapSize.width, width, minimumSize.width, maximum);
			width += drag;
		}

		if (SOUTH == (_direction & SOUTH)){
			int drag = getDragDistance(current.y, _pressed.y, _snapSize.height);
			Dimension boundingSize = getBoundingSize( source );
			int maximum = Math.min(boundingSize.height - y, maximumSize.height);
			drag = getDragBounded(drag, _snapSize.height, height, minimumSize.height, maximum);
			height += drag;
		}

		source.setBounds(x, y, width, height);
		source.validate();
	}

	/*
	 *  Determine how far the mouse has moved from where dragging started
	 */
	private int getDragDistance(int larger, int smaller, int _snapSize){
		int halfway = _snapSize / 2;
		int drag = larger - smaller;
		drag += (drag < 0) ? -halfway : halfway;
		drag = (drag / _snapSize) * _snapSize;

		return drag;
	}

	/*
	 *  Adjust the drag value to be within the minimum and maximum range.
	 */
	private int getDragBounded(int drag, int _snapSize, int dimension, int minimum, int maximum){
		while (dimension + drag < minimum){
			drag += _snapSize;
		}
		while (dimension + drag > maximum){
			drag -= _snapSize;
		}

		return drag;
	}

	/*
	 *  Keep the size of the component within the bounds of its parent.
	 */
	private Dimension getBoundingSize(Component source){
		if (source instanceof Window){
			GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
			Rectangle bounds = env.getMaximumWindowBounds();
			return new Dimension(bounds.width, bounds.height);
		}
		else {
			return source.getParent().getSize();
		}
	}
}
	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\ComponentResizer.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\FlexiFontOutputFrame.java
	 */


/**
 * This class is going to take over
 * the original output frame because it is more flexible 
 * in font color and type.
 */

package com.taskpad.ui;

import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;


public class FlexiFontOutputFrame extends OutputFrame {

	private static final long serialVersionUID = 1L;

	private final int DEFAULT_ALIGNMENT = StyleConstants.ALIGN_JUSTIFIED;
	private final String DEFAULT_FONT_TYPE = "Lucida Console";
	private final int DEFAULT_FONT_SIZE = 12;
	private final Color DEFAULT_COLOR_NORMAL = Color.BLACK;
	private final Color DEFAULT_COLOR_REMINDER = Color.RED;

	private final int MARGIN_TOP = 5;
	private final int MARGIN_LEFT = 5;
	private final int MARGIN_BOTTOM = 5;
	private final int MARGIN_RIGHT = 5;
	
	private final String ERROR_BAD_LOCATION_EXCEPTION = "BadLocationException occurs";
	
	private JTextPane _outputBox = new JTextPane();	
	private ComponentMover _moveOutputBox = new ComponentMover(this);
	
	protected FlexiFontOutputFrame()
	{
		super(true);
		initializeFlexiOutputFrame();
	}

	private void initializeFlexiOutputFrame() {
		setUpFrame();       
		initializeOutputBox();
		setUpScrollBar();
		getContentPane().add(_scrollBox);
		_isHiding = false;
	}

	@Override
	protected void initializeOutputBox() {
		// Don't let the user change the output.
		_outputBox.setEditable(false);

		_outputBox.setBackground(OUTPUTBOX_BACKGROUND_COLOR);

		// Fix the maximum length of the line
		setUpBorderAndMargin();
		
		//manually create an EditorKit that supports wrap
		//to make JTextPane supports wrap.
		//and set it to be JTextPane's editorKit
		_outputBox.setEditorKit(new WrapEditorKit());		
		
		//to make it movable
		_moveOutputBox.registerComponent(_outputBox);
		
		//_outputBox.addMouseListener(_pressDetect);       DEPRECATED
		//_outputBox.addMouseMotionListener(_moveMouse);   DEPRECATED
		
		/* Testing
		appendToPane(_outputBox, "My Name is Too Good.\n", Color.RED);
		appendToPane(_outputBox, "I wish I could be ONE of THE BEST on ", Color.BLUE);
		appendToPane(_outputBox, "Stack", Color.DARK_GRAY);
		appendToPane(_outputBox, "Over", Color.MAGENTA);
		appendToPane(_outputBox, "flow", Color.ORANGE);
		*/
	}

	private void setUpBorderAndMargin() {
		Border border = BorderFactory.createLineBorder(OUTPUTBOX_BORDER_COLOR);
		Border margin =  BorderFactory.createEmptyBorder(MARGIN_TOP, MARGIN_LEFT, MARGIN_BOTTOM, MARGIN_RIGHT);
		CompoundBorder marginBorder = BorderFactory.createCompoundBorder(border, margin);
		_outputBox.setBorder(marginBorder);
	}

	@Override
	protected void setUpScrollBar() {
		//JScrollPane provides scroll bar, so I add outputbox inside it.
		_scrollBox = new JScrollPane(_outputBox);
		disableHorizontalScrollBar();
		
		resetScrollBarPosition();
	}

	/**
	 * 
	 */
	private void resetScrollBarPosition() {
		SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
            	JScrollBar vertical = _scrollBox.getVerticalScrollBar();
        		_scrollBox.getVerticalScrollBar().setValue( vertical.getMaximum() );
            }
        });
		
	}
	
	@Override
	protected void clearOutputBox() {
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				_outputBox.setText("");
			}
			
		});
	}

	@Override
	protected void addLine(String line) {
		append(line, DEFAULT_COLOR_NORMAL);
		resetScrollBarPosition();
	}
	
	@Override
	protected void addReminder(String line) {
		boolean isBold = true;
		append(line, DEFAULT_COLOR_REMINDER, isBold);
		resetScrollBarPosition();
	}
	
	@Override
	protected void addSelfDefinedLine(String line, Color c, boolean isBold) {
		append(line, c, isBold);
	}
	
	/**
	 * Method to replace appendToPane()
	 * this method is easier to write
	 * and can handle setEditable(false)
	 * without changing its status anymore!
	 */
	private void append(String msg, Color c){
		boolean isBold = false;
		append(msg, c, isBold);
	}
	
	private void append(final String msg, final Color c, final boolean isBold){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				StyleContext sc = StyleContext.getDefaultStyleContext();
				AttributeSet aset = setUpAttributeSet(c, sc, isBold);
				StyledDocument doc = _outputBox.getStyledDocument();
				int len = doc.getLength();
				printMessage(msg, aset, doc, len);
			}
			
		});
		resetScrollBarPosition();
		
	}

	private void printMessage(String msg, AttributeSet aset,
			StyledDocument doc, int len) {
		try {
			doc.insertString(len, msg, aset);
		} catch (BadLocationException e) {
			e.printStackTrace();
			System.err.println(ERROR_BAD_LOCATION_EXCEPTION);
		}
	}
	
	
	
	/**
	 * appendToPane() finally works
	 * but it is obviously not the best way
	 * so I implement another method
	 */
	/*
	private void appendToPane(String msg, Color c){  //DEPRECATED
		//let us to modify the output
		_outputBox.setEditable(true);
		
		appendToPane(_outputBox, msg, c);
	
		//prevent user from modifying the output
		_outputBox.setEditable(false);
	}
	
	private void appendToPane(JTextPane tp, String msg, Color c){ //DEPRECATED
		StyleContext sc = StyleContext.getDefaultStyleContext();
		
		AttributeSet aset = setUpAttributeSet(c, sc);

		showMessage(tp, msg, aset);
	}

	private void showMessage(JTextPane tp, String msg, AttributeSet aset) { //DEPRECATED
		int len = tp.getDocument().getLength();
		tp.setCaretPosition(len);
		tp.setCharacterAttributes(aset, false);
		tp.replaceSelection(msg);
	}*/

	private AttributeSet setUpAttributeSet(Color c, StyleContext sc, boolean isBold) {
		AttributeSet aset = SimpleAttributeSet.EMPTY;
		aset = setFontColor(c, sc, aset);
		aset = setFontType(sc, aset);
		aset = setAlignment(sc, aset);
		aset = setFontSize(sc, aset);
		aset = setBold(sc, isBold, aset);
		return aset;
	}

	private AttributeSet setBold(StyleContext sc, boolean isBold,
			AttributeSet aset) {
		return sc.addAttribute(aset, StyleConstants.Bold, isBold);
	}

	private AttributeSet setFontSize(StyleContext sc, AttributeSet aset) {
		return sc.addAttribute(aset, StyleConstants.FontSize, DEFAULT_FONT_SIZE);
	}

	private AttributeSet setAlignment(StyleContext sc, AttributeSet aset) {
		return sc.addAttribute(aset, StyleConstants.Alignment, DEFAULT_ALIGNMENT);
	}

	private AttributeSet setFontType(StyleContext sc, AttributeSet aset) {
		return sc.addAttribute(aset, StyleConstants.FontFamily, DEFAULT_FONT_TYPE);
	}

	private AttributeSet setFontColor(Color c, StyleContext sc, AttributeSet aset) {
		return sc.addAttribute(aset, StyleConstants.Foreground, c);
	}

	@Override
	protected void endProgram() {
		super.endProgram();
		
		//clear every listener before closing
		_moveOutputBox.deregisterComponent(_outputBox);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\FlexiFontOutputFrame.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiCellRenderer.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;



/**
 * The standard class for rendering (displaying) individual cells in a JTable.
 * This class inherits from JTextArea, a standard component class. However
 * JTextArea is a multi-line area that displays plain text.
 * 
 * This class implements TableCellRenderer , i.e. interface. This interface
 * defines the method required by any object that would like to be a renderer
 * for cells in a JTable.
 * 
 * extracted from:
 * http://manivelcode.blogspot.sg/2008/08/how-to-wrap-text-inside
 * -cells-of-jtable.html
 * 
 * @see JTable
 * @see JTextArea
 */

public class GuiCellRenderer extends JTextArea implements TableCellRenderer {

	/**
	 * generated
	 */
	private static final long serialVersionUID = -1333277163624784049L;
	
	private static final int STAT = 6;
	private static final int INFO = 5;
	private static final int END = 4;
	private static final int START = 3;
	private static final int DEADLINE = 2;
	private static final int DESC = 1;
	private static final int ID = 0;
	
	private static final int FONT_SIZE = 11;
	private static final int FONT_STYLE = Font.PLAIN;
	private static final String FONT_TYPE = "Georgia";
	private static final Font FONT_DEFAULT = new Font(FONT_TYPE, FONT_STYLE, GuiCellRenderer.FONT_SIZE);

	private final DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();

	// Column heights are placed in this Map
	private final Map<JTable, Map<Object, Map<Object, Integer>>> tablecellSizes = new HashMap<JTable, Map<Object, Map<Object, Integer>>>();

	/**
	 * Creates a text area renderer.
	 */
	public GuiCellRenderer() {
		setLineWrap(true);
		setWrapStyleWord(true);

		/* Finding out the types of fonts Java supports
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();

		  String fontNames[] = ge.getAvailableFontFamilyNames();

		  // Iterate the font family names

		  for (int i=0; i<fontNames.length; i++) {

		     System.out.println(fontNames[i]);

		  }
		  */
	}

	/**
	 * Returns the component used for drawing the cell. This method is used to
	 * configure the renderer appropriately before drawing.
	 * 
	 * @param table
	 *            - JTable object
	 * @param value
	 *            - the value of the cell to be rendered.
	 * @param isSelected
	 *            - isSelected true if the cell is to be rendered with the
	 *            selection highlighted; otherwise false.
	 * @param hasFocus
	 *            - if true, render cell appropriately.
	 * @param row
	 *            - The row index of the cell being drawn.
	 * @param column
	 *            - The column index of the cell being drawn.
	 * @return - Returns the component used for drawing the cell.
	 */
	public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column) {
		// set the Font, Color, etc.
		renderer.getTableCellRendererComponent(table, value, isSelected,
				hasFocus, row, column);
		// setForeground(renderer.getForeground());
		setBackground(renderer.getBackground());
		setBorder(renderer.getBorder());
		//setFont(renderer.getFont());
		setText(renderer.getText());
		setFont(FONT_DEFAULT);
		
		setFontColor(column);

		TableColumnModel columnModel = table.getColumnModel();

		setSize(columnModel.getColumn(column).getWidth(), 0);

		int heightWanted = (int) getPreferredSize().getHeight();

		addSize(table, row, column, heightWanted);

		heightWanted = findTotalMaximumRowSize(table, row);

		if (heightWanted != table.getRowHeight(row)) {
			table.setRowHeight(row, heightWanted);
		}
		return this;
	}

	/**
	 * @param row
	 * @param column
	 */
	private void setFontColor(int column) {
		switch (column) {
		case ID:
			//setForeground(Color.cyan);
			setForeground(new Color(41, 36, 33));
			break;

		case DESC:
			//setForeground(Color.blue);
			setForeground(new Color(49, 46, 158));
			break;

		case DEADLINE:
			setForeground(Color.red);
			break;

		case START:
			//setForeground(Color.burntsienna);
			setForeground(new Color(205, 51, 51));
			break;

		case END:
			//setForeground(Color.teal);
			setForeground(new Color(56, 142, 142));
			break;

		case INFO:
			//setForeground(Color.purple);
			setForeground(new Color(78, 51, 134));
			break;

		case STAT:
			//setForeground(Color.maroon 4);
			setForeground(new Color(139, 28, 98));
			break;

		default:
			assert (false);
			break;
		}
	}

	/**
	 * @param table
	 *            - JTable object
	 * @param row
	 *            - The row index of the cell being drawn.
	 * @param column
	 *            - The column index of the cell being drawn.
	 * @param height
	 *            - Row cell height as int value This method will add size to
	 *            cell based on row and column number
	 */
	private void addSize(JTable table, int row, int column, int height) {
		Map<Object, Map<Object, Integer>> rowsMap = tablecellSizes.get(table);

		if (rowsMap == null) {
			tablecellSizes.put(table,
					rowsMap = new HashMap<Object, Map<Object, Integer>>());
		}

		Map<Object, Integer> rowheightsMap = rowsMap.get(row);
		if (rowheightsMap == null) {
			rowsMap.put(row, rowheightsMap = new HashMap<Object, Integer>());
		}

		rowheightsMap.put(column, height);
	}

	/**
	 * Look through all columns and get the renderer. If it is also a
	 * TextAreaRenderer, we look at the maximum height in its hash table for
	 * this row.
	 * 
	 * @param table
	 *            -JTable object
	 * @param row
	 *            - The row index of the cell being drawn.
	 * @return row maximum height as integer value
	 */
	private int findTotalMaximumRowSize(JTable table, int row) {
		int maximum_height = 0;
		Enumeration<TableColumn> columns = table.getColumnModel().getColumns();

		while (columns.hasMoreElements()) {
			TableColumn tc = columns.nextElement();
			TableCellRenderer cellRenderer = tc.getCellRenderer();
			if (cellRenderer instanceof GuiCellRenderer) {
				GuiCellRenderer tar = (GuiCellRenderer) cellRenderer;
				maximum_height = Math.max(maximum_height,
						tar.findMaximumRowSize(table, row));
			}
		}
		return maximum_height;
	}

	/**
	 * This will find the maximum row size
	 * 
	 * @param table
	 *            - JTable object
	 * @param row
	 *            - The row index of the cell being drawn.
	 * @return row maximum height as integer value
	 */
	private int findMaximumRowSize(JTable table, int row) {
		Map<Object, Map<Object, Integer>> rows = tablecellSizes.get(table);
		if (rows == null) {
			return 0;
		}
		Map<Object, Integer> rowheights = rows.get(row);
		if (rowheights == null) {
			return 0;
		}

		int maximum_height = 0;
		for (Map.Entry<Object, Integer> entry : rowheights.entrySet()) {
			int cellHeight = entry.getValue();
			maximum_height = Math.max(maximum_height, cellHeight);
		}
		return maximum_height;
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiCellRenderer.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiFrame.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.awt.Frame;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import javax.swing.border.LineBorder;

import org.jnativehook.GlobalScreen;
import org.jnativehook.NativeHookException;
import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;

/**
 * For implementing HotKeys for the GuiFrame
 */

public abstract class GuiFrame extends JFrame implements NativeKeyListener, WindowListener, KeyListener{
		
	/**
	 * generated
	 */
	private static final long serialVersionUID = 1179398807003068461L; 
	
	private final static Logger LOGGER = Logger.getLogger("TaskPad");

	  
	protected final double COMPUTER_WIDTH = 
			Toolkit.getDefaultToolkit().getScreenSize().getWidth();
	protected final double COMPUTER_HEIGHT = 
			Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	protected final Color ROOTPANE_BORDER_COLOR = 
			//new Color(120, 48, 160);//light purple?
			//new Color(41,36,33);	//Black
			//Color.gray;
			new Color(41,36,33);
	private final int ROOTPANE_BORDER_THICKNESS = 2;
	private LineBorder BORDER_ROOTPANE = new LineBorder(ROOTPANE_BORDER_COLOR, ROOTPANE_BORDER_THICKNESS);
	private ComponentResizer _resizer = new ComponentResizer();
	  
	protected boolean _isHiding = false;
	
	protected GuiFrame(){
		setupLogger();
		initalizeGuiFrame();
	}

	/**
	 * 
	 */
	private void setupLogger() {
		LOGGER.setLevel(Level.INFO);
				
		LOGGER.info("Setting up GuiFrame");
	}

	private void initalizeGuiFrame() {
		//to disable the titlebar
		setUndecorated(true);
		
		setupBorder();
		
		setUpResizer();
				                  
		addWindowListener(this);
		
		showWindow(true);	
		
		setAlwaysOnTop(true);
			   		
		//to clear the memory
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	/**
	 * all swing object should be invoke later
	 */
	private void setupBorder() {
		Runnable runBorderSetup = new Runnable(){
			@Override
			public void run(){
				LOGGER.info(this.toString());
				
				getRootPane().setBorder(BORDER_ROOTPANE);
			}
		};
		SwingUtilities.invokeLater(runBorderSetup);
	}      

	private void setUpResizer() {
		_resizer.registerComponent(this);

		
		Runnable runResizerSetup = new Runnable(){
			@Override
			public void run(){
				LOGGER.info("ROOTPANE_BORDER_THICKNESS: " + ROOTPANE_BORDER_THICKNESS);
				
				_resizer.setDragInsets(ROOTPANE_BORDER_THICKNESS * 2);  
			}
		};
		SwingUtilities.invokeLater(runResizerSetup);
		
		
		LOGGER.info("Have set up resizer");
	}
	
	protected boolean isHiding(){
		return _isHiding;
	}

	protected void showUp(final GuiFrame visibleFrame){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				setSize(visibleFrame.getSize());
				setLocation(visibleFrame.getLocation());
				setVisible(true);
				_isHiding = false;			
			}
		});
		
		LOGGER.info("showing GuiFrame");
	}
	     
	protected void close(){ 
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				dispose();		
			}
		});
		
		LOGGER.info("CLOSE!");
	}
	
	protected void hideWindow(){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				setVisible  (false);
				_isHiding = true;		
			}
		});
		
		
		LOGGER.info("hide!");
 	}
	
	protected void showWindow(final boolean isVisible){
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				setVisible(isVisible);	
			}
		});
		
		LOGGER.info("changed visibility: " + isVisible);
	}

	@Override
	public void windowOpened(WindowEvent arg0) {
		//Initialize native hook.
        try {
        		LOGGER.info("Initializing native hook");
        		
            	GlobalScreen.registerNativeHook();
        }
        catch (NativeHookException ex) {
        		LOGGER.severe("There was a problem registering the native hook.\n");
        		LOGGER.severe(ex.getMessage());
                ex.printStackTrace();

                System.exit(1);
        }     

        GlobalScreen.getInstance().addNativeKeyListener(this);
        //requestFocusInWindow(); should not request focus here
	}
	
	@Override
	public void windowClosed(WindowEvent arg0) {
		//end Program to disable every listeners! Exit Program to really exit it.
		endProgram();
	    exitProgram();
	}
	
	@Override
	public void nativeKeyPressed(NativeKeyEvent arg0) {
		
		boolean isEscapeKey = arg0.getKeyCode() == NativeKeyEvent.VK_ESCAPE;
		boolean isShiftSpaceKey = arg0.getKeyCode() == NativeKeyEvent.VK_SPACE 
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).
				equals("Shift");
		boolean isAltEndKey = arg0.getKeyCode() == NativeKeyEvent.VK_END 
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).
				equals("Alt");
		
		
		/**
		 * we will disable some keys when TaskPad is in
		 * hiding mode
		 */
		isEscapeKey = isEscapeKey && isVisible();
		isAltEndKey = isAltEndKey && isVisible();
		
		
		if (isAltEndKey) {
			minimizeOrRestore();
		} else if (isShiftSpaceKey){
			hideOrShow();
		} else if (isEscapeKey){
			endProgram();
			exitProgram();
		} 		
	}
	
	/**
	 * override by inputFrame
	 */
	protected void requestFocusOnInputBox() {
	}
	

	private void hideOrShow() {		
		Runnable changeVisibility = getVisibilityChanges();
		SwingUtilities.invokeLater(changeVisibility);
	}

	private void minimizeOrRestore() {
		Runnable changeState = getStateChanges();
		SwingUtilities.invokeLater(changeState);
	}

	protected void endProgram() {
		LOGGER.info("Program HALT");
		
		//Clean up every listener
        GlobalScreen.unregisterNativeHook();
        _resizer.deregisterComponent(this);
	}
	
	private void exitProgram() {
		Runnable runExit = new Runnable(){
			@Override
			public void run(){
				LOGGER.info(this.toString());
				LOGGER.severe("EXIT NOW!!!");
				
				System.runFinalization();
			    System.exit(0);
			}
		};
		SwingUtilities.invokeLater(runExit);
	}
	
	private Runnable getVisibilityChanges() {
		Runnable changeVisibility = new Runnable(){
			@Override
			public void run(){
				LOGGER.info(this.toString());
				LOGGER.info("hiding? " + _isHiding);
				
				if (_isHiding){
					return;
				}
				
				boolean isShown = isVisible() == true;
				boolean isHided = isVisible() == false;
				if (isShown){
				  	hide();
				} else if (isHided){
					show();
				}
			}
 
			private void show() {
				LOGGER.info("SHOW!");
				
				showWindow(true);
				setState(Frame.NORMAL);
				
				requestFocusOnInputBox();
			}

			private void hide() {
				LOGGER.info("HIDE!");

				showWindow(false);
			}
		};
		return changeVisibility;
	}

	private Runnable getStateChanges() {
		Runnable changeState = new Runnable(){
			@Override
			public void run(){
				LOGGER.info(this.toString());
				
				boolean isMinimized = getExtendedState() == Frame.ICONIFIED;
				boolean isRestored = getExtendedState() == Frame.NORMAL;
				if (isMinimized){
					restore();
				} else if (isRestored){
					minimize();
				}
			}

			private void minimize() {
				LOGGER.info("minimize!");
				setState(Frame.ICONIFIED);
			}

			private void restore() {
				LOGGER.info("restore!");
				setState(Frame.NORMAL);
			}
		};
		return changeState;
	}
	
	//abstract protected int getInitialWidth();
	//abstract protected int getInitialHeight();
	
	
	//won't implement
	@Override
	public void windowActivated(WindowEvent arg0) {
		
	}

	@Override
	public void windowClosing(WindowEvent arg0) {
		
	}

	@Override
	public void windowDeactivated(WindowEvent arg0) {
		
	}

	@Override
	public void windowDeiconified(WindowEvent arg0) {
		
	}

	@Override
	public void windowIconified(WindowEvent arg0) {
		
	}

	@Override
	public void nativeKeyReleased(NativeKeyEvent arg0) {
		
	}

	@Override
	public void nativeKeyTyped(NativeKeyEvent arg0) {
		
	}

	@Override
	public void keyTyped(KeyEvent e) {
	}

	@Override
	public void keyPressed(KeyEvent e) {		
	}

	@Override
	public void keyReleased(KeyEvent e) {		
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiFrame.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiManager.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.util.logging.Logger;

import javax.swing.SwingUtilities;

import com.taskpad.alarm.AlarmManager;
import com.taskpad.input.InputManager;

public class GuiManager {
	private final static Logger LOGGER = Logger.getLogger("TaskPad");

	private static final String NEWLINE = "\n\n";
	private static final String MESSAGE_START_REMINDER = "Today's Tasks ";
	private static InputFrame _inputFrame;
	private static OutputFrame _outputFrame;
	private static OutputTableFrame _tableFrame;
	private static boolean _isDebug = false;
	private static boolean _isGuiTest = false;
	private static boolean _isTableCalled = false;

	// not designed to be instantiated
	private GuiManager() {
	}

	// invoke all frames to a thread
	public static void initialGuiManager() {
		initializeTableFrame();
		initializeFlexiFontOutputFrame();
		initializeInputFrame();
	}

	/**
	 * 
	 */
	private static void initializeInputFrame() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				_inputFrame = new InputFrame();
			}

		});
	}

	/**
	 * 
	 */
	private static void initializeTableFrame() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				_tableFrame = new OutputTableFrame();
			}

		});
	}

	/**
	 * 
	 */
	private static void initializeFlexiFontOutputFrame() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				_outputFrame = new FlexiFontOutputFrame();
			}

		});
	}

	/*
	 * deprecated public static void initialGuiManager(InputFrame inputFrame,
	 * OutputFrame outputFrame) { setInputFrame(inputFrame);
	 * setOutputFrame(outputFrame); }
	 */

	public static void callTable(final Object[][] data) {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				swapFrame(_outputFrame, _tableFrame);
				_tableFrame.refresh(data);
				_inputFrame.requestFocusOnInputBox();
			}

		});
	}

	/**
	 * @param data
	 */
	private static void swapFrame(final GuiFrame firstFrame,
			final GuiFrame secondFrame) {

		boolean isHided = firstFrame.isHiding();

   		LOGGER.info("isHided is : " + isHided);

		if (isHided) {
			LOGGER.info("IS NOT SWAPPING!!! ");
			
			firstFrame.hideWindow();
			secondFrame.showUp(secondFrame);
			
			return;
		} else {
			LOGGER.info("IS SWAPPING!!! ");

			firstFrame.hideWindow();
			secondFrame.showUp(firstFrame);
			_isTableCalled = !_isTableCalled;

			LOGGER.info("HAS SWAPPED ");
		}
	}

	public static void showWindow(final boolean isVisible) {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				_inputFrame.showWindow(isVisible);
				swapFrame(_tableFrame, _outputFrame);
				_inputFrame.requestFocusOnInputBox();
			}

		});

	}

	public static void callExit() {
		closeAllWindows();

	}

	private static void closeAllWindows() {

		_inputFrame.close();
		_outputFrame.close();
		_tableFrame.close();

	}

	public static void callOutput(final String out) {
		callOutputNoLine(out + NEWLINE);

	}

	public static void callOutputNoLine(final String out) {
		if (!_isDebug || _isGuiTest) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override
				public void run() {
					swapFrame(_tableFrame, _outputFrame);
					_outputFrame.addLine(out);

					_inputFrame.requestFocusOnInputBox();
				}
			});

		}
		
		if (_isDebug){
			System.out.print(out);
		}

	}

	/**
	 * @deprecated
	 * @param out
	 */
	protected static void callInputBox(String out) {
		_inputFrame.setLine(out);
	}

	public static void showSelfDefinedMessage(String out, Color c,
			boolean isBold) {
		showSelfDefinedMessageNoNewline(out + NEWLINE, c, isBold);

	}

	public static void showSelfDefinedMessageNoNewline(final String out,
			final Color c, final boolean isBold) {
		if (!_isDebug || _isGuiTest) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override
				public void run() {
					swapFrame(_tableFrame, _outputFrame);
					_outputFrame.addSelfDefinedLine(out, c, isBold);

					_inputFrame.requestFocusOnInputBox();
				}

			});

		} 
		
		if (_isDebug){
			System.out.print(out);
		}

	}

	
	public static void startRemindingUser() {
		remindUser(MESSAGE_START_REMINDER);
	}

	private static void remindUser(final String out) {
		// swapFrame(_tableFrame, _outputFrame);
		_outputFrame.addReminder(out + NEWLINE);
		
		if (_isDebug){
			System.out.print(out + NEWLINE);
		}
	}

	protected static void passInput(final String in) {
		InputManager.receiveFromGui(in);
	}

	protected static void turnOffAlarm() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				try {
					AlarmManager.turnOffAlarm();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

		});
	}

	protected static void cancelAlarms() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				try {
					AlarmManager.cancelAlarms();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

		});
	}

	protected static OutputFrame getOutputFrame() {
		return _outputFrame;
	}

	public static void clearOutput() {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				swapFrame(_tableFrame, _outputFrame);
				_outputFrame.clearOutputBox();
				_inputFrame.requestFocusOnInputBox();
			}

		});
		
	}

	// for debug
	public static boolean getInputFrameVisibility() {
		boolean isNormal = _inputFrame.isVisible();
		return isNormal;
	}

	public static boolean getOutputFrameVisibility() {
		boolean isNormal = _outputFrame.isVisible();
		return isNormal;
	}

	public static boolean getTableVisibility() {
		boolean isNormal = _tableFrame.isVisible();
		return isNormal;
	}

	public static boolean isTableActive() {
		return _isTableCalled;
	}

	public static void setDebug(boolean isDebugFlag) {
		_isDebug = isDebugFlag;
		_isTableCalled = false;
	}
	
	public static void setGui(boolean isGuiTest) {
		_isGuiTest = isGuiTest;
	}

	/*
	 * deprecated private static void setInputFrame(InputFrame _inputFrame) {
	 * GuiManager._inputFrame = _inputFrame; }
	 * 
	 * private static void setOutputFrame(OutputFrame _outputFrame) {
	 * GuiManager._outputFrame = _outputFrame; }
	 */

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiTableModel.java
	 */


package com.taskpad.ui;

import javax.swing.table.DefaultTableModel;

public class GuiTableModel extends DefaultTableModel {

	/**
	 * generated
	 */
	private static final long serialVersionUID = 7747422784248466091L;

	private static final String[] _columnNames = { "ID", "Description",
			"Deadline", "Start", "End", "Info", "Status" };

	/*private static Object[][] _data = {
		{"1", "Hi Lynnette!", "06/04/2014", "01:00 05/04/2014", "12:00 05/04/2014", "JUST FOR FUN", "DONE"}
	};*/
	private static Object[][] _data = {};
	
	protected GuiTableModel(){
		super(_data, _columnNames);
	}

	@Override
	public boolean isCellEditable(int row, int column) {
		// all cells false
		return false;
	}
	
	/*
	public void refresh(Object[][] objects){
	    //make the changes to the table, then call fireTableChanged
		_data = objects;
	    fireTableChanged(null);
	}
	*/

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\GuiTableModel.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\InputFrame.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;
import java.util.LinkedList;
import java.util.logging.Logger;

import javax.swing.JTextField;
import javax.swing.SwingUtilities;

import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;

public class InputFrame extends GuiFrame{
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = 6500266679828724479L;
	
	private final static Logger LOGGER = Logger.getLogger("TaskPad");


	private static final Color INPUTBOX_BACKGROUND_COLOR = 
			//new Color(219, 219, 219); //this is grey color
			new Color(255,248,220);		//Cornsilk
	
	//inputTextBox
	private static JTextField _input = new JTextField(15);
	
	private static final int INPUTFRAME_WIDTH = 800;
	private static final int INPUTFRAME_HEIGHT = 33;
	private static final int HISTORY_LIMIT = 3000;
	
	private TextFieldListener _seeText = new TextFieldListener(this);
	private ComponentMover _moveInputBox = new ComponentMover(this);
	
	//protected static ArrayList<String> _inputHistory = new ArrayList<String>();
	private LinkedList<String> _historyInput = new LinkedList<String>();
	private int _historyCount = 0;
	
	private static final String EMPTY = "";
	
	protected InputFrame(){
		super();
		initializeInputFrame();
	}

	private void initializeInputFrame() {		
		setUpFrame();
		
		initializeInputBox();
		this.getContentPane().add(_input);
	}

	private void setUpFrame() {
		setSize(INPUTFRAME_WIDTH, INPUTFRAME_HEIGHT);
		setLocation((int)(COMPUTER_WIDTH / 2 - INPUTFRAME_WIDTH / 2),
					(int)(COMPUTER_HEIGHT / 2 + OutputFrame.getInitialHeight() / 2 - INPUTFRAME_HEIGHT / 2));
		setVisible(true);
		_isHiding = false;
	}

	private void initializeInputBox() {
		//ready to receive key
		_input.addKeyListener(this);
		
		//ready to receive input
		_input.addActionListener(_seeText);
		
		//ready to move
		_moveInputBox.registerComponent(_input);
		//_input.addMouseListener(_mousePress);      DEPRECATED
		//_input.addMouseMotionListener(_mouseMove); DEPRECATED
		
		_input.setBackground(INPUTBOX_BACKGROUND_COLOR);
		
		_input.setFocusable(true);
		_input.setRequestFocusEnabled(true);
		
		requestFocusOnInputBox();
	}
	
	@Override
	public void windowDeiconified(WindowEvent arg0) {
		requestFocusOnInputBox();
	}       

	@Override
	public void nativeKeyPressed(NativeKeyEvent arg0) {
		super.nativeKeyPressed(arg0);
		
		boolean isCtrlI = arg0.getKeyCode() == NativeKeyEvent.VK_I
	            && NativeInputEvent.getModifiersText(arg0.getModifiers()).equals(
	                    "Ctrl");
		boolean isAltAKey = arg0.getKeyCode() == NativeKeyEvent.VK_A 
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).
				equals("Alt");
		boolean isAltCKey = arg0.getKeyCode() == NativeKeyEvent.VK_C
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).
				equals("Alt");
		
		isAltCKey = isAltCKey && isVisible();
		
		if (isCtrlI){
			requestFocusOnInputBox();
		} else if (isAltAKey){
			switchOffAlarm();
		} else if (isAltCKey){
			cancelAlarms();
		} 
	}
	
	private void cancelAlarms() {
    	LOGGER.info("Canceling Alarm...");
		
    	Runnable runCancel = new Runnable(){
			@Override
			public void run(){
				GuiManager.cancelAlarms();
			}
		};
		SwingUtilities.invokeLater(runCancel);
	}

	private void switchOffAlarm() {
		try {
    		LOGGER.info("Switching off Alarm...");
			
			GuiManager.turnOffAlarm();
		} catch (Exception e) {
			//System.err.println(e.getMessage());
			//do nothing
		}
	}

	
	@Override
	public void keyPressed(KeyEvent arg0) {
		boolean isUpKey = arg0.getKeyCode() == KeyEvent.VK_UP;
		boolean isDownKey = arg0.getKeyCode() == KeyEvent.VK_DOWN;
		
		if (isUpKey){
			showPastCommands();
		} else if (isDownKey){
			showNextCommands();
		}
	}
	
	protected void addHistory(String inputString){
		int size = _historyInput.size();
		if (size >= HISTORY_LIMIT){
			_historyInput.removeLast();
		}
		_historyInput.addFirst(inputString);
		
		initializeHistory();
	}
	
	private void initializeHistory(){
		_historyCount = 0;
	}
	
	private void showPastCommands(){ 
		int size = _historyInput.size();
		if (isBoundary()){
			return;
		}
		
		String outputString = _historyInput.get(_historyCount);
		_input.setText(outputString);
		
		boolean isNotMaximum = _historyCount < size - 1;
		if(isNotMaximum){
			_historyCount++;
		}
	}

	/**
	 * @param size
	 * @return
	 */
	private boolean isBoundary() {
		int size = _historyInput.size();
		return _historyCount >= size && _historyCount < 0 || size == 0;
	}
	
	private void showNextCommands(){
		if (isBoundary()){
			return;
		}
		

		String outputString = EMPTY;
		
		boolean isNotMinimum = _historyCount > 0;
		if (isNotMinimum){
			_historyCount--;
			outputString = _historyInput.get(_historyCount);
		} 
		_input.setText(outputString);	
	}
	
	@Override
	protected void requestFocusOnInputBox() {
		Runnable inputBoxFocus = new Runnable(){
			@Override
			public void run(){
				_input.grabFocus();  
				_input.requestFocusInWindow();
			}
		};
		SwingUtilities.invokeLater(inputBoxFocus);
	}
	
	protected String getText(){
		return _input.getText();
	}
	
	protected void reset(){
		Runnable resetBox = new Runnable(){
			@Override
			public void run(){
				_input.setText(InputFrame.EMPTY);
			}
		};
		SwingUtilities.invokeLater(resetBox);
		
	}
	
	protected JTextField getInputBox(){
		return _input;
	}
	
	//@Override
	protected static int getInitialWidth(){
		return INPUTFRAME_WIDTH;
	}
	
	//@Override
	protected static int getInitialHeight(){
		return INPUTFRAME_HEIGHT;
	}
	
	@Override
	protected void endProgram(){
		super.endProgram();
		
		//clear every listener before closing
		_input.removeActionListener(_seeText);
		
		_moveInputBox.deregisterComponent(_input);
		//_input.removeMouseListener(_mousePress);      DEPRECATED
		//_input.removeMouseMotionListener(_mouseMove); DEPRECATED
	}

	protected void passInput(String inputString) {
		GuiManager.passInput(inputString);
	}
	
	/**
	 * @deprecated
	 * @param line
	 */
	protected void setLine(String line) {
		_input.setText(line);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\InputFrame.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\MouseMover.java
	 */


package com.taskpad.ui;



import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

import javax.swing.JFrame;

/**
 * 
 * ===================DEPRECATED========================== 
 *  *
 * @category
 * MouseDragActioner is the actual class to do the moving
 * with the help of MousePressedDetector.
 * 
 * @deprecated
 * DEPRECATED: replaced by ComponentMover.java
 *
 */

public class MouseMover implements MouseMotionListener{
	private static Point _mouseDownPoint = MousePressedDetector.getMouseDownPoint();
	private static Point _currPoint = null;
	private static Point _movePoint = null;
	private JFrame _movingFrame = null;
	
	/**
	 * @deprecated
	 *  DEPRECATED: private constructor shows that it cannot be used anymore.
	 * @param ListenFrame
	 */
	private MouseMover(JFrame ListenFrame){
		setMovingFrame(ListenFrame);
	}
	
	@Override
	public void mouseDragged(MouseEvent e) {
		initializedPoints(e);
		move();
	}

	private void initializedPoints(MouseEvent e) {
		setCurrPoint(e.getLocationOnScreen());
		setMouseDownPoint(MousePressedDetector.getMouseDownPoint());
		setMovePoint(new Point(_currPoint.x - _mouseDownPoint.x, _currPoint.y - _mouseDownPoint.y));
	}

	private void move() {
		_movingFrame.setLocation(_movePoint);
	}

	private void setMouseDownPoint(Point mouseDownPoint) {
		_mouseDownPoint = mouseDownPoint;
	}

	private static void setCurrPoint(Point _currPoint) {
		MouseMover._currPoint = _currPoint;
	}
	
	private static void setMovePoint(Point _movePoint) {
		MouseMover._movePoint = _movePoint;
	}

	private void setMovingFrame(JFrame _movingFrame) {
		this._movingFrame = _movingFrame;
	}

	//unimplemented
	@Override
	public void mouseMoved(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\MouseMover.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\MousePressedDetector.java
	 */


package com.taskpad.ui;



import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/**
 * 
 * ===================DEPRECATED==========================
 * 
 * @category
 * MousePressedDetector is created to detect whether 
 * the mouse has clicked on the boxes or not.
 * 
 * It is a helper class to move JFrame......
 * 
 * @deprecated
 * DEPRECATED: replaced by ComponentMover.java
 *
 */

public class MousePressedDetector implements MouseListener {
	private static Point _mouseDownPoint = null;
	
	/** 
	 * @deprecated
	 * DEPRECATED: private constructor shows that it cannot be used anymore.
	 * To make sure it cannot be used by other package
	 */
	private MousePressedDetector(){
	}

	@Override
	public void mousePressed(MouseEvent e) {
		setMouseDownPoint(e.getPoint());
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		setMouseDownPoint(null);
	}
	
	protected static Point getMouseDownPoint() {
		return _mouseDownPoint;
	}
	

	private void setMouseDownPoint(Point _mouseDownPoint) {
		MousePressedDetector._mouseDownPoint = _mouseDownPoint;
	}

	
	//unimplemented methods at below:
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
	@Override
	public void mouseClicked(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\MousePressedDetector.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\OutputFrame.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.BorderFactory;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;

import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;



/**
 * 
 * ===============DEPRECATED================
 * 
 * This class is deprecated as this class can only 
 * show text font with only one color.
 * 
 * But we need different font color for reminder...
 * JTextArea doesn't support this functionality 
 * so we have to implement a new class......
 * 
 * @category
 * Change to become a parent class
 * 
 * @see
 * FlexiFontOutputFrame
 * 
 */

public abstract class OutputFrame extends GuiFrame{

	/**
	 * default
	 */
	private static final long serialVersionUID = 1L;
	
	//protected final Color OUTPUTBOX_BORDER_COLOR = 
	//		new Color(112, 48, 160);//light purple?
	protected final Color OUTPUTBOX_BORDER_COLOR = Color.white;
	protected final Color OUTPUTBOX_BACKGROUND_COLOR = 
			//new Color(242, 242, 242);//light grey I think
			new Color(240,248,255);		//Baby blue
	
	private final static int OUTPUTFRAME_WIDTH = 800;
	private final static int OUTPUTFRAME_HEIGHT = 350;
	
	private final Color DEFAULT_FONT_COLOR = Color.black;
	
	//outputTextBox
	private JTextArea _output = new JTextArea(5, 15);
	
	//children should have scroll bar too
	protected JScrollPane _scrollBox  = new JScrollPane();
		
	protected OutputFrame(){
		super();
		initializeOutputFrame();
	}
	
	protected OutputFrame(boolean inherit){
		super();
	}

	protected void setUpFrame() {
		setSize(OUTPUTFRAME_WIDTH, OUTPUTFRAME_HEIGHT);
		setLocation((int)(COMPUTER_WIDTH / 2 - OUTPUTFRAME_WIDTH / 2),
					(int)(COMPUTER_HEIGHT / 2 - OUTPUTFRAME_HEIGHT / 2 - InputFrame.getInitialHeight() / 2));
	}

	private void initializeOutputFrame() {				
		setUpFrame();
		
		initializeOutputBox();
		
		setUpScrollBar();

		this.getContentPane().add(_scrollBox);
	}

	protected void setUpScrollBar() {
		//JScrollPane provides scroll bar, so I add outputbox inside it.
		_scrollBox = new JScrollPane(_output);
		disableHorizontalScrollBar();
	}

	protected void disableHorizontalScrollBar() {
		_scrollBox.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
	}


	protected void initializeOutputBox() {
		// Don't let the user change the output.
		_output.setEditable(false);
		
		// Fix the maximum length of the line
		_output.setLineWrap(true);
		
		_output.setBackground(OUTPUTBOX_BACKGROUND_COLOR);
		
		Border line = BorderFactory.createLineBorder(OUTPUTBOX_BORDER_COLOR);
		_output.setBorder(line);
		
		initializeFont();
	}

	private void initializeFont() {
		Font font = new Font("Verdana", Font.BOLD, 12);
		_output.setFont(font);
		_output.setForeground(DEFAULT_FONT_COLOR);
	}
	
	protected void clearOutputBox() {
		_output.setText("");
	}
	
	protected void addLine(String line) {
		_output.append(line);
	}
	
	protected void addReminder(String line) {
		_output.append(line);
	}
	
	@Override
	public void nativeKeyPressed(NativeKeyEvent arg0) {
		super.nativeKeyPressed(arg0);
		
		boolean isCtrlW= arg0.getKeyCode() == NativeKeyEvent.VK_W
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).equals(
	                    "Ctrl");
		boolean isCtrlS = arg0.getKeyCode() == NativeKeyEvent.VK_S				
				&& NativeInputEvent.getModifiersText(arg0.getModifiers()).equals(
	                    "Ctrl");

		
		if (isCtrlW){
			scrollUp();
			
		} else if (isCtrlS){
			scrollDown();
		}
	}

	private void scrollDown() {
		Runnable downScroller = new BarScroller(false, _scrollBox.getVerticalScrollBar());
		SwingUtilities.invokeLater(downScroller);
	}

	private void scrollUp() {
		Runnable upScroller = new BarScroller(true, _scrollBox.getVerticalScrollBar());
		SwingUtilities.invokeLater(upScroller);
	}
	
	protected static int showWidth(){
		return OUTPUTFRAME_WIDTH;
	}
	
	abstract protected void addSelfDefinedLine(String line, Color c, boolean isBold);
	
	@Override
	protected void endProgram(){
		super.endProgram();
	}

	//@Override
	protected static int getInitialWidth(){
		return OUTPUTFRAME_WIDTH;
	}
	
	//@Override
	protected static int getInitialHeight(){
		return OUTPUTFRAME_HEIGHT;
	}
}
	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\OutputFrame.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\OutputTableFrame.java
	 */


package com.taskpad.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.TableColumn;

import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;

public class OutputTableFrame extends GuiFrame {

	/**
	 * generated
	 */
	private static final long serialVersionUID = -325278351936827523L;

	private JTable _table;
	private GuiTableModel _taskpadTableModel;
	private JScrollPane _scrollBox;

	private final static int TABLEFRAME_WIDTH = 800;
	private final static int TABLEFRAME_HEIGHT = 350;

	private final String FONT_HEADER_TYPE = "Lucida Console";
	private final int FONT_HEADER_SIZE = 12;
	private final int FONT_HEADER_STYLE = Font.BOLD;
	private final Font FONT_HEADER_DEFAULT = new Font(FONT_HEADER_TYPE,
			FONT_HEADER_STYLE, FONT_HEADER_SIZE);
	private static final Color COLOR_TABLE_BACKGROUND = new Color(240,248,255);
	
	private ComponentMover _moveOutputBox = new ComponentMover(this);

	
	protected OutputTableFrame() {
		super();
		intializeOutputTableFrame();
	}

	private void intializeOutputTableFrame() {
		setUpFrame();
		setVisible(false);

		_taskpadTableModel = new GuiTableModel();
		_table = new JTable(_taskpadTableModel);
		_scrollBox = new JScrollPane(_table);
		
		customizeHeaderStyle();
		
		_table.setBackground(COLOR_TABLE_BACKGROUND);

		setUpColumnWidth();
		
		
		//to make it movable
		_moveOutputBox.registerComponent(_table);
		
		_table.setFillsViewportHeight(true);
		add(_scrollBox);



		
		
		_isHiding = true;
	}


	/**
	 * 
	 */
	private void customizeHeaderStyle() {
		_table.getTableHeader().setFont(FONT_HEADER_DEFAULT);
		_table.getTableHeader().setBackground(Color.black);
		_table.getTableHeader().setForeground(OutputTableFrame.COLOR_TABLE_BACKGROUND);
		
		//disable the reordering option
		_table.getTableHeader().setReorderingAllowed(false);
	}

	protected void setUpFrame() {
		setSize(TABLEFRAME_WIDTH, TABLEFRAME_HEIGHT);
		setLocation((int) (COMPUTER_WIDTH / 2 - TABLEFRAME_WIDTH / 2),
				(int) (COMPUTER_HEIGHT / 2 - TABLEFRAME_HEIGHT / 2 - InputFrame
						.getInitialHeight() / 2));
	}

	protected void refresh(final Object[][] objects) {
		SwingUtilities.invokeLater(new Runnable(){
			@Override
			public void run() {
				reset();
				for (int i = 0; i < objects.length; i++) {
					_taskpadTableModel.addRow(objects[i]);
				}

				setUpColumnWidth();
				_table.repaint();
			}
			
		});
		
		// _taskpadTableModel.refresh(objects);

		/*
		 * DEBUG for (int i = 0; i < objects.length; i++){ for (int j = 0; j <
		 * objects[i].length; j++){ System.err.println(objects[i][j]); } }
		 *
		 */
	}

	private void setUpColumnWidth() {
		final int colNo = _table.getColumnCount();
		
		//_table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		_table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		
		Runnable runColWidthSetup = setAllColumns(colNo);
		SwingUtilities.invokeLater(runColWidthSetup);
	}

	/**
	 * @param colNo
	 * @return
	 */
	private Runnable setAllColumns(final int colNo) {
		Runnable runColWidthSetup = new Runnable(){
			@Override
			public void run(){
				for (int i = 0; i < colNo; i++) {
					TableColumn column = _table.getColumnModel().getColumn(i);
					int preferredWidthID = 25;
					int noOfColLeft = 2;
					boolean isDesc = i == 1;
					boolean isID = i == 0;
					if (isID) {
						column.setCellRenderer(new GuiCellRenderer());
						column.setPreferredWidth(preferredWidthID);
					} else if (isDesc) {
						column.setCellRenderer(new GuiCellRenderer());
						column.setPreferredWidth((getWidth() - preferredWidthID -
								noOfColLeft * (getWidth() - preferredWidthID) / (colNo - noOfColLeft)));
					} else {
						column.setCellRenderer(new GuiCellRenderer());
						column.setPreferredWidth((getWidth() - preferredWidthID) / (colNo - noOfColLeft));
					}
				}
			}
		};
		return runColWidthSetup;
	}

	private void reset() {
		_taskpadTableModel.setRowCount(0);
	}

	@Override
	public void nativeKeyPressed(NativeKeyEvent arg0) {
		super.nativeKeyPressed(arg0);

		boolean isCtrlW = arg0.getKeyCode() == NativeKeyEvent.VK_W
				&& NativeInputEvent.getModifiersText(arg0.getModifiers())
						.equals("Ctrl");
		boolean isCtrlS = arg0.getKeyCode() == NativeKeyEvent.VK_S
				&& NativeInputEvent.getModifiersText(arg0.getModifiers())
						.equals("Ctrl");

		if (isCtrlW) {
			scrollUp();

		} else if (isCtrlS) {
			scrollDown();
		}
	}

	private void scrollDown() {
		Runnable downScroller = new BarScroller(false,
				_scrollBox.getVerticalScrollBar());
		SwingUtilities.invokeLater(downScroller);
	}

	private void scrollUp() {
		Runnable upScroller = new BarScroller(true,
				_scrollBox.getVerticalScrollBar());
		SwingUtilities.invokeLater(upScroller);
	}
	
	@Override
	protected void endProgram() {
		super.endProgram();
		
		//clear every listener before closing
		_moveOutputBox.deregisterComponent(_table);
	}

	// /*
	public static void main(String[] args) {
		OutputTableFrame anyTable = new OutputTableFrame();
		anyTable.showWindow(true);
	}
	// */
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\OutputTableFrame.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\TextFieldListener.java
	 */


package com.taskpad.ui;



import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TextFieldListener implements ActionListener
{  
	private InputFrame _textFrame;
	protected TextFieldListener(InputFrame textFrame){
		setTextFrame(textFrame);
	}

	/**
	 * @param textFrame
	 */
	private void setTextFrame(InputFrame textFrame) {
		_textFrame = textFrame;
	}
	
	@Override
	public void actionPerformed(ActionEvent evt)
	{  
		String inputString = _textFrame.getText();
		_textFrame.passInput(inputString);
		_textFrame.addHistory(inputString);
		_textFrame.reset();
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\TextFieldListener.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapColumnFactory.java
	 */


package com.taskpad.ui;



/**
 * 
 * This class is created to fix
 * the line wrap problem in JTextPane Java 1.7
 * 
 * WrapColumnFactory creates view on JTexTPane Doucument
 * 
 */

import javax.swing.text.AbstractDocument;
import javax.swing.text.BoxView;
import javax.swing.text.ComponentView;
import javax.swing.text.Element;
import javax.swing.text.IconView;
import javax.swing.text.LabelView;
import javax.swing.text.ParagraphView;
import javax.swing.text.StyleConstants;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;

public class WrapColumnFactory implements ViewFactory {
	/**
	 * To make sure it cannot be used by other package.
	 */
	protected WrapColumnFactory(){
	}
	
    public View create(Element elem) {
        String kind = elem.getName();
        if (kind != null) {
            if (kind.equals(AbstractDocument.ContentElementName)) {
                return new WrapLabelView(elem); //key is here, wrap the content
            } else if (kind.equals(AbstractDocument.ParagraphElementName)) {
                return new ParagraphView(elem);
            } else if (kind.equals(AbstractDocument.SectionElementName)) {
                return new BoxView(elem, View.Y_AXIS);
            } else if (kind.equals(StyleConstants.ComponentElementName)) {
                return new ComponentView(elem);
            } else if (kind.equals(StyleConstants.IconElementName)) {
                return new IconView(elem);
            }
        }

        // default to text display
        return new LabelView(elem);
    }
}
	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapColumnFactory.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapEditorKit.java
	 */


package com.taskpad.ui;



import javax.swing.text.StyledEditorKit;
import javax.swing.text.ViewFactory;

/**
 * 
 * 
 * This class is created to fix
 * the line wrap problem in JTextPane Java 1.7
 * Hope it works!
 * 
 * WrapEditorKit:
 * This is the set of things needed by a text component 
 * to be a reasonably functioning editor for some type of text document. 
 * This implementation provides a default implementation which treats 
 * text as styled text and provides a minimal set of actions for editing styled text, 
 * and we add the viewFactory that we manually create to here,
 * in order to connect it to JTextPane
 * 
 * 
 */
public class WrapEditorKit extends StyledEditorKit {
    /**
	 * generated
	 */
	private static final long serialVersionUID = -2439803723035686677L;

	private ViewFactory _defaultFactory = new WrapColumnFactory();
	
	/**
	 * To make sure it cannot be used by other package
	 */
	protected WrapEditorKit(){
	}
	
	@Override
    public ViewFactory getViewFactory() {
        return _defaultFactory;
    }

}
	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapEditorKit.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapLabelView.java
	 */


package com.taskpad.ui;



/**
 * 
 * 
 * This class is created to fix
 * the line wrap problem in JTextPane Java 1.7
 * Hope it works!
 * 
 * WrapLabelView: wrap the view to the text.
 * 
 * The logic is following when a row is bigger 
 * than available width the row must be broken. 
 * The first part (row) should be less than available width. 
 * 
 * The rest again is measured and can be broken once more 
 * if it's bigger than available width.
 * 
 */

import javax.swing.text.Element;
import javax.swing.text.LabelView;
import javax.swing.text.View;

public class WrapLabelView extends LabelView {
	/**
	 * to make sure it cannot be used by other package
	 * @param elem
	 */
    protected WrapLabelView(Element elem) {
        super(elem);
    }

    
    /**
	 * Size of content is defined by minimumSpan
	 * (can't be less than minimal possible). 
	 * So when it's in a scroll scroll measures width and asks for minimal span.
	 * Then width of JScrollPane's content = width of viewport 
	 * (or if min width is bigger =min width).
	 */
    
    @Override
    public float getMinimumSpan(int axis) {
        switch (axis) {
            case View.X_AXIS:
                return 0;
            case View.Y_AXIS:
                return super.getMinimumSpan(axis);
            default:
                throw new IllegalArgumentException("Invalid axis: " + axis);
        }
    }

}
	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\ui\WrapLabelView.java





