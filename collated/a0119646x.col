//@author: a0119646x



	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTimeManager.java
	 */


/* Public API to call dates */

package com.taskpad.dateandtime;

import java.text.ParseException;
import java.util.ArrayList;

import com.taskpad.ui.GuiManager;

/**
 * 
 * DateAndTimeManager is a facade class of dateandtime package.
 * 
 */
public class DateAndTimeManager{

	//private static DateAndTime _dateAndTimeObject = new DateAndTime();

	private static final String STRING_EMPTY = "";
	private static final String STRING_QUOTE = "\"";
	private static DateAndTimeManager _managerInstance = new DateAndTimeManager();
	private static DateAndTimeRetriever _datr = DateAndTimeRetriever.getInstance();
	
	//Private constructor to prevent instantiation by other classes
	private DateAndTimeManager() {
	}

	/**
	 * @return single instance of DateAndTimeManager
	 */
	public static DateAndTimeManager getInstance() {
		return _managerInstance;
	}

	/**
	 * getTodayTime: return the current time.
	 * 
	 * @return String
	 */
	public String getTodayTime() {
		return _datr.getTodayTime();
		//_dateAndTimeObject = new DateAndTime();
		//return _dateAndTimeObject.getCurrentTime();
	}

	/**
	 * getTodayDate: return today's date
	 * 
	 * @return String
	 */
	public String getTodayDate() {
		return _datr.getTodayDate();
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		//return _dateAndTimeObject.getCurrentDate();
	}

	/**
	 * getTodayDay: return today's day
	 * 
	 * @return String
	 */
	public String getTodayDay() {
		return _datr.getTodayDay();
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		//return _dateAndTimeObject.getCurrentDay();
	}

	/**
	 * getTodayDateAndTime: to get today's date and the current time
	 * 
	 * @return String
	 */
	public String getTodayDateAndTime() {
		return _datr.getTodayDateAndTime();
		//DateAndTime _dateAndTimeObject = new DateAndTime();
		//return _dateAndTimeObject.getCurrentTimeAndDate();
	}
	
	/**
	 * Takes in a string and formats date and time to TaskPad standards 
	 * dd/MM/yyyy and HH:mm then retrieve all types of date and time
	 * @param input
	 * @return desc | Deadline: | StartTime: Date then Time | EndTime: Date Then Time
	 * @throws InvalidQuotesException 
	 */
	public String formatDateAndTimeInString(String input) throws InvalidQuotesException{
		//DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		return _datr.formatDateAndTimeInString(input);
	}
	
	/**
	 * 
	 * @param input
	 * @return
	 * @throws InvalidQuotesException
	 */
	public ArrayList<String> searchTimeAndDate(String input) throws InvalidQuotesException{
		//DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		return _datr.searchTimeAndDate(input);
	}
	
	/**
	 * Takes in a string and formats date and time to TaskPad standards .
	 * It changes words to numbers as well
	 * dd/MM/yyyy and HH:mm
	 * @param input
	 * @return
	 * @throws InvalidQuotesException
	 */
	public String convertDateAndTimeString(String input) throws InvalidQuotesException{
		return _datr.convertStandardDateAndTime(input);
	}
	
	/**
	 * compare the input date with startTime and now
	 * @param now
	 * @param startEarliest
	 * @param dateLatest
	 * @return Date: null if smaller or equal, original date if bigger
	 */
	public String checkDateAndTimeWithStart(String startEarliest,
			String dateLatest) {
		return _datr.checkDateAndTimeWithStart(startEarliest, dateLatest);
	}
	
	/**
	 * Takes in a string and changes number words to numbers
	 * i.e. "one day in forever" changes to "1 day in forever"
	 * @param input
	 * @return string changed to numerics
	 * @throws InvalidQuotesException 
	 */
	public String parseNumberString(String input) throws InvalidQuotesException{
		assert (input != null);
		input = _datr.getAlphaNumericSpaceDesc(input);
		input = _datr.removeParseFreeZone(input);
		input = _datr.parseNumber(input);
		input = _datr.parseDate(input);
		input = _datr.parseTime(input);
		return input.replaceAll(STRING_QUOTE, STRING_EMPTY).trim();
	}	
	
	/**
	 * 
	 * @param firstDateString
	 * @param secondDateString
	 * @return
	 */
	public int compareDateAndTime(String firstDateString, String secondDateString){
		//DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		return _datr.compareDateAndTimeExecutor(firstDateString, secondDateString);
	}
	
	/**
	 * 
	 * @param dateString
	 * @return
	 */
	public int compareDateAndTime(String dateString){
		return compareDateAndTime(dateString, getTodayDate() + " 23:59");
	}

	/**
	 * methods that parses only holiday
	 * @param holidayString
	 * @return
	 */
	public String parseHolidayString(String holidayString){
		return _datr.parseOnlyHoliday(holidayString);
	}	
	
	/**
	 * only can parse normal time, such as 1am, 11:00 ......
	 * but can parse next hour, 1 hour later......
	 * @param timeString
	 * @return
	 * @throws TimeErrorException
	 * @throws InvalidTimeException
	 */
	public String parseTimeInput(String timeString) throws TimeErrorException, InvalidTimeException {
		return _datr.parseOnlyTimeInput(timeString);
	}
	
	/**
	 * parses only time word + special words
	 * @param input
	 * @return
	 * @throws NullTimeUnitException
	 * @throws NullTimeValueException
	 */
	public String parseTimeWord(String input) throws NullTimeUnitException, NullTimeValueException{
		return _datr.parseOnlyTimeWord(input);
	}
	
	/**
	 * convertToSecond: convert time from any unit to second
	 * 
	 * @param timeString
	 *            : time value + time unit, ex: 1 min, one min, 1s
	 * @return: String
	 * @throws NullTimeUnitException
	 *             : User did not key in time unit
	 * @throws NullTimeValueException
	 *             : User did not key in time value / not valid time value
	 */
	public String convertToSecond(String timeString)
			throws NullTimeUnitException, NullTimeValueException {
		return _datr.convertToSecond(timeString);
		/*
		TimeWordParser twp = TimeWordParser.getInstance();
		return twp.parseTimeWord(timeString);
		*/
	}
	
	/**
	 * To parse day to date
	 * @throws DatePassedException 
	 * @throws InvalidDayException 
	 */
	public String parseDayToDate(String input) throws InvalidDayException{
		return _datr.parseOnlyDayToDate(input);
		/*
		DayParser dayParser = DayParser.getInstance();
		return dayParser.parseDayToDate(input);
		*/
	}
	
	/**
	 * parseDate: parse different formats of Date
	 * 
	 * @return timeString, in dd/mm/yyyy 
	 * @throws InvalidDateException 
	 */
	public String parseDate(String dateString) throws InvalidDateException{
		return _datr.parseOnlyDate(dateString);
		/*
		DateParser dateParser = DateParser.getInstance();
		return dateParser.parseDate(dateString);
		*/
	}
	
	/**
	 * format: dd/MM/yyyy HH:mm
	 * @param dateString
	 * @throws ParseException
	 */
	public void setDebug(String dateString) throws ParseException{
		_datr.setDebug(dateString);
		//_dateAndTimeObject.setDebugDate(dateString);
	}
	
	/**
	 * =================================BELOW ARE ALL DEPRECATED=================================================
	 */
	

	/**
	 * Check if there  is a valid date in the string
	 * @deprecated
	 * @param String
	 * @returns DateObject
	 */
	public DateObject findDate(String input){
		return _datr.findDate(input);
	}
	
	/**
	 * Check if there is a valid time in the string
	 * @deprecated
	 * @param String
	 * @returns TimeObject
	 */
	public TimeObject findTime(String input){
		//DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		return _datr.findTime(input);
	}
	
	/**
	 * parseNumber: parse a language number to a real number String, ex: one to
	 * 1. It returns null when error occurs.
	 * 
	 * @deprecated
	 * 
	 * @param numberString
	 *            : language number or normal number
	 * @return String
	 */
	public String parseNumber(String numberString) {
		return parseNumber(numberString, true);
	}
	
	/**
	 * can only parse one to 1
	 * @deprecated
	 * @param numberString
	 * @param isStrict
	 * @return
	 */
	public String parseNumber(String numberString, boolean isStrict) {
		NumberParser parser = NumberParser.getInstance();
		return parser.parseTheNumbers(numberString, isStrict);
	}
	
	
	/**
	 * @deprecated
	 * @param numberString
	 * @return
	 */
	protected boolean isNumber(String numberString) {
		NumberParser parser = NumberParser.getInstance();
		return parser.parseTheNumbers(numberString, true) != null;
	}
	
	/**
	 * @deprecated
	 * parse a day (such as Monday to int)
	 * @param dayString
	 * @return int
	 * @throws InvalidDayException
	 */
	public int parseDayToInt(String dayString) throws InvalidDayException{
		DayParser dayParser = DayParser.getInstance();
		return dayParser.parseDayToInt(dayString);
	}

	/**
	 * @deprecated
	 * @param timeString
	 * @return
	 */
	protected boolean isSecondInstance(String timeString) {
		TimeWordParser twp = TimeWordParser.getInstance();

		try {
			twp.parseTimeWord(timeString);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			GuiManager.callOutput(e.getMessage());
			return false;
		}

		return true;
	}
	
	/**
	 * @deprecated
	 * @param dayString
	 * @return
	 */
	protected boolean isDay(String dayString){
		DayParser dayParser = DayParser.getInstance();
		try {
			dayParser.parseDayToInt(dayString);
		} catch (InvalidDayException e) {
			//GuiManager.callOutput(e.getMessage());
			return false;
		}
		return true;
	}
	
	/**
	 * parseTime: parse different format of time
	 * @deprecated
	 * @param timeString
	 * @return String
	 * @throws TimeErrorException
	 * @throws InvalidTimeException 
	 */
	public String parseTime(String timeString) throws TimeErrorException, InvalidTimeException {
		TimeParser tp = TimeParser.getInstance();
		return tp.parseTime(timeString);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateAndTimeManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateObject.java
	 */


package com.taskpad.dateandtime;

/**
 * Date object to contain parsed date and the input date format
 * @deprecated
 */
public class DateObject {
	
	private String parsedDate;
	private String inputDate;
	
	public DateObject(String parsedDate, String inputDate){
		this.parsedDate = parsedDate;
		this.inputDate = inputDate;
	}

	public String getParsedDate() {
		return parsedDate;
	}

	public String getInputDate() {
		return inputDate;
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateObject.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateParser.java
	 */


package com.taskpad.dateandtime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/** This class takes in a date and checks if it fits any of the SimpleDateFormat
 * Returns null string if otherwise
 * 
 */

public class DateParser {

	//private static final String STRING_EMPTY = "";
	//private static final String DATE_INVALID = "Not a valid date";
	private static SimpleDateFormat _formatter = new SimpleDateFormat("dd/MM/yyyy");
	private static DateParser _dateParser = new DateParser();
	
	private static final String[] _dateWithoutYear = {
		"d MMMM", "MMMM d", "dMMMM", "MMMMd",
		"d/MMMM", "d-MMMM",
		"d MMM", "MMM d", "dMMM", "MMMd",
		"d/MMM", "d-MMM",
		"d/MM", "d-MM",  //"d.MM", //"d MM",
		"d/M", "d-M",  //"d.M", //"d M",
		
		"dd MMMM", "MMMM dd", "ddMMMM", "MMMMdd",
		"dd/MMMM", "dd-MMMM",
		"MMM dd", "dd MMM", "ddMMM", "MMMdd",
		"dd/MMM", "dd-MMM",
		"dd/M", "dd-M", //"dd.M", //"dd M", 
		"dd/MM", "dd-MM", //"dd.MM", //"dd MM", 
	};
	
	private static final String[] _dateFormats = {
		"d/MM/yy", "d-MM-yy", "d.MM.yy", //"d MM yy", 
		"d/M/yy", "d-M-yy", "d.M.yy", //"d M yy",
		"MMMM d , yy", "MMMM d, yy", "MMMM d,yy",  
		"d MMMM yy", "d MMMM , yy", "d MMMM, yy", "d MMMM,yy", 
		"d-MMMM-yy", "dMMMMyy",
		"MMM d , yy", "MMM d, yy", "MMM d,yy",  
		"d MMM yy", "d MMM , yy", "d MMM, yy", "d MMM,yy", 
		"d-MMM-yy", "d MM , yy", "d MM, yy", "d MM,yy", 
		"d M , yy", "d M, yy", "d M,yy", "dMMMyy", 
		
		"dd/MM/yy", "dd-MM-yy", "dd.MM.yy", //"dd MM yy", 
		"dd/M/yy", "dd-M-yy", "dd.M.yy", //"dd M yy",
		"MMMM dd , yy", "MMMM dd, yy", "MMMM dd,yy",  
		"dd MMMM yy", "dd MMMM , yy", "dd MMMM, yy", "dd MMMM,yy", 
		"dd-MMMM-yy", "ddMMMMyy",
		"MMM dd , yy", "MMM dd, yy", "MMM dd,yy",  
		"dd MMM yy", "dd MMM , yy", "dd MMM, yy", "dd MMM,yy", 
		"dd-MMM-yy", "dd MM , yy", "dd MM, yy", "dd MM,yy", 
		"dd M , yy", "dd M, yy", "dd M,yy", "ddMMMyy", 
		
		/*
		 * deprecated - we will only support d-m-y  
		"yy/dd/MM", "yy-dd-MM", 
		"yy.dd.MM", "yy dd MM", "yy-dd-MMM",  "yy/dd/MMM",
		"yy/d/M", "yy-d-M", "yy.d.M", "yy d M", 
		, "MMddyy", "yyMMMdd", "ddMMyy", 
		"MMMM d yy", "MMM d yy", "MMMM dd yy", "MMM dd yy", 
		*/
		//"MMMddyy",
		
		"d/MM/yyyy", "d-MM-yyyy", "d.MM.yyyy", //"d MM yyyy", 
		"d/M/yyyy", "d-M-yyyy", "d.M.yyyy", //"d M yyyy",
		"MMMM d , yyyy", "MMMM d, yyyy", "MMMM d,yyyy",  
		"d MMMM yyyy", "d MMMM , yyyy", "d MMMM, yyyy", "d MMMM,yyyy", 
		"d-MMMM-yyyy", "dMMMMyyyy",
		"MMM d , yyyy", "MMM d, yyyy", "MMM d,yyyy",  
		"d MMM yyyy", "d MMM , yyyy", "d MMM, yyyy", "d MMM,yyyy", 
		"d-MMM-yyyy", "d MM , yyyy", "d MM, yyyy", "d MM,yyyy", 
		"d M , yyyy", "d M, yyyy", "d M,yyyy", "dMMMyyyy", 
		
		"dd/MM/yyyy", "dd-MM-yyyy", "dd.MM.yyyy", //"dd MM yyyy", 
		"dd/M/yyyy", "dd-M-yyyy", "dd.M.yyyy", //"dd M yyyy",
		"MMMM dd , yyyy", "MMMM dd, yyyy", "MMMM dd,yyyy",  
		"dd MMMM yyyy", "dd MMMM , yyyy", "dd MMMM, yyyy", "dd MMMM,yyyy", 
		"dd-MMMM-yyyy", "ddMMMMyyyy",
		"MMM dd , yyyy", "MMM dd, yyyy", "MMM dd,yyyy",  
		"dd MMM yyyy", "dd MMM , yyyy", "dd MMM, yyyy", "dd MMM,yyyy", 
		"dd-MMM-yyyy", "dd MM , yyyy", "dd MM, yyyy", "dd MM,yyyy", 
		"dd M , yyyy", "dd M, yyyy", "dd M,yyyy", "ddMMMyyyy"
		
		/*
		 * Deprecated for the reason above
		//"yyyy/dd/MM", "yyyy-dd-MM", "yyyy.dd.MM", "yyyy dd MM", 
		//"yyyy dd MMM", "yy dd MMM", "yyyy,dd MMM", "yyyy-dd-MMM", "yyyy/dd/MMM",
		//"yyyy/d/M", "yyyy-d-M", "yyyy.d.M", "yyyy d M", 
		 //"MMddyyyy", "yyyyMMMdd", "ddMMyyyy", 
		//"MMMddyyyy",
		"yyyy/d/M", "yyyy-d-M", "yyyy.d.M", "yyyy d M", 
		 "MMddyyyy", "yyyyMMMdd" "MMM d yyyy""MMM dd yyyy", 
		 */
	};
	
	/*
	private static final String[] MONTHS = {
		
	};
	
	private static HashMap _monthMap = new HashMap();
	*/
	
	private DateParser(){
	}
	
	protected static DateParser getInstance(){
		return _dateParser;
	}
	
	protected String parseDate(String input) throws InvalidDateException{
		if (input == null){
			throw new InvalidDateException();
		}
		
		input = input.trim();
		
		String dateString = getActualDate(input);
		
		if (dateString == null){
			throw new InvalidDateException();
		} 
		
		return dateString;
	}

	
	/**
	 * getActualDate: as formatDateWithoutYear() might parses
	 * a String with "dd mm yy" also, so, we have to consider cases:
	 * if we can parse it without year, but not with year, then is without year ; 
	 * if we can parse it without year and also with year, then is with year;
	 * if we can parse it with year only, then of course is with year;
	 * then if both also can't parse, then is null.
	 * @param input
	 * 				: String
	 * @return String
	 * @throws InvalidDateException 
	 */
	private String getActualDate(String input){
		String dateStringWithoutYear = null;
		String dateString = null;
		
		input = input.toUpperCase();
		
		dateStringWithoutYear = formatDateWithoutYear(input);
		dateString = formatDate(input);

		if (dateString == null || dateString.trim().isEmpty()){
			dateString = dateStringWithoutYear;
		}
		return dateString;
	}
	
	private static String formatDateWithoutYear(String input){
		assert (input != null);
		
		String dateString = null;
		for (String dwy: _dateWithoutYear){
			
			SimpleDateFormat sdf = new SimpleDateFormat(dwy);
			try {
				//System.out.println(_dateFormats[i]);
				
				//to strictly follow the format
				sdf.setLenient(false);
				
				Date date = sdf.parse(input);
				
				
				boolean isWrongFormat = !input.equals(sdf.format(date).toUpperCase());
				if (isWrongFormat){
					continue;
				}
				
				date = setYear(date);
				
				/*
				if (isPassed(date) ){
					throw new DatePassedException();
				}
				*/
				
				dateString = _formatter.format(date);
				break;
			} catch (ParseException e){
				//do nothing
			}
		}
		return dateString;
	}
	
	private static Date setYear(Date date) {
		Calendar calendar = Calendar.getInstance();
		int year = calendar.get(Calendar.YEAR);
		calendar.setTime(date);
		calendar.set(Calendar.YEAR, year);
		date = calendar.getTime();
		
		return date;
	}

	private static String formatDate(String input){
		assert (input != null);
		
		String dateString = null;
		for (String df : _dateFormats){
			
			SimpleDateFormat sdf = new SimpleDateFormat(df);
			try {
				//System.out.println(_dateFormats[i]);
				
				//to strictly follow the format
				sdf.setLenient(false);
				
				Date date = sdf.parse(input);
				
				
				boolean isWrongFormat = !input.equals(sdf.format(date).toUpperCase());
				if (isWrongFormat){
					continue;
				}
				/*
				if (isPassed(date) ){
					throw new DatePassedException();
				}
				*/
				
				dateString = _formatter.format(date);
				break;
			} catch (ParseException e){
				//do nothing
			}
		}
		return dateString;
	}
	
	/**
	 * should not be true because even if 
	 * the date has passed it can be
	 * startDate also
	 * @deprecated
	 * @param date
	 * @return
	 */
	@SuppressWarnings("unused")
	private static boolean isPassed(Date date) {
		/*
		Date now = new Date();
		return now.compareTo(date) > 0;
		*/
		
		return false;
	}
	
	///* Testing
	public static void main (String[] args){
		//System.out.println(formatDate("13-12-14"));
		//System.out.println(formatDate("13 12 2014"));
		//System.out.println(formatDate("1 Feb 14"));
		//System.out.println(formatDate("2014 1 December"));
		//System.out.println(formatDate("1December2014"));
		//System.out.println(formatDate("011214"));
		//System.out.println(formatDateWithoutYear("03 01"));  //Will use system year at 1970
		//System.out.println(formatDate("Oct 18,93"));
		try {
			System.out.println(DateParser.getInstance().parseDate("18Oct"));
		} catch (InvalidDateException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//*/
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DateParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DatePassedException.java
	 */


package com.taskpad.dateandtime;

public class DatePassedException extends Exception {

	/**
	 * generated
	 */
	private static final long serialVersionUID = 7516238062049393549L;

	private static final String MESSAGE = "Date has passed. Please enter a date in the future";
		
	public DatePassedException(){
		super(MESSAGE);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\DatePassedException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\HolidayDatesParser.java
	 */


package com.taskpad.dateandtime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/** For special holiday dates
 * 
 */

public class HolidayDatesParser {
	
	private static Map<String, String> _holidays = new HashMap<String, String>();
	private static HolidayDatesParser _holidayDate = new HolidayDatesParser();
	
	//private static final String STRING_NULL = "";
	
	private HolidayDatesParser(){
		initialiseHolidayMap();
	}
	
	protected static HolidayDatesParser getInstance(){
		return _holidayDate;
	}
	
	/**
	 * This method takes an input String, finds if there is holiday dates
	 * @param input
	 * @return String with holidayDates replaced, else returns input
	 */
	
	protected String replaceHolidayDate(String input){	
		if (input == null){
			return null;
		}
		String holidayDate = _holidays.get(input.toUpperCase());
		if (holidayDate != null){
			holidayDate = parseHolidayDate(holidayDate);
		} else {
			holidayDate = null;
		}
		return holidayDate;
	}

	/** This method parses the date in the correct year
	 * 
	 * @param holidayDate
	 * @return String, dd/mm/yyyy
	 */
	private String parseHolidayDate(String holidayDate){
		holidayDate = addYear(holidayDate);
		
		/*
		SimpleDateFormat sdf = new SimpleDateFormat("dd/mm/yyyy");
		Date date = null;
		try {
			date = sdf.parse(holidayDate);
			
		} catch (ParseException e) {
			//do nothing
		}
		return sdf.format(date);
		*.
		*/
		
		return holidayDate;
	}
	
	private String addYear(String date) {
		int year = getThisYear();
		
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date holidayDate = null;
		try {
			holidayDate = sdf.parse(date + "/" + year);
			
		} catch (ParseException e) {
			//do nothing
		}
		
		Date now = new Date();
		if (now.compareTo(holidayDate) > 0){
			year++;
		}
		
		//System.out.println(now.toString() + "\n" + holidayDate.toString());
		
		return date + "/" + year;
	}

	/**
	 * @return
	 */
	private int getThisYear() {
		DateAndTimeRetriever datr = DateAndTimeRetriever.getInstance();
		String today = datr.getTodayDate();
		String yearString = today.split("/")[2];
		return Integer.parseInt(yearString);
		//return Calendar.getInstance().get(Calendar.YEAR);
	}
	
	private static void initialiseHolidayMap(){
		_holidays.put("CHRISTMAS", "25/12");
		_holidays.put("APRIL FOOLS", "01/04");
		_holidays.put("APRIL FOOL", "01/04");
		_holidays.put("APRIL FOOLS DAY", "01/04");
		_holidays.put("APRIL FOOL DAY", "01/04");
		_holidays.put("INDEPDENCE DAY", "04/07");
		_holidays.put("LABOUR DAY", "01/05");
		_holidays.put("LABOR DAY", "01/05");
		_holidays.put("NATIONAL DAY", "09/08");
		_holidays.put("NEW YEAR", "01/01");
		_holidays.put("NEW YEAR DAY", "01/01");
	}
	
	/* Testing
	public static void main(String[] args){
		String input = "LABOUR DAY";
		HolidayDatesParser holidayDates = HolidayDatesParser.getInstance();
		System.out.println(holidayDates.replaceHolidayDate(input));
		System.out.println(holidayDates.replaceHolidayDate("RANDOM"));

	}
	//*/
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\HolidayDatesParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidDateException.java
	 */


package com.taskpad.dateandtime;


/**
 * InvalidDateException thrown while it is not a valid date format
 */

public class InvalidDateException extends Exception{

	/**
	 * generated
	 */
	private static final long serialVersionUID = 8886449578429827179L;
	
	private static final String MESSAGE = "Error: Invalid Date Entered";
	
	public InvalidDateException(){
		super(MESSAGE);
	}
	
	public InvalidDateException(String Message){
		super (MESSAGE + ": " + Message);
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidDateException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidTimeException.java
	 */


package com.taskpad.dateandtime;

/**
 * InvalidTimeException when user keys in AM string >12 or PM string > 25 or minutes >60
 *
 */

public class InvalidTimeException extends Exception {

	/**
	 * generated
	 */
	private static final long serialVersionUID = -1003877340664378926L;
	
	private static final String MESSAGE = "Error: Invalid time entered";
	
	public InvalidTimeException(){
		super(MESSAGE);
	}
	
	public InvalidTimeException(String message){
		super(MESSAGE + ": " + message);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\InvalidTimeException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NullTimeValueException.java
	 */


package com.taskpad.dateandtime;

import java.util.logging.Logger;

/**
 * 
 * NullTimeValueException: an exception thrown
 * when user did not key in a time value
 */

public class NullTimeValueException extends Exception{
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = 1045316937520580318L;
	
	private static final String MESSAGE = "Error: Please enter a time value";
	
	protected static Logger _logger = Logger.getLogger("TaskPad");


	public NullTimeValueException(){
		super (MESSAGE);
	}
	
	public NullTimeValueException(String Message){
		super (MESSAGE);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\NullTimeValueException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeErrorException.java
	 */


package com.taskpad.dateandtime;

public class TimeErrorException extends Exception {
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = -8922390543512908633L;

	private static final String MESSAGE = "Error: Invalid Time supplied";
		
	public TimeErrorException(){
		super(MESSAGE);
		
	}
	
	public TimeErrorException(String input){
		super(MESSAGE + ": " + input);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeErrorException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeObject.java
	 */


package com.taskpad.dateandtime;

/**
 * @deprecated
 *
 */
public class TimeObject {

	private String parsedTime;
	private String inputTime;
	
	public TimeObject(String parsedTime, String inputTime){
		this.parsedTime = parsedTime;
		this.inputTime = inputTime;
	}

	public String getParsedTime() {
		return parsedTime;
	}

	public String getInputTime() {
		return inputTime;
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeObject.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeParser.java
	 */


/**
 * This class is for FlexiCommands for time
 */

package com.taskpad.dateandtime;

import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TimeParser {
	
	private static final String FULL_PM = "PM";

	private static final String FULL_AM = "AM";

	private final static Logger LOGGER = Logger.getLogger("TaskPad");

	private static final String TIME_TWELVE = "12";
	private static final String TIME_EVE = "17";
	private static final String TIME_NIGHT = "19";
	private static final int TIME_NEG = -1;
	private static final String TIME_DEF = "-1";
	private static final String TIME_ZERO = "0";
	private static final String TIME_AM = "a";
	private static final String TIME_PM = "p";
	
	private static final String COLON = ":";
	private static final String SEMICOLON = ";";
	private static final String DOT = ".";
	private static final String EMPTY = "";

	private static TimeParser _timeParser = new TimeParser();
	
	private TimeParser(){
	}
	
	protected static TimeParser getInstance(){
		return _timeParser;
	}
	
	/**
	 * parses input to time format:
	 * it supports 1pm -> 13:00 like parseTimeInput
	 * and also 1 hour.
	 * But we are going to use DateAndTimeRetriever to do this
	 * @deprecated
	 * @param input
	 * @return
	 * @throws TimeErrorException
	 * @throws InvalidTimeException
	 */
	protected String parseTime(String input) throws TimeErrorException, InvalidTimeException{
		TimeWordParser twp = TimeWordParser.getInstance();
		
		String timeString = EMPTY;
		
		input = input.trim();
		
		LOGGER.info(input);
		try {
			timeString = twp.parseTimeWordWithSpecialWord(input);
		} catch (NullTimeUnitException | NullTimeValueException e) {
			LOGGER.warning(e.getMessage());
			timeString = parseTimeInput(input);
		}

		if (input.isEmpty()){
			throw new InvalidTimeException();
		}
		
		return timeString;
	}
	
	/**
	 * parses time like 1pm to standard format 13:00
	 * @param input
	 * @return
	 * @throws TimeErrorException
	 * @throws InvalidTimeException
	 */
	protected String parseTimeInput(String input) throws TimeErrorException, InvalidTimeException{
		String timeString = EMPTY;
		long time = 0;
		
		LOGGER.info("input is passed into parseTimeInput() :" + input);
		if (input == null){
			LOGGER.info(input + " is null!");
			throw new InvalidTimeException();
		}
		
		//to solve 8 am case
		input = input.replaceAll(" ", "");
		
		if (isDouble(input)){
			LOGGER.info(input + " is double!");
			throw new InvalidTimeException(input);
		}		
		
		//to solve 8 AM case
		input = input.toLowerCase();
		
		if(isNotEmptyString(input)){
			time = decodeTime(input);
			timeString = convertMillisecondsToTime(time);
		} else {
			throw new InvalidTimeException();
		}

		if (isInvalidTime(timeString)){
			throw new TimeErrorException(input);
		}
		
		return timeString;
	}
	
	private boolean isDouble(String input){
		try {
			Double.parseDouble(input);
		} catch (NumberFormatException e){
			return false;
		}
		return true;
	}
	
	private boolean isNotEmptyString(String timeString) {
		return !timeString.trim().isEmpty();
	}

	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	@SuppressWarnings("unused")
	private boolean inputContainsTimeWords(String input) {
		if (input.equals(EMPTY)){
			return true;
		}
		return false;
	}

	private long decodeTime(String input) throws InvalidTimeException{	    
		input = input.trim();
        String hours = TIME_DEF, minutes = TIME_DEF;
        
        long time = TIME_NEG;
        
        time = checkMornAftEvenWords(input);
        
        if (time != TIME_NEG){
        	return time;
        }
        	    
	    if (timePatternMatch(input)) {
	    	LOGGER.info(input + " matched timePattern");
	    	
	        if (input.contains(COLON) || input.contains(DOT) || input.contains(SEMICOLON)) {
		    	LOGGER.info(input + " has time punctuation");

	            String[] inputs = input.split("[:.;]");
	            hours =  inputs[0];
	            minutes = inputs[1].substring(0, 2);
	            
	            LOGGER.info("hours: " + hours);
            	LOGGER.info("minutes: " + minutes);
	        } else {
	            // Process strings like "8", "8p", "8pm", "2300"
	            if (input.contains(TIME_AM)) {
	            	LOGGER.info(input + " matched timePattern and contains AM! time:" + time);
	            	
	                hours = input.substring(0, input.indexOf(TIME_AM)).trim();	//am strings
	                minutes = TIME_ZERO;
	                
	            	LOGGER.info("hours: " + hours);
	            	LOGGER.info("minutes: " + minutes);
	                
	                checkIfInvalidTimeString(hours, minutes, input);

	            } else if (input.contains(TIME_PM)) {
	            	LOGGER.info(input + " matched timePattern and contains PM! time:" + time);
	            	
	                hours = input.substring(0, input.indexOf(TIME_PM)).trim();	//pm strings
	                minutes = TIME_ZERO;
	                
	                LOGGER.info("hours: " + hours);
	            	LOGGER.info("minutes: " + minutes);
	                
	                checkIfInvalidTimeString(hours, minutes, input);

	            } /* else if (input.length() < 3) { SUPPORTED By Checking is double value
	            	/* Deprecated - not supportting single date values
	                hours = input;
	                minutes = TIME_ZERO;

	            	throw new InvalidTimeException(input);
	                
	            }*//* else { UNREACHABLE??
	            	LOGGER.info(input + " matched timePattern but no contains AM or PM! time:" + time);
	            	
	                hours =  input.substring(0, input.length() - 2);
	                minutes = input.substring(input.length() - 2);
	                
	                LOGGER.info("hours: " + hours);
	            	LOGGER.info("minutes: " + minutes);
	            }*/
	        }
	        	        
	        if (input.contains(TIME_AM) && hours.equals(TIME_TWELVE)) {
	        	LOGGER.info(input + " contains 12. Time:" + time);
	            hours = TIME_ZERO;
	            //minutes = TIME_ZERO;
	        }

	        time = convertToSeconds(hours, minutes);
	        LOGGER.info("Matched timePattern. time: " + time);

	        if (input.contains(TIME_PM) && !hours.equals(TIME_TWELVE)) {
	            time = addPM(time);
	            
	            LOGGER.info(input + " has pm but not 12pm. Time:" + time);
	        }

	        return time;
	    } else {
	    	LOGGER.info(input + " not matched timePattern");
	    	
	    	//To take care of strings like 800am
            if (input.contains(TIME_AM)) {
            	LOGGER.info(input + " not matched timePattern and contains AM! time:" + time);

                hours = input.substring(0, input.indexOf(TIME_AM)).trim();	//am strings
                LOGGER.info("hours: " + hours);
                
                String tempInput = input.replaceFirst(hours, EMPTY);
                LOGGER.info("tempInput: " + tempInput);
                
                if (tempInput.length() > 1){
                	if (!FULL_AM.equalsIgnoreCase(tempInput)){
                		throw new InvalidTimeException(input);
                	}
                }
                
                if (hours.length() == 4){ 
                	minutes = hours.substring(2, 4);
                	hours = hours.substring(0, 2);
                } else if (hours.length() == 3) {
                	minutes = hours.substring(1, 3);
                	hours = hours.substring(0, 1);
                } else {
                	throw new InvalidTimeException(input);
                }
                
                LOGGER.info("hours: " + hours);
            	LOGGER.info("minutes: " + minutes);
                
                checkIfInvalidTimeString(hours, minutes, input);

            } else if (input.contains(TIME_PM)) {
            	LOGGER.info(input + " not matched timePattern and contains PM! time:" + time);
            	
                hours = input.substring(0, input.indexOf(TIME_PM)).trim();	//pm strings
                LOGGER.info("hours: " + hours);
                
                String tempInput = input.replaceFirst(hours, EMPTY);
                LOGGER.info("tempInput: " + tempInput);
                
                if (tempInput.length() > 1){
                	if (!FULL_PM.equalsIgnoreCase(tempInput)){
                		throw new InvalidTimeException(input);
                	}
                }
                
                if (hours.length() == 4){ 
                	minutes = hours.substring(2, 4);
                	hours = hours.substring(0, 2);
                } else if (hours.length() == 3) {
                	minutes = hours.substring(1, 3);		
                	hours = hours.substring(0, 1);
                } else {
                	throw new InvalidTimeException(input);
                }

                LOGGER.info("hours: " + hours);
            	LOGGER.info("minutes: " + minutes);
                
                checkIfInvalidTimeString(hours, minutes, input);
            }
            
            if (input.contains(TIME_AM) && hours.equals(TIME_TWELVE)) {
	        	LOGGER.info(input + " contains 12. Time:" + time);
	            hours = TIME_ZERO;
	            //minutes = TIME_ZERO;
	        }
            
	        time = convertToSeconds(hours, minutes);
	        LOGGER.info("Not matched timePattern. time: " + time);
	        
	        if (input.contains(TIME_PM) && !hours.equals(TIME_TWELVE)) {
	            time = addPM(time);
	            LOGGER.info(input + " has pm but not 12pm. Time:" + time);
	        }
	        
	        return time;
	    }
	 }
	
	/**
	 * check whether timeString is valid:
	 * hour and minute can only be non-negative and cannot exceed their range
	 * @param hours
	 * @param minutes
	 * @param input
	 * @throws InvalidTimeException
	 */
	private void checkIfInvalidTimeString(String hours, String minutes, String input) throws InvalidTimeException {
		LOGGER.info("check whether " + input + " is invalid");
		LOGGER.info("hours: " + hours);
    	LOGGER.info("minutes: " + minutes);
		
    	if (!isDouble(hours) || !isDouble(minutes)){
    		LOGGER.severe("NOT NUMBER!");
        	throw new InvalidTimeException(input);
    	}
    	
        int h = Integer.parseInt(hours);
        int m = Integer.parseInt(minutes);
		if (h > 12 || m > 60){
			LOGGER.severe("h > 12 || m > 60");
			LOGGER.severe("h: " + h);
			LOGGER.severe("m: " + m);
        	throw new InvalidTimeException(input);
        } else if (h <= 0 || m < 0){
			LOGGER.severe("h <= 0 || m < 0");
        	LOGGER.severe("h: " + h);
			LOGGER.severe("m: " + m);
        	throw new InvalidTimeException(input);
        }
	}

	private boolean timePatternMatch(String input) {
		return time12Matches(input) || time24Matches(input);
	}
	
	private boolean time12Matches(String input){
		Pattern time12 = Pattern.compile("^(1[012]|[1-9])([;:.][0-5][0-9])?(a|p|am|pm)?$");
	    Matcher time12M = time12.matcher(input);
	    boolean time12Match = time12M.matches();
	    
		return time12Match;
	}
	
	private boolean time24Matches(String input){
	    Pattern time24 = Pattern.compile("^(([01]?[0-9]|2[0-3])[;:.]?([0-5][0-9])?)$");
	    Matcher time24M = time24.matcher(input);
	    boolean time24Match = time24M.matches();
	    
	    return time24Match;
	}

	private long addPM(long time) {
		time += 12 * 60 * 60 * 1000;
		return time;
	}
	
	private long checkMornAftEvenWords(String input) {
		long time = TIME_NEG;
		String hours = TIME_ZERO;
		String minutes = TIME_ZERO;
		
        if (containsMornWords(input)){
        	hours = TIME_ZERO;
        	minutes = TIME_ZERO;
        } else if (containsAftWords(input)){
        	hours = TIME_TWELVE;
        	minutes = TIME_ZERO;
        } else if (containsEveWords(input)){
        	hours = TIME_EVE;
        	minutes = TIME_ZERO;
        } else if (containsNightWords(input)){
        	hours = TIME_NIGHT;
        	minutes = TIME_ZERO;
        } else if (containsMidnightWords(input)){
        	hours = TIME_ZERO;
        	minutes = TIME_ZERO;
        } else {
        	return time;
        }
        
        //System.err.println(hours + " " + minutes);
        
    	time = convertToSeconds(hours, minutes);
		return time;
	}

	private boolean containsNightWords(String input) {
		return input.toLowerCase().equals("night") || input.toLowerCase().equals("ngt");
	}

	private boolean containsEveWords(String input) {
		return input.toLowerCase().equals("evening") || input.toLowerCase().equals("eve");
	}

	private boolean containsAftWords(String input) {
		return input.toLowerCase().equals("afternoon") || input.toLowerCase().equals("aft") ||
        		input.toLowerCase().equals("noon");
	}

	private boolean containsMornWords(String input) {
		return input.toLowerCase().equals("morning") || input.toLowerCase().equals("morn");
	}

	
	private boolean containsMidnightWords(String input) {
		return input.toLowerCase().equals("midnight") || input.toLowerCase().equals("midngt");
	}
	
	private long convertToSeconds(String hours, String minutes){
		return (Long.parseLong(hours) * 60 + Long.parseLong(minutes)) * 60 * 1000;
	}
	
	private String convertMillisecondsToTime(long milliseconds){
		int minutes = (int) ((milliseconds / (1000*60)) % 60);
		int hours   = (int) ((milliseconds / (1000*60*60)) % 24);
		
		LOGGER.info("milliseconds : " + milliseconds);
		LOGGER.info("minutes : " + minutes);
		LOGGER.info("hours : " + hours);
		
		String hourString = "" + hours;
		if (hourString.length() == 1){
			hourString = TIME_ZERO + hourString;
		}
		
		String minuteString = EMPTY + minutes;
		if (minuteString.length() == 1){
			minuteString = TIME_ZERO + minuteString;
		}
		String timeString = hourString + COLON + minuteString;
		
		LOGGER.info("hourString : " + hourString);
		LOGGER.info("minuteString : " + minuteString);
		LOGGER.info("timeString : " + timeString);
		
		return timeString;
	}
	
	private boolean isInvalidTime(String timeString){
		if (timeString.trim().equals("-1:-1")){
			return true;
		}
		return false;
	}
	
	public static void main(String[] args){
		String input = "12pm";
		
		//System.out.println(checkMornAftEvenWords(input));
		TimeParser tp = TimeParser.getInstance();
		String time = null;
		try {
			time = tp.parseTime(input);
		} catch (InvalidTimeException | TimeErrorException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		//String timeString = convertMillisecondsToTime(time);
		System.out.println(input + " " + time);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\dateandtime\TimeParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorManager.java
	 */

	/**
	 * For integration/ system tests
	 * Creates an artificial database 
	 * @param ArrayList<Input>
	 */
	public void setDebug(){
		CommandFactory.clear();
		createDatabase();
	}
	
	/**
	 * Takes in an arrayList of Input objects and arrayList of full Input 
	 * Add them to database
	 */
	private static void createDatabase(){
		ArrayList<Input> inputObjects = new ArrayList<Input>();
		ArrayList<String> fullInputList = new ArrayList<String>();
		
		/**
		 * Create your inputObjects here 
		 */
		
		addObjectsToDatabase(inputObjects, fullInputList);
	}


	private static void addObjectsToDatabase(ArrayList<Input> inputObjects, 
			ArrayList<String> fullInputList) {
		for (int i=0; i<inputObjects.size(); i++){
			receiveFromInput(inputObjects.get(i), fullInputList.get(i));
		}
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Add.java
	 */


package com.taskpad.input;


import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Logger;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidDateException;
import com.taskpad.dateandtime.InvalidQuotesException;
import com.taskpad.execute.InvalidTaskIdException;


/**
 * Add syntax
 * with delimiters:
 * add <desc> -d <deadlinedate>,<deadlinetime> -s <start date>,<start time> -e <end date>,<end time>
 * 
 *
 */

public class Add extends Command {

	private static final String STRING_NULL = "null";
	private static final String STRING_EMPTY = "";
	private static final String STRING_SPACE = " ";
	
	private static final String COMMAND_ADD = "ADD";
	private static final int NUMBER_ARGUMENTS = 1;
	
	private static String PARAMETER_DEADLINE_DATE = "DEADLINE DATE";
	private static String PARAMETER_START_DATE = "START DATE";
	private static String PARAMETER_START_TIME = "START TIME";
	private static String PARAMETER_END_DATE = "END DATE";
	private static String PARAMETER_END_TIME = "END TIME";
	private static String PARAMETER_DESCRIPTION = "DESC";

	private int _startNo;
	private int _deadNo;
	private int _endNo;
	private String _taskID;
	private String _deadline;
	private String _startDate;
	private String _startTime;
	private String _endDate;
	private String _endTime;
	
	private static Scanner _sc; 
	private static boolean _invalidParameters;
	
	private final static Logger LOGGER = Logger.getLogger("TaskPad");
	
	public Add(String input, String fullInput) {
		super(input, fullInput);
		
		_invalidParameters = false;
	}
	
	@Override
	public void run(){
		try {
			checkIfEmptyString();
		} catch (EmptyStringException e) {
			showEmptyString();
			return;
		}
		
		clearInputParameters();
		initialiseParametersToNull();
		
		if (commandSpecificRun()){
			createInputObject();
			passObjectToExecutor();
		}
		_sc.close();
	}

	@Override
	protected void initialiseOthers() {
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		setCOMMAND(COMMAND_ADD);
		_sc = new Scanner(System.in);
		
		_startNo = 0;
		_endNo = 0;
		_deadNo = 0;
		
		_taskID = null;
		_deadline = null;
		_startDate = null;
		_startTime = null;
		_endDate = null;
		_endTime = null;
	}

	@Override
	protected boolean commandSpecificRun() {		
		if (checkIfDelimitedString()){
			//this line is only useful if it is delimited
			String temp = putDescInQuotesFirst(input);
			
			if (!temp.trim().isEmpty()){
				input = temp;
			}
			parseDelimitedString();

		} else {
			parseNonDelimitedString();
		}
		
		try {
			checkIfExistDesc();
		} catch (EmptyDescException e) {
			InputManager.outputToGui(e.getMessage());
		}
		
		if (_invalidParameters){
			return false;
		}
		
		return true;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_DEADLINE_DATE, STRING_EMPTY);
		putOneParameter(PARAMETER_DESCRIPTION, STRING_EMPTY); 
		putOneParameter(PARAMETER_START_DATE, STRING_EMPTY);
		putOneParameter(PARAMETER_END_DATE, STRING_EMPTY);
		putOneParameter(PARAMETER_END_TIME, STRING_EMPTY);
		putOneParameter(PARAMETER_START_TIME, STRING_EMPTY);
	}

	@Override
	protected void putInputParameters() {
		//do nothing
	}
	
	private void checkIfExistDesc() throws EmptyDescException {
		if (inputParameters.get(PARAMETER_DESCRIPTION).trim().isEmpty()
				|| (inputParameters.get(PARAMETER_DESCRIPTION) == null)){
			_invalidParameters = true;
			throw new EmptyDescException();
		}		
	}

	private void parseNonDelimitedString() {
		//"..." deadlinedate deadlintime startdate starttime enddate endtime
		String inputNew = STRING_EMPTY;
		try {
			inputNew = DateAndTimeManager.getInstance().formatDateAndTimeInString(input);
		} catch (InvalidQuotesException e) {
			InputManager.outputToGui(e.getMessage());
			return;
		}
		
		String[] splitInput = inputNew.split(STRING_SPACE);
		int size = splitInput.length - 1;
		
		for (int i = size; i >= size - 5; i--){
			if (STRING_NULL.equals(splitInput[i])){
				splitInput[i] = null;
			}
		}
		
		_endTime = splitInput[size];
		_endDate = splitInput[size - 1];
		_startTime = splitInput[size - 2];
		_startDate = splitInput[size - 3];
		String deadlineDate = splitInput[size - 5];
		String deadlineTime = splitInput[size - 4];
		

		if (deadlineDate != null && deadlineTime != null){
			_deadline = deadlineTime + STRING_SPACE + deadlineDate;
		}
		checkEmptyParametersAndInput();		
		
		String desc = STRING_EMPTY;
		for (int i=0; i < size - 5; i++){
			desc += splitInput[i] + STRING_SPACE;
		}
				
		putOneParameter(PARAMETER_DESCRIPTION, desc);
		
	}

	/**
	 * 
	 * parseDelimitedString: a method that parses
	 * input that has a description in front.
	 * @throws EmptyDescException 
	 */
	private void parseDelimitedString(){
		//checkAndRemoveDate();
		
		_sc = new Scanner(input);
		
		StringBuffer description = new StringBuffer();
		StringBuffer otherPart = new StringBuffer();
		String tempInput = null;
		
		tempInput = retrieveDescription(_sc, description, tempInput);
		otherPart = restructureOtherPart(otherPart, tempInput);
			
		_sc.close();
		
		_sc = new Scanner(otherPart.toString().trim());
		_sc.useDelimiter("\\s-");
		
		while(_sc.hasNext()){
			String nextParam = _sc.next().trim();
			
			nextParam = nextParam.replaceFirst("-", STRING_EMPTY);
			parseNextParam(nextParam.trim());
		}
		_sc.close();
		
		try {
			boolean isEdit = false;
			ArrayList<String> times = 
					checkDeadLineAndEndTime(_startTime, _startDate, _taskID, _deadline, _endTime, _endDate, isEdit);
			String endLatest = times.get(POSITION_TIME_ENDTIME / 2);
			String startEarliest = times.get(POSITION_TIME_STARTTIME / 2);
			_deadline = times.get(POSITION_TIME_DEADLINE / 2);
			
			if (_deadline != null){
				String[] deadTokens = _deadline.split(STRING_SPACE);
				_deadline = deadTokens[1] + STRING_SPACE + deadTokens[0];
			}
			
			if (endLatest == null){
				_endDate = null;
				_endTime = null;
			}
			
			if (startEarliest == null){
				_startDate = null;
				_startTime = null;
			}
		} catch (InvalidTaskIdException e) {
			//do nothing
			assert (false);
		}
		
		checkEmptyParametersAndInput();
	}

	/**
	 * Extracted method to input parameters
	 */
	private void checkEmptyParametersAndInput() {
		if (_endTime != null){
			inputEndTime(_endTime);
		}
		
		if (_endDate != null){
			inputEndDate(_endDate);
		}
		
		if (_startTime != null) {
			inputStartTime(_startTime);
		}
		
		
		if (_startDate != null){
			inputStartDate(_startDate);
		}
		
		if (_deadline != null){
			inputDeadlineDate(_deadline);
		}
	}

	/**
	 * 
	 * @param otherPart
	 * @param tempInput
	 * @return
	 */
	private StringBuffer restructureOtherPart(StringBuffer otherPart, String tempInput) {
		if (tempInput != null){
			otherPart.append(tempInput.trim());
		}
		while (_sc.hasNext()){
			otherPart.append(STRING_SPACE + _sc.next());
		}
		return otherPart;
	}

	/**
	 * @param description
	 * @param tempInput
	 * @return
	 */
	private String retrieveDescription(Scanner sc, StringBuffer description,
			String tempInput) {
		boolean isBreak = false;
		while (sc.hasNext()){
			tempInput = sc.next();
			 
			if (tempInput.equals("-d") || tempInput.equals("-e") || tempInput.equals("-s")){
				isBreak = true;
				break;
			}
			
			description.append(tempInput + STRING_SPACE);
		}
		
		String descString = description.toString().trim();
		descString = descString.replaceAll("\"", STRING_EMPTY);
		
		putOneParameter(PARAMETER_DESCRIPTION, descString);
		
		if (!isBreak){
			tempInput = STRING_EMPTY;
		}
		
		return tempInput;
	}
	
	private void parseNextParam(String param){
		String firstChar = getFirstChar(param);
		param = removeFirstChar(param);
		
		switch (firstChar){
		case "d":
			_deadNo++;
			_deadline = putDeadline(param);
			break;
		case "s":
			_startNo++;
			processStart(param);
			break;
		case "e": 
			_endNo++;
			processEnd(param);
			break;
		}
		
		LOGGER.info("deadline is " + _deadline );
		LOGGER.info("start time and date is " + _startTime + " " + _startDate);
		LOGGER.info("end time and date is " + _endTime + " " + _endDate);
		
		showErrorWhenActionRepeated(_startNo, _deadNo, _endNo);
	}

	private boolean checkIfDelimitedString() {
		String inputToCheck = input.toLowerCase();
		//delimited String	
		if (inputToCheck.contains(" -d ") || inputToCheck.contains(" -s ") || inputToCheck.contains(" -e ")){
			return true;
		}
		
		return false;
	}


	private void inputDeadlineDate(String deadline) {
		putOneParameter(PARAMETER_DEADLINE_DATE, deadline);		
	}
	
	
	
	private void inputStartDate(String date){
		putOneParameter(PARAMETER_START_DATE, date);
	}
	
	private void inputEndDate(String date){
		putOneParameter(PARAMETER_END_DATE, date);
	}
	
	private void inputStartTime(String time){
		putOneParameter(PARAMETER_START_TIME, time);
	}
	
	private void inputEndTime(String time){
		putOneParameter(PARAMETER_END_TIME, time);
	}
	
	private String stripWhiteSpaces(String input){
		return input.replaceAll(STRING_SPACE, STRING_EMPTY);
	}
	
	private void inputStartTimeDate(String result){
		String[] splitResult = result.split(STRING_SPACE);
		_startDate = splitResult[0];
		_startTime = splitResult[1];
	}
	
	private void inputEndTimeDate(String result){
		String[] splitResult = result.split(STRING_SPACE);
		_endDate = splitResult[0];
		_endTime = splitResult[1];
	}
	
	private void processEnd(String param){
		String endResult = putEndTime(param);
		if (endResult != null){
			inputEndTimeDate(endResult);
		}
	}
	
	private void processStart(String param){
		String startResult = putStartTime(param);
		if (startResult != null){
			inputStartTimeDate(startResult);
		}
	}
	
	/**
	 *  =========================DEPRECATED===============================================================================
	 */
	
	/**
	 * @deprecated
	 * @param param
	 */
	private void getDeadline(String param) {
		param = stripWhiteSpaces(param);
		try {
			param = DateAndTimeManager.getInstance().parseDate(param);
		} catch (InvalidDateException e) {
			InputManager.outputToGui(e.getMessage());
			_invalidParameters = true;
		}
		inputDeadlineDate(param);
	}
	
	/* Helper methods for parsing delimited strings */
	/**
	 * @deprecated
	 */
	@SuppressWarnings("unused")
	private void checkAndRemoveDate() {
		String[] splitInput = input.split(STRING_SPACE);
		String newInput = STRING_EMPTY;
		
		for (int i=0; i<splitInput.length; i++){
			if (splitInput[i].toLowerCase().equals("-d")){
				getDeadline(splitInput[i+1]);
				splitInput[i+1] = STRING_EMPTY;
			} else {
				newInput += splitInput[i] + STRING_SPACE;
			}
		}
		input = newInput;
	}
	
	/**
	 * @deprecated
	 * @param dateArray
	 * @return
	 */
	/*
	private ArrayList<String> sortDateArray(ArrayList<String> dateArray) {
		ArrayList<Date> dates = convertStringToDates(dateArray);

		Collections.sort(dates, new Comparator<Date>(){
			@Override
			public int compare(Date d1, Date d2) {
				return d1.compareTo(d2);
			}
		});
		
		return null;
	}
	*/

	/**
	 * @deprecated
	 * @param dateArray
	 * @return
	 */
	/*
	private ArrayList<Date> convertStringToDates(ArrayList<String> dateArray) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/mm/yyyy");
		ArrayList<Date> dates = new ArrayList<Date>();
		
		for (int i=0; i<dateArray.size(); i++){
			try {
				dates.add(sdf.parse(dateArray.get(i)));
			} catch (ParseException e) {
				//do nothing
			}
		}
		
		return dates;
	}
	*/
	
	/*
	private static String constructNewInputString(String[] splitInput,
			String newInput, int index) {
		if (index != -1){
			for (int i=0; i<splitInput.length; i++){
				if (splitInput[i].equals(STRING_DASH)){
					continue;
				} else {
					newInput += splitInput[i].trim() + STRING_SPACE;
				}
			}
		}
		return newInput;
	}*/
	
	
	/**
	 * @param timeArray
	 */
	/*
	private void orderTimeArray(ArrayList<String> timeArray) {
		//this method is add temporary to avoid bug
		if (timeArray.size() != 2){
			return;
		}
		
		Collections.sort(timeArray);
		inputStartTime(timeArray.get(0));
		inputEndTime(timeArray.get(1));
	}
	*/

	/**
	 * @param dateArray
	 */
	/*
	private void orderDateArray(ArrayList<String> dateArray) {
		//this method is add temporary to avoid bug
		if (dateArray.size() != 3){
			return;
		}
		
		dateArray = sortDateArray(dateArray);
		inputDeadlineDate(dateArray.get(0));
		inputStartDate(dateArray.get(1));
		inputEndDate(dateArray.get(2));
	}
	*/
	
	/*
	private String[] splitBySpace(String param) {
		return param.split(STRING_SPACE);
	}
	*/
	
	/*
	private boolean descAlreadyEntered(){
		return inputParameters.get(PARAMETER_DESCRIPTION) != STRING_EMPTY;
	}
	*/
	
	/**
	 * @deprecated
	 * @param desc
	 */
	/*
	private void inputDesc(String desc) {
		putOneParameter(PARAMETER_DESCRIPTION, desc);		
	}
	*/
	
	/**
	 * For each input index, if it is date, put in date; if it is time, put in time
	 * Otherwise, string them together as description
	 * @deprecated
	 * @param splitInput
	 */
	/*
	@SuppressWarnings({ "unused"})
	private String extractTimeAndDate(String[] splitInput) {
		ArrayList<String> dateArray = new ArrayList<String>();
		ArrayList<String> timeArray = new ArrayList<String>();
		
		String newInput = STRING_EMPTY;
		
		for (int i=0; i<splitInput.length; i++){
			String inputString = stripWhiteSpaces(splitInput[i]);
			
			DateObject dateObject = DateAndTimeManager.getInstance().findDate(inputString);
			if (dateObject != null){
				dateArray.add(dateObject.getParsedDate());
			} else{
				TimeObject timeObject = DateAndTimeManager.getInstance().findTime(inputString);
				if (timeObject != null){
					timeArray.add(timeObject.getParsedTime());
				} else {
					newInput += inputString + STRING_SPACE;
				}
			}
		}		
		
		orderDateArray(dateArray);
		orderTimeArray(timeArray);
		
		return newInput;
		
	}
	*/

	/**
	 * @deprecated
	 * @param param
	 * @return
	 */
	/*
	private boolean findTimeOrDate(String param){
		param = param.trim();		
		
		DateObject dateObject = DateAndTimeManager.getInstance().findDate(param);
		if (dateObject != null){
			return true;
		} else {
			TimeObject timeObject = DateAndTimeManager.getInstance().findTime(param);
			if (timeObject != null){
				return true;
			}
		}
		return false;
	}
	*/

	/**
	 * @deprecated
	 * @param param
	 */
	/*
	private void getStartDetails(String param){
		String[] inputParams = splitBySpace(param);
		inputParams = findDateTime(inputParams);
		
		inputStartDate(inputParams[0]);
		inputStartTime(inputParams[1]);
	}
	*/
	
	/**
	 * @deprecated
	 * @param param
	 */
	/*
	private void getEndDetails(String param){
		String[] inputParams = splitBySpace(param);
		inputParams = findDateTime(inputParams);
		
		inputEndDate(inputParams[0]);
		inputEndTime(inputParams[1]);
	}
	*/
	
	/**
	 * @deprecated
	 * @param inputParams
	 * @return
	 */
	/*
	private String[] findDateTime(String[] inputParams) {
		String[] dateTime = {STRING_EMPTY, STRING_EMPTY};
		boolean gotDate = false;
		boolean gotTime = false;
		
		for (int i=0; i<inputParams.length; i++){
			if (!gotDate){
				DateObject dateObject = DateAndTimeManager.getInstance().findDate(inputParams[i].trim());
				if (dateObject != null){
					dateTime[0] = dateObject.getParsedDate();
					gotDate = true;
				} else if (!gotTime){
					TimeObject timeObject = DateAndTimeManager.getInstance().findTime(inputParams[i].trim());
					dateTime[1] = timeObject.getParsedTime();
					gotTime = true;
				}
			} 
		}
		
		return dateTime;
	}
	*/
	
	/**
	 * @deprecated
	 */
	/*
	@SuppressWarnings("unused")
	private void checkAndRemoveEnd() {
		String[] splitInput = input.split(STRING_SPACE);
		String newInput = STRING_EMPTY;
		String param = STRING_EMPTY;
		int index = -1;
		
		for (int i=0; i<splitInput.length; i++){
			if (splitInput[i].toLowerCase().equals("-e")){
				index = i;
				splitInput[i] = STRING_DASH;
				if (findTimeOrDate(splitInput[i+1])){
					param += splitInput[i+1] + STRING_SPACE;
					splitInput[i+1] = STRING_DASH;
				} 
				
				if (findTimeOrDate(splitInput[i+2])){
					param += splitInput[i+2] + STRING_SPACE;
					splitInput[i+2] = STRING_DASH;
				} 
			} 
		}
		
		newInput = constructNewInputString(splitInput, newInput, index);

		getEndDetails(param);
		input = newInput;
	}
	*/
	
	/**
	 * @deprecated
	 */
	/*
	@SuppressWarnings("unused")
	private void checkAndInputDesc(){
		if (inputParameters.get(PARAMETER_DESCRIPTION) != STRING_EMPTY){
			inputDesc(input);
		}
	}
	*/
	
	/**
	 * @deprecated
	 */
	/*
	@SuppressWarnings("unused")
	private void checkAndRemoveStart() {
		String[] splitInput = input.split(STRING_SPACE);
		String newInput = STRING_EMPTY;
		String param = STRING_EMPTY;
		int index = -1;
		
		for (int i=0; i<splitInput.length; i++){
			if (splitInput[i].toLowerCase().equals("-s")){
				index = i;
				splitInput[i] = STRING_DASH;
				if (findTimeOrDate(splitInput[i+1])){
					param += splitInput[i+1] + STRING_SPACE;
					splitInput[i+1] = STRING_DASH;
				} 
				
				if (findTimeOrDate(splitInput[i+2])){
					param += splitInput[i+2] + STRING_SPACE;
					splitInput[i+2] = STRING_DASH;
				} 
			} 
		}
		
		newInput = constructNewInputString(splitInput, newInput, index);

		getStartDetails(param);
		input = newInput;
	}
	
	*/
	/* Testing
	public static void main(String[] args){
		checkAndRemoveStart();
	}
	//*/
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Add.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Addinfo.java
	 */


package com.taskpad.input;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidQuotesException;


public class Addinfo extends Command{
	
	private static final String COMMAND_ADD_INFO = "ADDINFO";
	private static final int NUMBER_ARGUMENTS = 2;
	
	private static String PARAMETER_INFO = "INFO";
	private static String PARAMETER_TASK_ID = "TASKID";
	
	private static String _info = "";
	private static String _taskID = "";
	private String _editInput;
	
	private static final String STRING_SPACE = " ";


	public Addinfo(String input, String fullInput) {
		super(input, fullInput);
	}

	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_ADD_INFO);
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
	}
	
	@Override
	protected boolean commandSpecificRun() {
		//String splitInput[] = input.split(" ");
		//_taskID = splitInput[0];
		LOGGER.info("fullInput is " + fullInput);
		_editInput = fullInput;  
		if(hasNoTaskIDInPosition(fullInput)){
			try {
				_taskID = findTaskID(fullInput);
			} catch (TaskIDException | InvalidQuotesException e) {
				InputManager.outputToGui(e.getMessage());
				LOGGER.severe(e.getMessage());
				return false;
			}
		}
		fullInput = _editInput;
		
		_info = getInfo(input, _taskID);
		return true;
	}
	
	@Override
	protected boolean checkIfIncorrectArguments() throws InvalidParameterException, TaskIDException{
		String inputString[] = input.split(STRING_SPACE);
		
		if (isNotNumberArgs(inputString)){
			LOGGER.severe("Throw");
			LOGGER.severe("inputString is " + inputString);
			throw new InvalidParameterException();
		}
			
		return false;
	}
	
	/**
	 * Takes in input string and finds the first integer as taskID
	 * @param input
	 * @return taskID
	 * @throws TaskIDException 
	 * @throws InvalidQuotesException 
	 */
	private String findTaskID(String input) throws TaskIDException, InvalidQuotesException{
		String numberInput = DateAndTimeManager.getInstance().parseNumberString(input);

		LOGGER.info("finding TaskID. Converted to numberInput");
		LOGGER.info("numberInput is " + numberInput);
		
		input = numberInput;
		fullInput = numberInput;
		
		LOGGER.info("input is " + input);
		LOGGER.info("fullInput is " + fullInput);
		
		int taskID = -1;
		String[] splitInput = input.split(STRING_SPACE);
		
		for (int i = 0; i < splitInput.length; i++){
			if (taskID == -1){
				String token = splitInput[i];
				if (!isNotValidTaskID(token)){
					taskID = Integer.parseInt(token);
					break;
				}
			}
		}
				
		LOGGER.info("taskID is " + taskID);
		
		if (taskID == -1){
			LOGGER.severe("TASK ID is invalid!");
			throw new TaskIDException();
		}
		
		return "" + taskID;
	}
	
	/**
	 * Check if second word entered is an integer (likely to be taskID)
	 * @param fullInput
	 * @return true if is integer and sets it as taskID
	 */
	private boolean hasNoTaskIDInPosition(String fullInput) {
		String splitInput[] = fullInput.split(STRING_SPACE);
		
		if (isNotValidTaskID(splitInput[1])){
			InputManager.outputToGui(MESSAGE_WARNING_TASKID);
			return true;
		} else {
			int taskID = Integer.parseInt(splitInput[1]);
			_taskID = "" + taskID;
			return false;
		}
		/*
		try{
			int taskID = Integer.parseInt(splitInput[1]);
			_taskID = "" + taskID;
			return false;
		} catch (NumberFormatException e){
			InputManager.outputToGui(MESSAGE_WARNING_TASKID);
			return true;
		}
		*/
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_TASK_ID, "");
		putOneParameter(PARAMETER_INFO, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_TASK_ID, _taskID);
		putOneParameter(PARAMETER_INFO, _info);
	}
	
	@Override
	protected boolean isNotNumberArgs(String[] inputString){
		if (inputString.length < getNUMBER_ARGUMENTS()){
			return true;
		}
		return false;
	}
	
	private String getInfo(String input, String taskID){
		//input = removeFirstWord(input);
		return input.replaceFirst(taskID, "").trim();
	}
	
	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	@SuppressWarnings("unused")
	private String removeFirstWord(String input){
		return input.replace(getFirstWord(input), "").trim();
	}
	
	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private static String getFirstWord(String input) {
		return input.trim().split("\\s+")[0];
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Addinfo.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Addrem.java
	 */


package com.taskpad.input;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;
import java.util.logging.Logger;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.DatePassedException;
import com.taskpad.dateandtime.InvalidQuotesException;
import com.taskpad.dateandtime.InvalidTimeException;
import com.taskpad.dateandtime.TimeErrorException;
import com.taskpad.ui.GuiManager;
//import com.taskpad.dateandtime.DateObject;
//import com.taskpad.dateandtime.TimeObject;


public class Addrem extends Command{
	private static final String STRING_SPACE = " ";

	private static final String DAY_TIME_END = "23:59";

	protected static final Logger LOGGER = Logger.getLogger("TaskPad");
	
	private static final String COMMAND_ADD_REM = "ADDREM";
	private static final int NUMBER_ARGUMENTS = 2;
	private static final String SPACE = Addrem.STRING_SPACE;
		
	private static final String PARAMETER_TASK_ID = "TASKID";
	private static final String PARAMETER_REM_DATE = "DATE";
	private static final String PARAMETER_REM_TIME = "TIME";
	
	private String _taskID;
	private String _remDate;
	private String _remTime;
	
	/*
	private static DateObject _dateObject;
	private static TimeObject _timeObject;
	*/
	
	private static Scanner sc;
	private boolean _invalidParameters = false;
	
	private boolean _isFlexiString = false;
	
	boolean _gotTaskID = false;
	boolean _gotDate = false;
	boolean _gotTime = false;

	public Addrem(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_ADD_REM);
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		
		sc = new Scanner(System.in);
		//_dateObject = null;
		//_timeObject = null;
		_taskID = "";
		_remDate = "";
		_remTime = "";
	}

	@Override
	protected boolean commandSpecificRun() {	
		LOGGER.info("is input : " + input + " a flexi String? " + _isFlexiString);
		
		if (!_isFlexiString){
			try {
				splitInputParameters();
			} catch (InvalidQuotesException e) {
				return false; 
			 }
		} else {
			boolean isContinuing = splitInputNoDelimiters();
			if (!isContinuing){
				return false;
			}
		}
		
		//putInputParameters();
		
		try {
			checkTimeAndDate();
		} catch (DatePassedException e) {
			InputManager.outputToGui(e.getMessage());
		}
				
		if (_invalidParameters){
			LOGGER.info("parameters are incorrect!");
			InputManager.outputToGui("parameters are incorrect!");
			return false;
		} 
 
		LOGGER.info("Reminder added! " + Addrem.STRING_SPACE + _taskID + ": " +  _remDate + Addrem.STRING_SPACE + _remTime);
		InputManager.outputToGui("Reminder added! " + Addrem.STRING_SPACE + _taskID + ": " +  _remDate + Addrem.STRING_SPACE + _remTime);
		
		return true;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_TASK_ID, _taskID);	
		putOneParameter(PARAMETER_REM_DATE, _remDate);
		putOneParameter(PARAMETER_REM_TIME, _remTime);
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_TASK_ID, _taskID);	
		putOneParameter(PARAMETER_REM_DATE, _remDate);
		putOneParameter(PARAMETER_REM_TIME, _remTime);		
	}
	
	@Override
	protected boolean isNotNumberArgs(String[] inputString){
		if (inputString.length == getNUMBER_ARGUMENTS() ||
				inputString.length == getNUMBER_ARGUMENTS()+1 || 
				inputString.length == getNUMBER_ARGUMENTS()+2 || 
				inputString.length == getNUMBER_ARGUMENTS()+3){
			return false;
		}
		return true;
	}
	
	@Override
	protected boolean checkIfIncorrectArguments() throws InvalidParameterException, TaskIDException{
		LOGGER.info("input is " + input);
		
		if(checkIfContainsDelimiters()){
			String inputString[] = input.split(Addrem.STRING_SPACE);
			
			if (isNotNumberArgs(inputString)){
				//System.out.println("Throw");
				throw new InvalidParameterException();
			}
			
			if(isNotValidTaskID(inputString[0])){
				throw new TaskIDException(inputString[0]);
			}
		} else{
			_isFlexiString = true;
		}
		return false;
	}
	
	private void splitInputParameters() throws InvalidQuotesException{
		int count = 0;
		sc = new Scanner(input);
		sc.useDelimiter("\\s-");
		
		int dCnt = 0;
		int tCnt = 0;
		while(sc.hasNext()){
			String nextParam = sc.next();
			if (count == 0){
				_taskID = nextParam;
			} else {
				switch (parseNextParam(nextParam)){
				case 0:
					dCnt++;
					break;
				case 1:
					tCnt++;
					break;
				}
			}
			count++;
		}
		
		sc.close();

		
		if (dCnt == 0 && tCnt == 0){
			_invalidParameters = true;
			return;
		} else if (dCnt > 0 || tCnt > 0) {
			_invalidParameters = false;
		}
		
		if (dCnt > 1){
			InputManager.outputToGui("-d appears " + dCnt + "times");
		}
		
		if (tCnt > 1){
			InputManager.outputToGui("-t appears " + tCnt + "times");
		}
		
		assert (_remDate != null);
		assert (_remTime != null);
		
		_remDate = _remDate.trim();
		_remTime = _remTime.trim();
		
		String dateAndTime = null;
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		if (!_remDate.isEmpty() && !_remTime.isEmpty()){
			dateAndTime = _remDate + STRING_SPACE + _remTime;
		} else if (_remDate.isEmpty() && !_remTime.isEmpty()){
			String todayDate = datm.getTodayDate();
			dateAndTime = todayDate + STRING_SPACE + _remTime;
		} else if (!_remDate.isEmpty() && _remTime.isEmpty()){
			_remTime = STRING_SPACE + DAY_TIME_END;
			dateAndTime = _remDate + _remTime;
		}
		
		findDateAndTime(dateAndTime);
	}

	/**
	 * @param dateAndTime
	 * @throws InvalidQuotesException
	 */
	private void findDateAndTime(String dateAndTime)
			throws InvalidQuotesException {
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		if (dateAndTime != null){
			//dateAndTime += " 23:59";
			try {
				String formatString = datm.formatDateAndTimeInString(dateAndTime);
				String[] formatTokens = formatString.split(STRING_SPACE);
				int size = formatTokens.length;
				
				_remDate = formatTokens[size - POSITION_DATE_STARTTIME];
				_remTime = formatTokens[size - POSITION_TIME_STARTTIME];
				
				LOGGER.info("remDate is " + _remDate);
				LOGGER.info("remTime is " + _remTime);
				
				if ("null".equals(_remDate) && "null".equals(_remTime)){
					_remDate = "";
					_remTime = "";
				}
				
			} catch (InvalidQuotesException e) {
				_invalidParameters = true;  
				InputManager.outputToGui(e.getMessage());
				throw e;
			}
		}
	}
	
	private int parseNextParam(String param){
		String firstChar = getFirstChar(param);
		param = removeFirstChar(param).trim();
		
		switch (firstChar){
		case "d":
			getDeadline(param);
			//break;
			return 0;
		case "t":
			inputTime(param);
			//break;
			return 1;
		default:
			invalidParam();
		}
		
		
		//if reach here then is invalidParam
		return -1;
	}
	
	private boolean splitInputNoDelimiters(){
		//input = DateAndTimeManager.getInstance().formatDateAndTimeInString(input);
		String[] splitInput = input.split(SPACE);
		
		try {
			checkIfInvalidParameters(splitInput.length);
		} catch (InvalidParameterException e) {
			GuiManager.callOutput(e.getMessage());
			return false;
		};
		
		extractTaskID(splitInput);
		
		if (invalidIfNoTaskID()){
			return false;
		}
		
		String dateAndTime = buildString(splitInput);
		//extractTimeAndDate(splitInput);
		
		try {
			findDateAndTime(dateAndTime);
		} catch (InvalidQuotesException e) {
			InputManager.outputToGui(e.getMessage());
			return false;
		}
		
		if (invalidIfNoDateOrTime()){
			return false;
		}
		
		return true;
	}
	
	private void extractTaskID(String[] splitInput) {
		for (int i = 0; i < splitInput.length; i++){
			String token = splitInput[i];
			if (!isNotValidTaskID(token)){
				_taskID = token;
				_gotTaskID = true;
				splitInput[i] = null;
				return;
				//_invalidParameters = true;
				//throw new TaskIDException(taskID);
			} 
		}
		
		//if reach here then doesn't have valid taskID
		_invalidParameters = true;
		_gotTaskID = false;
	}

	private boolean invalidIfNoTaskID(){
		if (_taskID.equals("")){
			_invalidParameters = true;
			InputManager.outputToGui("Invalid Task ID");
			return true;
		}
		return false;
	}
	
	private boolean invalidIfNoDateOrTime(){
		if(_remDate.equals("") && _remTime.equals("")){
			_invalidParameters = true;
			InputManager.outputToGui("No date or time input");
			return true;
		}
		return false;
	}
	
	private boolean checkIfInvalidParameters(int length) throws InvalidParameterException{
		if (length == NUMBER_ARGUMENTS || length == NUMBER_ARGUMENTS + 1){
			return true;
		} else{
			throw new InvalidParameterException();
		}
	}
	
	

	private boolean checkIfContainsDelimiters() {
		return fullInput.contains(" -d ")||input.contains(" -t ");
	}
	
	private void getDeadline(String param) {		
		param = stripWhiteSpaces(param);
		_remDate = param;
	}
	
	private void inputTime(String param) {
		param = stripWhiteSpaces(param);
		//_remTime = param;		//deprecated for flexi commands
		//_remTime = DateAndTimeManager.getInstance().parseTime(param.trim());
		try {
			_remTime = DateAndTimeManager.getInstance().parseTimeInput(param.trim());
			//_remTime = DateAndTimeManager.getInstance().parseTime(param.trim());
		} catch (TimeErrorException | InvalidTimeException e) {
			//ErrorMessages.timeErrorMessage(_remTime);
			InputManager.outputToGui(e.getMessage());
			return;
		}
	}
	
	/** 
	 * 
	 * Checks if the rem time and date added is after current time and date
	 * If so, throw exception, and populate invalidParameters
	 * @throws DatePassedException 
	 */
	private void checkTimeAndDate() throws DatePassedException {
		String dateAndTime = _remDate + Addrem.STRING_SPACE + _remTime;
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		String now = datm.getTodayDateAndTime();
		
		int num = datm.compareDateAndTime(dateAndTime, now);
		
		if (num <= 0){
			_invalidParameters = true;
			throw new DatePassedException();
		}
		
		/*
		Date now = new Date();
		Date date = null;
		date = parseRemDateAndTime(date);
			
		if (now.compareTo(date) > 0){
			_invalidParameters = true;
			throw new DatePassedException();
		}
		*/
	}

	/**
	 * @deprecated
	 * @param date
	 * @return
	 */
	@SuppressWarnings("unused")
	private Date parseRemDateAndTime(Date date) {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		String enteredDateAndTime = formatRemString();
		try {
			date = sdf.parse(enteredDateAndTime);
		} catch (ParseException e) {
			//Do nothing
		}
		return date;
	}
	
	
	
	private String stripWhiteSpaces(String input){
		return input.replaceAll(Addrem.STRING_SPACE, "");
	}
	
	private void invalidParam() {
		_invalidParameters = true;
	}
	
	/**
	 * ====================================DEPRECATED==============================================================
	 */
	/**
	 * @deprecated
	 * @return
	 */
	private String formatRemString(){
		String dateString = formatParaDate() + Addrem.STRING_SPACE + formatParaTime();
		return dateString;
	}
	
	/**
	 * @deprecated
	 * @return
	 */
	private String formatParaDate(){
		String dateString = "";
		if (_remDate.equals("")){
			_remDate = DateAndTimeManager.getInstance().getTodayDate();
		}
		
		dateString += _remDate;
		
		return dateString;
	}
	
	/**
	 * @deprecated
	 * @return
	 */
	private String formatParaTime(){
		String timeString = "";
		if(_remTime.equals("")){
			timeString += DateAndTimeManager.getInstance().getTodayTime();
		}else {
			timeString += _remTime;
		}
		
		return timeString;
	}
	
	/* deprecated for flexiCommands without delimiters
	private void splitInputNoDelimiters() throws TaskIDException {		
		String[] splitInput = input.split(SPACE);
		_taskID = splitInput[0];
		
		if (Integer.parseInt(_taskID) > InputManager.retrieveNumberOfTasks()+1){
			throw new TaskIDException(_taskID);
		}
		_remDate = splitInput[1];
		if (splitInput.length == 3){
			//_remTime = splitInput[2];		//deprecated for flexi commands
			try {
				_remTime = DateAndTimeManager.getInstance().parseTimeInput(splitInput[2].trim());
			} catch (TimeErrorException | InvalidTimeException e) {
				//ErrorMessages.invalidTimeMessage();
				InputManager.outputToGui(e.getMessage());
				_invalidParameters = true;
				return;
			}
		}
	}
	*/     
	
	/**
	 * @deprecated
	 * @param splitInput
	 */
	@SuppressWarnings("unused")
	private void extractTimeAndDate(String[] splitInput){	
		for (int i=0; i<splitInput.length; i++){
			if(!_gotDate && isDateObject(splitInput[i])){
				//_remDate = _dateObject.getParsedDate();
				_gotDate = true;
			} else if (!_gotTime && isTimeObject(splitInput[i])){
				//_remTime = _timeObject.getParsedTime();
				_gotTime = true;
				
			} else if (!_gotTaskID){
				try {
					enterTaskID(splitInput[i]);
				} catch (TaskIDException e) {
					continue;
				}
			}
		}
	}
	
	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private boolean isTimeObject(String input) {
		//_timeObject = DateAndTimeManager.getInstance().findTime(input);
		//if (_timeObject != null){
		//	return true;
		//}
		return false;
	}

	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	private boolean isDateObject(String input) {
		//_dateObject = DateAndTimeManager.getInstance().findDate(input);
		//if (_dateObject != null){
		//	return true;
		//}
		return false;
	}

	/**
	 * @deprecated
	 * @param taskID
	 * @throws TaskIDException
	 */
	private void enterTaskID(String taskID) throws TaskIDException{
		taskID = taskID.trim();
		if (isNotValidTaskID(taskID)){
			_invalidParameters = true;
			throw new TaskIDException(taskID);
		} else{
			_taskID = taskID;
			_gotTaskID = true;
		}
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Addrem.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\ClearTasks.java
	 */


package com.taskpad.input;


public class ClearTasks extends Command{
	
	private static final String COMMAND_CLEAR = "CLEAR";
	private static final int NUMBER_ARGUMENTS = 0;

	private static final String PARAMETER_NULL = "NULL";
	
	public ClearTasks(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_CLEAR);
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
	}
	
	@Override
	public void run(){
		initialiseParametersToNull();
		putInputParameters();
		createInputObject();
		passObjectToExecutor();
	}

	@Override
	protected boolean commandSpecificRun() {
		return false;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_NULL, "");
	}

	@Override
	protected void putInputParameters() {		
		putOneParameter(PARAMETER_NULL, "");
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\ClearTasks.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Command.java
	 */


/* 
 * Abstract class for processing the commands 
 */

package com.taskpad.input;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.logging.Logger;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidQuotesException;
import com.taskpad.execute.InvalidTaskIdException;

public abstract class Command {

	protected static Input inputObject;
	protected static Map<String, String> inputParameters;
	protected static String input;
	protected static String fullInput;
	
	protected static int NUMBER_ARGUMENTS;
	protected static String COMMAND;
	
	protected static final String MESSAGE_EMPTY_INPUT = "Error: Empty Input";
	protected static final String MESSAGE_INVALID_INPUT = "Error: Invalid input: %s";
	protected static final String MESSAGE_INVALID_PARAMETER_NUMBER = "Error: Invalid number of parameters.\nType help if you need! :)";
		
	protected static final String MESSAGE_DEADLINE_STARTTIME = "%s should be later than start time";
	protected static final String MESSAGE_ENDDATE_STARTTIME = "%s %s should be later than start time";
	protected static final String MESSAGE_WARNING_STARTDATETIME ="WARNING: has %s start date and time";
	protected static final String MESSAGE_WARNING_ENDDATETIME = "WARNING: has %s end date and time";
	protected static final String MESSAGE_WARNING_INFONO = "WARNING: has %s info tag, discarding second one";
	protected static final String MESSAGE_WARNING_DEADLINE = "WARNING: has %s deadline";
	protected static final String MESSAGE_INVALID_DATE = "%s is not a valid date";
	protected static final String MESSAGE_WARNING_TASKID = "Warning: TaskID is not in standard position";
	
	protected static final Logger LOGGER = Logger.getLogger("TaskPad");
	
	private static final String STRING_SPACE = " ";
	private static final String STRING_NULL = "null";
	private static final String STRING_EMPTY = "";
	private static final String STRING_QUOTE = "\"";
	
	protected static final String KEYWORD_ENDTiME = "TO";
	protected static final String KEYWORD_STARTTIME = "FROM";
	protected static final String KEYWORD_DEADLINE = "BY";
	
	protected static final int POSITION_TIME_ENDTIME = 1;
	protected static final int POSITION_DATE_ENDTIME = 2;
	protected static final int POSITION_TIME_STARTTIME = 3;
	protected static final int POSITION_DATE_STARTTIME = 4;
	protected static final int POSITION_TIME_DEADLINE = 5;
	protected static final int POSITION_DATE_DEADLINE = 6;
	
	public Command(String input, String fullInput){
		Command.fullInput = fullInput;
		Command.input = input;
		inputParameters = new HashMap<String,String>();
		initialiseOthers();
		run();
	}
	
	protected abstract void initialiseOthers();

	public void run() {
		input = input.trim();
		try {
			checkIfEmptyString();
		} catch (EmptyStringException e) {
			showEmptyString();
			return;
		}
		
		String numberInput = STRING_EMPTY;
		try {
			numberInput = DateAndTimeManager.getInstance().parseNumberString(input);
		} catch (InvalidQuotesException e1) {
			InputManager.outputToGui(e1.getMessage());
			return;
		}
		//System.out.println(numberInput);
		checkIfNumberInputEmpty(numberInput);
				
		try {
			checkIfIncorrectArguments();
		} catch (TaskIDException | InvalidParameterException e) {
			//showIncorrectArguments();
			InputManager.outputToGui(e.getMessage());
			return;
		}
		
		clearInputParameters();
		initialiseParametersToNull();
		
		if (commandSpecificRun()){
			createInputObject();
			passObjectToExecutor();
		} else {
			return;
		}
	}

	private void checkIfNumberInputEmpty(String numberInput) {
		numberInput = numberInput.trim();
		if (!numberInput.equals("") || numberInput != null){
			LOGGER.info("numberInput is " + numberInput);
			String[] inputTokens = numberInput.split(" ");
			
			for (int i = 0; i < inputTokens.length - 1; i++){
				if (inputTokens[i] == null){
					continue;
				} else if ("".equals(inputTokens[i])){
					inputTokens[i] = null;
					continue;
				} else if ("-".equals(inputTokens[i])){
					switch (inputTokens[i + 1]){
					case "d":
					case "s":
					case "e":
					case "t":
					case "i":
						inputTokens[i] = inputTokens[i] + inputTokens[i + 1];
						inputTokens[i + 1] = null;
						break;
					}
				}
			}
			  
			input = buildString(inputTokens);
			
			LOGGER.info("input is " + input);
		}
	}

	/**
	 * @param inputTokens
	 * @return
	 */
	protected String buildString(String[] inputTokens) {
		StringBuffer inputBuilder = new StringBuffer();
		for (int i = 0; i < inputTokens.length; i++){
			if (inputTokens[i] != null){
				inputBuilder.append(inputTokens[i] + STRING_SPACE);
			}
		}
		return inputBuilder.toString().trim();
	}
	
	protected void showEmptyString(){
		String errorMessage = String.format(MESSAGE_EMPTY_INPUT);
		InputManager.outputToGui(errorMessage);
	}

	protected void showNoDesc() {
		String errorMessage = String.format(MESSAGE_INVALID_INPUT, input);
		InputManager.outputToGui(errorMessage);
	}
	
	protected abstract boolean commandSpecificRun();
	
	protected boolean checkIfEmptyString() throws EmptyStringException {
		
		if(isEmptyString()){
			throw new EmptyStringException();
//			InputManager.outputToGui(MESSAGE_EMPTY_INPUT);
//			return true;
		}
		return false;
	}
	
	protected abstract void initialiseParametersToNull();
	
	protected boolean checkIfIncorrectArguments() throws TaskIDException, InvalidParameterException{
		String inputString[] = input.split(" ");
		
		if (isNotNumberArgs(inputString)){
			throw new InvalidParameterException();
		}
		
		if(isNotValidTaskID(inputString[0])){
			throw new TaskIDException(inputString[0]);
		}
		
		return false;
	}
	
	protected boolean isNotValidTaskID(String taskID){
		if(isNotInteger(taskID) || isInvalidID(taskID)){
			//outputIdError();
			return true;
		}	
		return false; 
	}
	
	protected Input createInputObject() {
		//clearInputParameters();	
		putInputParameters();
		inputObject = new Input(getCOMMAND(), inputParameters);	
		
		//inputObject.showAll();
		
		LOGGER.info("Input object created, command: " + inputObject.getCommand());
		return inputObject;
	}

	protected abstract void putInputParameters();
	
	protected static void clearInputParameters(){
		inputParameters.clear();
	}
	
	protected boolean isEmptyString(){
		if (input.isEmpty()){
			return true;
		}
		return false;
	}
	
	protected void putOneParameter(String parameter, String input){
		inputParameters.put(parameter, input);
	}
	
	protected void passObjectToExecutor(){
		assert (inputObject.getParameters().size() != 0);
		InputManager.passToExecutor(inputObject, fullInput);
		
		clearInputParameters();
		
		LOGGER.info("Input object passed to executor");
	}
	
	protected boolean isNotInteger(String input){
		try{
			Integer.parseInt(input);
		} catch (NumberFormatException e){
			return true;
		}
		return false;
	}
	
	protected boolean isInvalidID(String input){
		input = input.trim();
		int inputNum = Integer.parseInt(input.trim());
		if (inputNum > InputManager.retrieveNumberOfTasks() || inputNum < 0){
			return true;
		}
		return false;
	}
	
	protected boolean isNotNumberArgs(String[] inputString){
		if (inputString.length != getNUMBER_ARGUMENTS()){
			return true;
		}
		return false;
	}
	
	protected void invalidParameterError(){
		String errorMessage = String.format(MESSAGE_INVALID_PARAMETER_NUMBER);
		InputManager.outputToGui(errorMessage);
	}
	
	protected void outputIdError() {
		String errorMessage = String.format(MESSAGE_INVALID_INPUT, input);
		InputManager.outputToGui(errorMessage);
	}

	protected int getNUMBER_ARGUMENTS() {
		return NUMBER_ARGUMENTS;
	}

	protected void setNUMBER_ARGUMENTS(int nUMBER_ARGUMENTS) {
		NUMBER_ARGUMENTS = nUMBER_ARGUMENTS;
	}

	protected String getCOMMAND() {
		return COMMAND;
	}

	protected void setCOMMAND(String cOMMAND) {
		COMMAND = cOMMAND;
	}
	
	/* Helper methods to process date and times in strings For Edit and Add */
	
	/**
	 * findDateOrTime: helper method of getDateAndTimeValue,
	 * it uses formatDateAndTimeInString to get all the date and time
	 * @param fullInput
	 * @return
	 */
	protected String findDateOrTime(String fullInput) {
		LOGGER.info("findDateOrTime...");
		String formatInput = null;
		try {
			formatInput = DateAndTimeManager.getInstance().formatDateAndTimeInString(fullInput);
		} catch (InvalidQuotesException e) {
			LOGGER.severe("ERROR!! " + e.getMessage());
			InputManager.outputToGui(e.getMessage());
		}

		LOGGER.info("format input is: " + formatInput);
		return formatInput;
	}
	
	/**
	 * Main logic of getting date and time
	 * @param token
	 * @param splitResult
	 * @param datePos
	 * @param timePos
	 * @return dateString and timeString
	 */
	protected String getDateAndTime(String token, String[] splitResult, int datePos, int timePos) {
		String dateString = splitResult[datePos];
		String timeString = splitResult[timePos];
		
		LOGGER.info("getting date and time...");
		LOGGER.info("dateString is: " + dateString);
		LOGGER.info("timeString is: " + timeString);
		LOGGER.info("description is: " + splitResult[0]);
		
		//isDescNotNull is deprecated!
		//boolean isDescNotNull = splitResult.length > 6 && !splitResult[0].trim().isEmpty();
		boolean isDescNotNull = false;
		if (STRING_NULL.equals(dateString) || STRING_NULL.equals(timeString) || isDescNotNull){
			String errorMessage = String.format(MESSAGE_INVALID_DATE, token);
			InputManager.outputToGui(errorMessage);
			LOGGER.severe(errorMessage);
			return null;
		}
		
		return dateString + " " + timeString;
	}
	
	/**
	 * getDateAndTimeValue: is called by main function when finding
	 * deadlines/starttimes/endtimes and it returns the date and time
	 * @param token
	 * @param datePos
	 * @param timePos
	 * @return date and time if parsed correctly or null there error
	 */
	protected String getDateAndTimeValue(String token, int datePos, int timePos) {
		assert (token != null);
		assert (!token.trim().isEmpty());
		
		String formatInput = findDateOrTime(token);
		
		String[] splitResult = formatInput.split(STRING_SPACE);
		int arrDatePos = splitResult.length - datePos;
		int arrTimePos = splitResult.length - timePos;

		return getDateAndTime(token, splitResult, arrDatePos, arrTimePos);
	}
	
	/**
	 * For when the user has keyed in more than one startDate/ deadline/ endDate
	 * Used in ADD
	 * @param startNo
	 * @param deadNo
	 * @param endNo
	 */
	protected void showErrorWhenActionRepeated(int startNo, int deadNo, int endNo) {
		String errorMessage = STRING_EMPTY;
		
		if (startNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_STARTDATETIME, STRING_EMPTY + startNo);
			InputManager.outputToGui(errorMessage);
			LOGGER.warning(errorMessage);
		}
		
		if (endNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_ENDDATETIME, STRING_EMPTY + endNo);
			InputManager.outputToGui(errorMessage);
			LOGGER.warning(errorMessage);
		}
		
		if (deadNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_DEADLINE, STRING_EMPTY + deadNo);
			InputManager.outputToGui(errorMessage); 
			LOGGER.warning(errorMessage);
		}
	}
	
	/**
	 * For when the user has keyed in more than one startDate/ deadline/ endDate/ info
	 * used in Edit
	 * @param startNo, endNo, infoNo, deadNo
	 */
	protected void showErrorWhenActionRepeated(int startNo, int deadNo, int endNo, int infoNo){
		String errorMessage = STRING_EMPTY;
		
		if (startNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_STARTDATETIME, STRING_EMPTY + startNo);
			InputManager.outputToGui(errorMessage);
			LOGGER.warning(errorMessage);
		}
		
		if (endNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_ENDDATETIME, STRING_EMPTY + endNo);
			InputManager.outputToGui(errorMessage);
			LOGGER.warning(errorMessage);
		}
		
		if (deadNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_DEADLINE, STRING_EMPTY + deadNo);
			InputManager.outputToGui(errorMessage); 
			LOGGER.warning(errorMessage);
		}
		
		if (infoNo > 1){
			errorMessage = String.format(MESSAGE_WARNING_INFONO, STRING_EMPTY + infoNo);
			InputManager.outputToGui(errorMessage);
			LOGGER.warning(errorMessage);
		}
	}

	
	/**
	 * Check the deadline and end times are after start times
	 * @throws InvalidTaskIdException
	 */
	protected ArrayList<String> checkDeadLineAndEndTime(String startTime, String startDate, String taskID,
			String deadline, String endTime, String endDate, boolean isEdit) 
			throws InvalidTaskIdException {
		
		LOGGER.info("deadline is " + deadline);
		LOGGER.info("startDate is " + startDate);
		LOGGER.info("startTime is " + startTime);
		LOGGER.info("endDate is " + endDate);
		LOGGER.info("endTime is " + endTime);
		LOGGER.info("taskID is " + taskID);
		LOGGER.info("isEdit? " + isEdit);
		
		String startEarliest = null;
		if (startTime != null && startDate != null){
			startEarliest = startDate + STRING_SPACE + startTime;
			startEarliest = startEarliest.trim();
			
			LOGGER.info("startEarliest is " + startEarliest); 
			
			if (!startEarliest.isEmpty()){
				boolean isDeadline = true;
				startEarliest = checkStartEarliest(taskID, deadline, isEdit,
						startEarliest, isDeadline);
				LOGGER.info("Checked with deadline: startEarliest is " + startEarliest); 
				
				if (startEarliest != null){
					if (endDate == null || endTime == null){
						isDeadline = false;
						String endDateAndTime = null;
						LOGGER.info("Checked with endDate and endTime: startEarliest is " + startEarliest); 
						startEarliest = checkStartEarliest(taskID, endDateAndTime, isEdit,
								startEarliest, isDeadline);
					}
					
					if (startEarliest == null){
						LOGGER.info("startDate ( " + startDate + " ) and startTime ( " + startTime + " ) is invalid");
						
						startDate = null;
						startTime = null;
					}
				} else {
					LOGGER.info("startDate ( " + startDate + " ) and startTime ( " + startTime + " ) is invalid");
					
					startDate = null;
					startTime = null;
				}
				
			}
			
			
		} 
		
		if (isEdit && startEarliest == null){
			//For editing task, it has a task ID stored
			startEarliest = InputManager.getStartDateAndTimeForTask(Integer.parseInt(taskID));
		}

		LOGGER.info("startEarliest is " + startEarliest);
		LOGGER.info("deadline is " + deadline);
		
		if (deadline != null){
			String tempDeadline = deadline;
			deadline = InputManager.checkDateAndTimeWithStart(startEarliest, tempDeadline);
			
			if (deadline == null){
				InputManager.outputToGui(String.format(MESSAGE_DEADLINE_STARTTIME,tempDeadline));
			} else {
				deadline = deadline.trim();
			}
		}
		LOGGER.info("deadline is " + deadline);
		LOGGER.info("endLatest is " + endDate + STRING_SPACE + endTime);
		
		String endLatest = null;
		if (endTime != null && endDate != null){
			endLatest = endDate + STRING_SPACE + endTime;
			endLatest = InputManager.checkDateAndTimeWithStart(startEarliest, endLatest);
			
			if (endLatest == null){
				InputManager.outputToGui(String.format(MESSAGE_ENDDATE_STARTTIME, endDate, endTime));
			} else {
				endLatest = endLatest.trim();
			}
			
			/*
			if (endLatest != null){
				String[] endTokens = endLatest.split(STRING_SPACE);
				int datePos = 0;
				int timePos = 1;

				endDate = endTokens[datePos];
				endTime = endTokens[timePos];
			} else {
				InputManager.outputToGui(String.format(MESSAGE_ENDDATE_STARTTIME, endDate, endTime));
				//InputManager.outputToGui(endDate + STRING_SPACE + endTime + " should be later than start time"); 
				endDate = null;
				endTime = null;
			}
			*/
			
		}
		LOGGER.info("endLatest is " + endLatest);
		
		if (startDate == null || startTime == null){
			startEarliest = null;
		}
		
		ArrayList<String> times = new ArrayList<String>();
		times.add(endLatest);
		times.add(startEarliest);
		times.add(deadline);
		
		return times;
	}

	/**
	 * 
	 * @param taskID
	 * @param dateAndTime
	 * @param isEdit
	 * @param startEarliest
	 * @param isDeadline
	 * 						: true if it is deadline, false if it is endtime
	 * @return
	 * @throws InvalidTaskIdException
	 */
	private String checkStartEarliest(String taskID, String dateAndTime,
			boolean isEdit, String startEarliest, boolean isDeadline) throws InvalidTaskIdException {
		if (isEdit){
			LOGGER.info("isEdit, checking whether startEarliest( " + startEarliest + " ) is valid");
			//use existing deadline, then start time cannot be first
			if (dateAndTime == null){
				String existDateAndTime;
				if (isDeadline){
					existDateAndTime = InputManager.getDeadlineForTask(Integer.parseInt(taskID));
				} else {
					existDateAndTime = InputManager.getEndDateAndTimeForTask(Integer.parseInt(taskID));
				}
				LOGGER.info("isDeadline is " + isDeadline);
				LOGGER.info("existDateAndTime is " + existDateAndTime);
				
				if (existDateAndTime == null || existDateAndTime.trim().isEmpty()){
					return startEarliest;
				}
				
				switch (InputManager.compareDateAndTime(startEarliest, existDateAndTime)){
				case -2:
					assert (false);
					break;
					
				case -1:
					//it is valid if it is -1
					LOGGER.info("valid startEarliest");
					break;
					
				case 0:
				case 1:
					if (isDeadline){
						InputManager.outputToGui("startDateAndTime ( " + startEarliest + " ) is "
							+ "earlier than existing deadline : " + existDateAndTime);
					} else {
						InputManager.outputToGui("startDateAndTime ( " + startEarliest + " ) is "
								+ "earlier than existing end date and end time : " + existDateAndTime);
					}
					startEarliest = null;
					LOGGER.info("invalid startEarliest");
					break;
				}
			}
		}
		return startEarliest;
	}
	
	/**
	 * putDescInQuotesFirst: find description within " "
	 * @return input string without description or empty string if " " not found
	 */
	protected  String putDescInQuotesFirst(String input){
		Scanner sc = new Scanner(input);
		
		StringBuffer tempDesc = null;
		StringBuffer normalString = new StringBuffer(STRING_EMPTY);
		boolean isStarted = false;
		boolean isFinish = false;
		
		while (sc.hasNext()){
			String buildString = sc.next();
			if (!isFinish){
				if (!isStarted){
					if (buildString.startsWith(STRING_QUOTE)){
						isStarted = true;
						tempDesc = new StringBuffer(buildString);
					} else {
						normalString.append(STRING_SPACE + buildString);
					}
				} else {
					//System.out.println(buildString);
					tempDesc.append(STRING_SPACE + buildString);
					if (buildString.endsWith(STRING_QUOTE)){
						isFinish = true;
					}
				}
			} else {
				normalString.append(STRING_SPACE + buildString);
			}
		}
		sc.close();

		
		if (tempDesc == null){
			tempDesc = new StringBuffer(STRING_EMPTY);
			return tempDesc.toString();
		} else {
			//putOneParameter(PARAMETER_DESCRIPTION, tempDesc.toString());
			tempDesc.append(normalString);
		}
			
		//System.out.println(tempDesc.toString());
		
		return tempDesc.toString();
	}
	
	protected String putDeadline(String param) {	
		if (param.trim().isEmpty()){
			return null;
		}
		
		String token = KEYWORD_DEADLINE + STRING_SPACE + param.trim();
		String tempDead = getDateAndTimeValue(token, POSITION_DATE_DEADLINE , POSITION_TIME_DEADLINE);
		if (tempDead == null){
			return null;
		}
		
		return tempDead;
	}
	
	protected String putStartTime(String param) {
		if (param.trim().isEmpty()){
			return null;
		}
		
		String token = KEYWORD_STARTTIME + STRING_SPACE + param.trim();
		String startResult = getDateAndTimeValue(token, POSITION_DATE_STARTTIME , POSITION_TIME_STARTTIME);

		if (startResult == null){
			return null;
		}
		
		return startResult;
	}
	
	protected String putEndTime(String param) {
		if (param.trim().isEmpty()){
			return null;
		}
		String token = KEYWORD_ENDTiME + STRING_SPACE + param.trim();
		String endResult = getDateAndTimeValue(token, POSITION_DATE_ENDTIME , POSITION_TIME_ENDTIME);

		if (endResult == null){
			return null;
		}
		
		return endResult;
	}
	
	protected String removeFirstChar(String input) {
		return input.replaceFirst(getFirstChar(input), STRING_EMPTY).trim();
	}
	
	protected String getFirstChar(String input) {
		String firstChar = input.trim().split("\\s+")[0];
		return firstChar;
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Command.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\CommandQueue.java
	 */


package com.taskpad.input;

/** Trying to make Command a Singleton class
 * 
 */

import java.awt.Color;
import java.util.Map;

import com.taskpad.alarm.AlarmManager;
import com.taskpad.execute.ExecutorManager;
import com.taskpad.input.CommandTypes.CommandType;

public class CommandQueue {
	
	private static final String STRING_SPACE = " ";
	private static final String STRING_EMPTY = "";
	
	private static final String MESSAGE_TODAYS_REMINDERS = "\nToday's Reminders: ";
	
	private static final CommandQueue _commandInstance = new CommandQueue();

	private CommandQueue(){
	}
	
	protected static CommandQueue getInstance(){
		return _commandInstance;		
	}
	
	/* Methods to perform commands */
	
	protected void Add(String input, String fullInput){
		new Add(input, fullInput);
	}
	
	protected void Alarm(String input, String fullInput){
		new Alarm(input, fullInput);
	}
	
	protected void stopAlarm(String input, String fullInput){
		try {
			AlarmManager.turnOffAlarm();
		} catch (Exception e) {
			return;
		}
	}
	
	protected void Help(){
		new Help();
	}
	
	protected void Exit(){
		InputManager.callGuiExit();
	}
	
	protected void addInfoTask(String input, String fullInput) {
		new Addinfo(input, fullInput);
	}
	
	protected void addRemTask(String input, String fullInput){
		new Addrem(input, fullInput);
	}
	
	protected void listTask(String input, String fullInput){
		new List(input, fullInput);
	}
	
	protected void redoTask(){
		new Redo(STRING_EMPTY, "REDO");
	}
	
	protected void deleteTask(String input, String fullInput) {
		new Delete(input, fullInput);
	}

	protected void doneTask(String input, String fullInput) {
		new Done(input, fullInput);
	}
	
	protected void clearAllTasks() {
		new ClearTasks(STRING_EMPTY, "CLEAR");
	}

	
	protected void undoLast() {
		new Undo(STRING_EMPTY, "UNDO");
	}
	
	protected void editTask(String input, String fullInput) {
		new Edit(input, fullInput);
	}

	protected void searchTask(String input, String fullInput) {
		new Search(input, fullInput);
	}
	
	protected void showRem(){
		InputManager.outputFormatString(MESSAGE_TODAYS_REMINDERS, Color.RED, true);
		ExecutorManager.showReminder();
	}
	
	/* Helper methods to find Command Types */
	
	/** 
	 * This method takes in the first word of input and finds the CommandType
	 * 
	 * @param inputCommand
	 * @return CommandType
	 */
	public static CommandType find(String inputCommand){
		//new CommandTypes();
		CommandTypes.getInstance();
		String variations[];
		
		for (Map.Entry<CommandType, String[]> entry : CommandTypes.commandVariations.entrySet()){
			variations = entry.getValue();
			for (int i=0; i<variations.length; i++){
				if (isValueInputCommand(variations[i], inputCommand)){
					return (CommandType) entry.getKey();
				}
			}
		}
		
		return CommandType.INVALID;
	}
	
	
	/** 
	 * This method takes in the whole input and finds the CommandType
	 * 
	 * @param inputCommand
	 * @return CommandType
	 */
	public static CommandType findFlexi(String input){
		String variations[];
		CommandTypes.getInstance();
		
		for (Map.Entry<CommandType, String[]> entry : CommandTypes.commandVariations.entrySet()){
			variations = entry.getValue();
			for (int i=0; i<variations.length; i++){
				if (isInputSubstring(variations[i], input)){
					return (CommandType) entry.getKey();
				}
			}
		}
		
		return CommandType.INVALID;
	}
	
	protected String[] getFlexiMatch(CommandType command){
		CommandTypes.getInstance();
		String[] flexiMatch = CommandTypes.commandVariations.get(command);
				
		return flexiMatch;
	}
	
	private static boolean isInputSubstring(String value, String input){
		String[] splitInput = input.split(STRING_SPACE);
		for (int i=0; i<splitInput.length; i++){
			if (splitInput[i].toUpperCase().equals(value)){
				//System.out.println(splitInput[i] + " " + value);
				return true;
			}
		}
		return false;
	}
	
	/* deprecated
	private static boolean isContainsInput(String value, String input){
		return input.toUpperCase().contains(value);
	}
	*/
	
	private static boolean isValueInputCommand(String value, String inputCommand) {
		inputCommand = inputCommand.trim();
		if (value.equalsIgnoreCase(inputCommand)){
			return true;
		}
		
		return false;
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\CommandQueue.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\CommandTypes.java
	 */


package com.taskpad.input;

/**
 * CommandTypes has been changed to a Singleton class
 */


import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
 
public class CommandTypes {
	
	protected static Logger logger = Logger.getLogger("TaskPad");
	
	public enum CommandType{
		ADD, ADD_INFO, ADD_REM, ALARM, CLEAR_ALL, CLEAR_SCREEN, 
		DELETE, DONE, EDIT, EXIT, HELP, INVALID, LIST, REDO, SEARCH, SHOW_REM, STOP, UNDO
	};
	
	protected static Map<CommandType, String[]> commandVariations = new HashMap<CommandType, String[]>();
	private static final CommandTypes _commandTypes = new CommandTypes();
	
	private CommandTypes(){
		createHashMap();
	}
	
	public static CommandTypes getInstance(){
		return _commandTypes;
	}

	private static void createHashMap(){
		putAddVariations();
		putAddInfoVariations();
		putAddRemVariations();
		putAlarmVariations();
		putClearVariations();
		putClearScreenVariations();
		putDeleteVariations();
		putDoneVariations();
		putEditVariations();
		putExitVariations();
		putHelpVariations();
		putListVariations();
		putRedoVariations();
		putSearchVariations();
		putShowRemVariations();
		putStopVariations();
		putUndoVariations();
	}
	
	/* Helper methods for creating the hashmap */
	
	private static void putAddVariations(){
		String[] addVariations = {"ADD", "NEW", "CREATE", "INSERT"};
		commandVariations.put(CommandType.ADD, addVariations);
	}
	
	private static void putAddInfoVariations(){
		String[] addInfoVariations = {"ADDINFO", "INFO", "INFORMATION", "CREATEDESC", "ADDDESC", "CREATEINFO", "INFORMATIN", "INFORMATN"};
		commandVariations.put(CommandType.ADD_INFO, addInfoVariations);
	}
	
	private static void putAddRemVariations(){
		String[] addRemVariations = {"ADDR", "REMINDER", "REMIND", "REMAINDER", "ADDREM"};
		commandVariations.put(CommandType.ADD_REM, addRemVariations);
	}
	
	private static void putAlarmVariations() {
		String[] exitVariations = {"ALARM", "ADDALARM", "SETALARM", "SETTIMER", "RING", "CREATEALARM"};
		commandVariations.put(CommandType.ALARM, exitVariations);
	}
	
	private static void putDeleteVariations(){
		String[] deleteVariations = {"DELETE", "DEL", "REMOVE", "REM"};
		commandVariations.put(CommandType.DELETE, deleteVariations);
	}
	
	private static void putDoneVariations(){
		String[] doneVariations = {"DONE", "FINISHED", "COMPLETED", "FINISH", "COMPLETE"};
		commandVariations.put(CommandType.DONE, doneVariations);
	}
	
	private static void putClearVariations(){
		String[] clearVariations = {"CLEAR", "CLR", "CLEAN", "CLC", "CLEARALL"};
		commandVariations.put(CommandType.CLEAR_ALL, clearVariations);
	}
	
	private static void putClearScreenVariations(){
		String[] clearScreenVariations = {"CLEARSCR", "CLEARSCREEN", "CLEARSC", "CLCSR", "CLCSCR", "SCREEN", "SCR"};
		commandVariations.put(CommandType.CLEAR_SCREEN, clearScreenVariations);
	}
	
	private static void putEditVariations(){
		String[] editVariations = {"EDIT", "CHANGE", "ED"};
		commandVariations.put(CommandType.EDIT, editVariations);
	}
	
	private static void putUndoVariations(){
		String[] undoVariations = {"UNDO", "UN", "UDO"};
		commandVariations.put(CommandType.UNDO, undoVariations);
	}
	
	private static void putSearchVariations(){
		String[] searchVariations = {"SEARCH", "FIND"};
		commandVariations.put(CommandType.SEARCH, searchVariations);
	}
	
	private static void putShowRemVariations(){
		String[] showRemVariations = {"SHOWREM", "SHOWREMINDER", "SHOWREMAINDER"};
		commandVariations.put(CommandType.SHOW_REM, showRemVariations);
	}
	
	private static void putStopVariations(){
		String[] stopVariations = {"STOP", "STOPP", "STO"};
		commandVariations.put(CommandType.STOP, stopVariations);
	}
	
	private static void putListVariations(){
		String[] listVariations = {"LIST", "LS", "SHOW", "DISPLAY", "LST"};
		commandVariations.put(CommandType.LIST, listVariations);
	}
	
	private static void putRedoVariations(){
		String[] redoVariations = {"REDO", "RDO", "RE"};
		commandVariations.put(CommandType.REDO, redoVariations);
	}
	
	public static void putHelpVariations(){
		String[] helpVariations = {"HELP", "HLP", "MAN"};
		commandVariations.put(CommandType.HELP, helpVariations);
	}
	
	private static void putExitVariations(){
		String[] exitVariations = {"EXIT", "QUIT", "END", "CLOSE", "SHUTDOWN", "QUT"};
		commandVariations.put(CommandType.EXIT, exitVariations);
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\CommandTypes.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Delete.java
	 */


/**
 * This class creates a Delete object
 * 
 * Current syntax for delete: del <taskID>
 * 
 * Returns Input object
 * 
 */


package com.taskpad.input;

public class Delete extends Command{
	
	private static String COMMAND_DELETE = "DELETE";
	private static String PARAMETER_TASK_ID = "TASKID";
	private static String PARAMETER_KEYWORD = "KEYWORD";
	private static int NUMBER_ARGUMENTS = 1;		//Number of arguments for delete
	
	private String _taskID;
	private String _keyword;

	public Delete(String input, String fullInput) {
		super(input, fullInput);	
	}
	
	@Override
	protected void initialiseOthers(){
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		setCOMMAND(COMMAND_DELETE);	
		
		_taskID = "";
		_keyword = "";
	}
	
	@Override
	protected boolean commandSpecificRun() {
		if (isTaskID(input)){
			_taskID = input.trim();
		} else{
			_keyword = input.trim();
		}
		
		return true;
	}
	
	private boolean isTaskID(String input){
		try{
			Integer.parseInt(input);
			return true;
		} catch (NumberFormatException e){
			return false;
		}
	}

	@Override
	protected void initialiseParametersToNull() {
		inputParameters.put(PARAMETER_TASK_ID, "");		
		inputParameters.put(PARAMETER_KEYWORD, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_TASK_ID, _taskID);
		putOneParameter(PARAMETER_KEYWORD, _keyword);
	}
	
	protected boolean checkIfIncorrectArguments() throws TaskIDException, InvalidParameterException{
		String inputString[] = input.split(" ");
		
		if (isNotNumberArgs(inputString)){
			throw new InvalidParameterException();
		}
		
		return false;
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Delete.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Done.java
	 */


package com.taskpad.input;


public class Done extends Command{
	
	private static final String COMMAND_DONE = "DONE";
	private static final int NUMBER_ARGUMENTS = 1;
	
	private static String PARAMETER_TASK_ID = "TASKID";
	 
	private static String _taskID = "";

	public Done(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_DONE);
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
	}

	@Override
	protected boolean commandSpecificRun() {
		if (isNotValidTaskID(input)){
			return false;
		}
		_taskID = input.trim();
		return true;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_TASK_ID, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_TASK_ID, _taskID);		
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Done.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Edit.java
	 */


package com.taskpad.input;

import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Logger;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidQuotesException;
import com.taskpad.execute.InvalidTaskIdException;

public class Edit extends Command{
	private final static Logger LOGGER = Logger.getLogger("TaskPad");
		
	private static final int NUMBER_ARGUMENTS = 2;

	private static final String COMMAND_EDIT = "EDIT";
	
	private static String PARAMETER_TASK_ID = "TASKID";
	private static String PARAMETER_DESC = "DESC";
	private static String PARAMETER_DEADLINE = "DEADLINE";
	private static String PARAMETER_START_DATE = "START DATE";
	private static String PARAMETER_START_TIME = "START TIME";
	private static String PARAMETER_END_DATE = "END DATE";
	private static String PARAMETER_END_TIME = "END TIME";
	private static String PARAMETER_INFO = "INFO";
	
	private String _taskID;
	private String _desc;
	private String _deadline;
	private String _startDate;
	private String _startTime;
	private String _endDate;
	private String _endTime;
	private String _editInput;
	private String _info;
	
	private int _deadNo;
	private int _endNo;
	private int _startNo;
	private int _infoNo;
	
	private static final String STRING_SPACE = " ";
	private static final String STRING_COMMA = ",";
	private static final String STRING_EMPTY = "";

	public Edit(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		LOGGER.info("initializing...");
		LOGGER.info("NUMBER_ARGUMENTS: " + NUMBER_ARGUMENTS);
		LOGGER.info("COMMAND_EDIT: " + COMMAND_EDIT);
		
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		setCOMMAND(COMMAND_EDIT);
		
		_taskID = null;
		_desc = null;
		_deadline = null;
		_startDate = null;
		_startTime = null;
		_endDate = null;
		_endTime = null;
		_info = null;
		
		_deadNo = 0;
		_startNo = 0;
		_endNo = 0;
		_infoNo = 0;
	}

	@Override
	protected boolean commandSpecificRun() {
		clearInputParameters();
		
		LOGGER.info("input is " + input);
		
		_editInput = fullInput;  
		if(noTaskIDInPosition(fullInput)){
			try {
				_taskID = findTaskID(fullInput);
			} catch (TaskIDException | InvalidQuotesException e) {
				InputManager.outputToGui(e.getMessage());
				LOGGER.severe(e.getMessage());
				return false;
			}
		}
		
		LOGGER.info("taskID is " + _taskID);
		input = removeTaskID(fullInput, _taskID);
		LOGGER.info("input is " + input);
		
		fullInput = _editInput;
		
		if(isDelimitedString(" " + input + " ")){
			String temp = putDescInQuotesFirst(input);
			
			if (!temp.trim().isEmpty()){
				input = temp;
			}
			editDelimitedString();
		} else {
			
			LOGGER.info("taskID is " + _taskID);
			
			try {
				getOtherKeysValue();
			} catch (InvalidTaskIdException e) {
				InputManager.outputToGui("Not a valid TaskID!");
				LOGGER.severe("Not a valid TaskID!");
				return false;
			}
		}

		putInputParameters();
		return true;
	}

	/**
	 * delimited string syntax: edit <taskID> <desc> -d <deadline...> -s <start...> -e <end...>
	 */
	private void editDelimitedString() {
		extractTaskID();
		extractDescription();		
		
		Scanner sc = new Scanner(input);
		sc.useDelimiter("\\s-");
		
		while(sc.hasNext()){
			String nextParam = sc.next().trim();
			
			nextParam = nextParam.replaceFirst("-", STRING_EMPTY);

			parseNextParam(nextParam.trim());
		}
		sc.close();
	}
	
	/**
	 * Check if second word entered is an integer (likely to be taskID)
	 * @param fullInput
	 * @return true if is integer and sets it as taskID
	 */
	private boolean noTaskIDInPosition(String fullInput) {
		String splitInput[] = fullInput.split(STRING_SPACE);
		
		if (isNotValidTaskID(splitInput[1])){
			InputManager.outputToGui(MESSAGE_WARNING_TASKID);
			return true;
		} else {
			int taskID = Integer.parseInt(splitInput[1]);
			_taskID = "" + taskID;
			return false;
		}
		/*
		try{
			int taskID = Integer.parseInt(splitInput[1]);
			_taskID = "" + taskID;
			return false;
		} catch (NumberFormatException e){
			InputManager.outputToGui(MESSAGE_WARNING_TASKID);
			return true;
		}
		*/
	}

	/**
	 * @throws InvalidTaskIdException 
	 * 
	 */
	private void getOtherKeysValue() throws InvalidTaskIdException {
		//String inputString = fullInput;
		//inputString = removeTaskID(inputString, _taskID);
		String inputString = input;
		
		LOGGER.info("getting other parameters value (exclude ID).");
		LOGGER.info("inputString is " + inputString);
		
		String[] fullInputTokens = inputString.split(STRING_COMMA);
		
		for (String token : fullInputTokens){
			String tag = findTag(token);
			
			LOGGER.info("token is " + token);
			LOGGER.info("tag is " + tag);
			
			switch(tag){
				case "DESC":
					token = removeWordDesc(token);
					if (_desc == null){
						_desc = token;
						LOGGER.info("description is " + _desc);
					} else {
						_desc = _desc + STRING_COMMA + token;
						LOGGER.info("description is " + _desc);
					}
					break;
				case "DEADLINE":	
					_deadNo++;
					
					token = removeWordDeadline(token);
					if (token.trim().isEmpty()){
						_deadline = STRING_EMPTY;
						LOGGER.info("deadline is " + _deadline);
						continue;
					}

					token = KEYWORD_DEADLINE + STRING_SPACE + token.trim();
					
					LOGGER.info("after editing, token is " + token);
					String tempDead = getDateAndTimeValue(token, POSITION_DATE_DEADLINE , POSITION_TIME_DEADLINE);
					
					if (tempDead == null){
						continue;
					}
					_deadline = tempDead;
					
					LOGGER.info("deadline is " + _deadline);
					break;
				case "START":	
					_startNo++;
					
					token = removeWordStart(token);
					if (token.trim().isEmpty()){
						_startDate = STRING_EMPTY;
						_startTime = STRING_EMPTY;
						LOGGER.info("_startDate and _startTime is " + STRING_EMPTY);
						continue;
					}

					token = KEYWORD_STARTTIME + STRING_SPACE + token.trim();
					
					LOGGER.info("after editing, token is " + token);
					String startResult = getDateAndTimeValue(token, POSITION_DATE_STARTTIME , POSITION_TIME_STARTTIME);
					LOGGER.info("startResult is " + startResult);

					if (startResult == null){
						continue;
					}
					
					inputStartTimeDate(startResult);
					break;
				case "END":
					_endNo++;
					
					token = removeWordEnd(token);
					if (token.trim().isEmpty()){
						_endDate = STRING_EMPTY;
						_endTime = STRING_EMPTY;
						LOGGER.info("_endDate and _endTime is " + STRING_EMPTY);
						continue;
					}
					
					token = KEYWORD_ENDTiME + STRING_SPACE + token.trim();
						
					LOGGER.info("after editing, token is " + token);
					String endResult = getDateAndTimeValue(token, POSITION_DATE_ENDTIME , POSITION_TIME_ENDTIME);
					LOGGER.info("endResult is " + endResult);

					if (endResult == null){
						continue;
					}
					
					inputEndTimeDate(endResult);
					break;
				case "INFO":
					_infoNo++;
					token = removeWordInfo(token);
					if (_info == null){
						_info = token;
						LOGGER.info("information is " + _info);
					} else {
						_info = _info + STRING_COMMA + token;
						LOGGER.info("information is " + _info);
					}
					break;
				default:
					if (_desc == null){
						_desc = token;
						LOGGER.info("description is " + _desc);
					} else {
						_desc = _desc + STRING_COMMA + token;
						LOGGER.info("description is " + _desc);
					}
					break;
			}
		}
		
		checkDesc();
		
		showErrorWhenActionRepeated(_startNo, _deadNo, _endNo, _infoNo);
	
		boolean isEdit = true;
		ArrayList<String> times =
				checkDeadLineAndEndTime(_startTime, _startDate, _taskID, _deadline, _endTime, _endDate, isEdit);
		String endLatest = times.get(POSITION_TIME_ENDTIME / 2);
		String startEarliest = times.get(POSITION_TIME_STARTTIME / 2);
		_deadline = times.get(POSITION_TIME_DEADLINE / 2);
		
		if (_deadline != null && !_deadline.trim().isEmpty  ()){
			String[] deadTokens = _deadline.split(STRING_SPACE);
			_deadline = deadTokens[1] + STRING_SPACE + deadTokens[0];
		}
		
		if (endLatest == null){
			_endDate = null;
			_endTime = null;
		}
		
		if (startEarliest == null){
			_startDate = null;
			_startTime = null;
		}
	}
	
	/**
	 * Takes in input string and finds the first integer as taskID
	 * @param input
	 * @return taskID
	 * @throws TaskIDException 
	 * @throws InvalidQuotesException 
	 */
	private String findTaskID(String input) throws TaskIDException, InvalidQuotesException{
		String numberInput = DateAndTimeManager.getInstance().parseNumberString(input);

		LOGGER.info("finding TaskID. Converted to numberInput");
		LOGGER.info("numberInput is " + numberInput);
		
		input = numberInput;
		fullInput = numberInput;
		
		LOGGER.info("input is " + input);
		LOGGER.info("fullInput is " + fullInput);
		
		int taskID = -1;
		String[] splitInput = input.split(STRING_SPACE);
		
		for (int i = 0; i < splitInput.length; i++){
			if (taskID == -1){
				String token = splitInput[i];
				if (!isNotValidTaskID(token)){
					taskID = Integer.parseInt(token);
					break;
				}
			}
		}
				
		LOGGER.info("taskID is " + taskID);
		
		if (taskID == -1){
			LOGGER.severe("TASK ID is invalid!");
			throw new TaskIDException();
		}
		
		return "" + taskID;
	}

	/**
	 * 
	 */
	private void checkDesc() {
		if (_desc != null){
			_desc = _desc.trim();
			LOGGER.info("At last, desc is " + _desc);
			
			if (_desc.isEmpty()){
				_desc = null;
			} 
		}
	}

	private String findTag(String fullInput){
		String tag = STRING_EMPTY;
		
		if (containsDesc(fullInput)){
			tag = "DESC";
		} else if (containsDeadline(fullInput)){
			tag = "DEADLINE";
		} else if (containsStart(fullInput)){
			tag = "START";
		} else if (containsEnd(fullInput)){
			tag = "END";
		} else if (containsInfo(fullInput)){
			tag = "INFO";
		}
		
		return tag;		
	}

	@Override
	protected boolean checkIfIncorrectArguments() throws InvalidParameterException, TaskIDException{
		String inputString[] = input.split(STRING_SPACE);
		
		if (isNotNumberArgs(inputString)){
			LOGGER.severe("Throw");
			LOGGER.severe("inputString is " + inputString);
			throw new InvalidParameterException();
		}
			
		return false;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_TASK_ID, STRING_EMPTY);
		putOneParameter(PARAMETER_DESC, STRING_EMPTY);
		putOneParameter(PARAMETER_DEADLINE, STRING_EMPTY);
		putOneParameter(PARAMETER_START_TIME, STRING_EMPTY);
		putOneParameter(PARAMETER_START_DATE, STRING_EMPTY);
		putOneParameter(PARAMETER_END_TIME, STRING_EMPTY);
		putOneParameter(PARAMETER_END_DATE, STRING_EMPTY);
		putOneParameter(PARAMETER_INFO, STRING_EMPTY);
	}

	@Override
	protected void putInputParameters() {
		if (_deadline != null){
			if (! _deadline.trim().isEmpty()){
				String[] tempDeadSplit = _deadline.split(STRING_SPACE);
			
				_deadline = tempDeadSplit[1] + STRING_SPACE + tempDeadSplit[0]; 
			}
			putOneParameter(PARAMETER_DEADLINE, _deadline);
		}
		
		putOneParameter(PARAMETER_TASK_ID, _taskID);
		putOneParameter(PARAMETER_DESC, _desc);		
		putOneParameter(PARAMETER_START_TIME, _startTime);
		putOneParameter(PARAMETER_START_DATE, _startDate);
		putOneParameter(PARAMETER_END_TIME, _endTime);
		putOneParameter(PARAMETER_END_DATE, _endDate);
		putOneParameter(PARAMETER_INFO, _info);
	}
	
	@Override
	protected void putOneParameter(String parameter, String input){
		if (input != null){
			inputParameters.put(parameter, input);
		}
	}
	
	@Override
	protected boolean isNotNumberArgs(String[] inputString){
		if (inputString.length >= getNUMBER_ARGUMENTS()){
			return false;
		}
		return true;
	}
	
	private String removeTaskID(String input, String taskID){
		input = input.replaceFirst("(?i)" + COMMAND_EDIT, "");
		return input.replaceFirst(taskID, "").trim();
	}
	
	@SuppressWarnings("unused")
	private String removeFirstWord(String input){
		return input.replace(getFirstWord(input), "").trim();
	}
	
	private static String getFirstWord(String input) {
		return input.trim().split("\\s+")[0];
	}
	
	private boolean containsDesc(String input){
		String inputCopy = STRING_SPACE + input.toUpperCase() + STRING_SPACE;
		if (inputCopy.contains(" DESC ") || inputCopy.contains(" DESCRIPTION ")){
			return true;
		} 
		return false;
	}
	
	private boolean containsStart(String input){
		String inputCopy = STRING_SPACE + input.toUpperCase() + STRING_SPACE;
		if (inputCopy.contains(" START ")){
			return true;
		} 
		return false;
	}
	
	private boolean containsEnd(String input){
		String inputCopy = STRING_SPACE + input.toUpperCase() + STRING_SPACE;
		if (inputCopy.contains(" END ")){
			return true;
		} 
		return false;
	}
	
	private boolean containsInfo(String input){
		String inputCopy = STRING_SPACE + input.toUpperCase() + STRING_SPACE;
		if (inputCopy.contains(" INFO ") || inputCopy.contains(" INFORMATION ") ||
				inputCopy.contains(" DETAILS ") || inputCopy.contains(" DETAIL ")){
			return true;
		} 
		return false;
	}

	private String removeWordDesc(String inputCopy) {
		String newString = "";
		int count = 0;	//Just replace only one occurrence of description
		
		String[] inputSplit = inputCopy.split(" ");
		for (int i=0; i<inputSplit.length; i++){
			if (isNotDescWord(inputSplit[i].trim())){
				newString += inputSplit[i] + " ";
			} else if (count > 0) {
				newString += inputSplit[i] + " ";
			} else {
				count ++;
			}
		}
		return newString;
	}
	
	private String removeWordInfo(String inputCopy) {
		String newString = "";
		int count = 0;	//Just replace only one occurrence of description
		
		String[] inputSplit = inputCopy.split(" ");
		for (int i=0; i<inputSplit.length; i++){
			LOGGER.info("token is " + inputSplit[i]);
			LOGGER.info("cnt is " + count + " newString is: " + newString);
			if (isNotInfoWord(inputSplit[i].trim())){
				newString += inputSplit[i] + " ";
				LOGGER.info("added notInfoWord: " + newString);
			} else if (count > 0) {
				newString += inputSplit[i] + " ";
				LOGGER.info("added other InfoWord: " + newString);
			} else {
				count ++;
			}
		}
		
		LOGGER.info("after deleting word info : " + newString);
		return newString;
	}
	
	private boolean isNotInfoWord(String string) {
		string = string.toUpperCase();
		return (!string.equals("INFO") &&
				!string.equals("INFORMATION") &&
				!string.equals("DETAILS") &&
				!string.equals("DETAIL"));
	}

	private boolean isNotDescWord(String string) {
		return (!string.toUpperCase().equals("DESC") &&
				!string.toUpperCase().equals("DESCRIPTION"));
	}
	
	private boolean containsDeadline(String input){
		String inputCopy = STRING_SPACE + input.toUpperCase() + STRING_SPACE;
		if (inputCopy.contains(" DEADLINE ") || inputCopy.contains(" DEAD ") || 
				inputCopy.contains(" DATE ") || inputCopy.contains(" -D ")){
			return true;
		} 
		return false;
	}
	
	private String removeWordDeadline(String inputCopy) {
		String newString = "";
		int count = 0;
		String[] inputSplit = inputCopy.split(" ");
		for (int i=0; i<inputSplit.length; i++){
			if (!isDeadlineWord(inputSplit[i].trim())){
				newString += inputSplit[i] + " ";
			} else if (count > 0 ){
				newString += inputSplit[i] + " ";
			} else {
				count++;
			}
		}
		return newString;
	}
	
	private boolean isDeadlineWord(String string) {
		return string.toUpperCase().equals("DEADLINE") || 
				string.toUpperCase().equals("DATE") || 
				string.toUpperCase().equals("DEAD") ||
				string.toUpperCase().equals("-D");
	}

	private String removeWordEnd(String inputCopy) {
		String newString = "";
		int count = 0;	//Just replace only one occurrence of description
		
		String[] inputSplit = inputCopy.split(" ");
		for (int i=0; i<inputSplit.length; i++){
			if (isNotEndWord(inputSplit[i].trim())){
				newString += inputSplit[i] + " ";
			} else if (count > 0) {
				newString += inputSplit[i] + " ";
			} else {
				count ++;
			}
		}
		return newString;
	}
	
	private boolean isNotEndWord(String string) {
		return !string.toUpperCase().equals("END") && !string.toUpperCase().equals("-E");
	}
	
	private void inputStartTimeDate(String result){
		String[] splitResult = result.split(STRING_SPACE);
		_startDate = splitResult[0];
		_startTime = splitResult[1];
	}
	
	private void inputEndTimeDate(String result){
		String[] splitResult = result.split(STRING_SPACE);
		_endDate = splitResult[0];
		_endTime = splitResult[1];
	}

	private String removeWordStart(String inputCopy) {
		String newString = "";
		int count = 0;	//Just replace only one occurrence of description
		
		String[] inputSplit = inputCopy.split(" ");
		for (int i = 0; i < inputSplit.length; i++){
			LOGGER.info("remove " + inputSplit[i] + "?");
			if (isNotStartWord(inputSplit[i].trim())){
				newString += inputSplit[i] + " ";
				LOGGER.info("NO");
				LOGGER.info("newString is " + newString);
			} else if (count > 0) {
				newString += inputSplit[i] + " ";
				LOGGER.info("count is " + count);
				LOGGER.info("NO");
				LOGGER.info("newString is " + newString);
			} else {
				count ++;
				LOGGER.info("YES");
			}
		}
		return newString;
	}
	
	private boolean isNotStartWord(String string) {
		return !string.toUpperCase().equals("START") && !string.toUpperCase().equals("-S");
	}

	private boolean isDelimitedString(String input) {
		if (input.contains(" -s ") || input.contains(" -d ") || 
				input.contains(" -e ") || input.contains(" -i ")){
			return true;
		}
		return false;
	}
	
	private void parseNextParam(String param){
		String firstChar = getFirstChar(param);
		param = removeFirstChar(param).trim();

		switch (firstChar){
			case "d":
				_deadNo++;
				processDeadline(param);
				break;
			case "s":
				_startNo++;
				processStart(param);
				break;
			case "e": 
				_endNo++;
				processEnd(param);
				break;
			case "i":
				_infoNo++;
				processInfo(param);
				break;
		}
		
		LOGGER.info("deadline is " + _deadline );
		LOGGER.info("start time and date is " + _startTime + " " + _startDate);
		LOGGER.info("end time and date is " + _endTime + " " + _endDate);
		
		showErrorWhenActionRepeated(_startNo, _deadNo, _endNo, _infoNo);
	}

	private void processDeadline(String param){
		if (param.isEmpty()){
			return;
		}
		
		String tempDate = putDeadline(param);
		_deadline = swapDeadlinePlaces(tempDate);
	}
	
	private String swapDeadlinePlaces(String deadline){
		String[] tempDead = deadline.split(STRING_SPACE);
		return tempDead[1] + STRING_SPACE + tempDead[0];
	}
	
	private void processEnd(String param){
		if (param.isEmpty()){
			return;
		}
		
		String endResult = putEndTime(param);
		if (endResult != null){
			inputEndResult(endResult);
		}
	}
	
	private void processStart(String param){
		if (param.isEmpty()){
			return;
		}
		
		String startResult = putStartTime(param);
		if (startResult != null){
			inputStartResult(startResult);
		}
	}
	
	private void inputStartResult(String startResult) {
		String[] splitResult = startResult.split(STRING_SPACE);
		_startDate = splitResult[0];
		_startTime = splitResult[1];
	}
	
	private void inputEndResult(String endResult) {
		String[] splitResult = endResult.split(STRING_SPACE);
		_endDate = splitResult[0];
		_endTime = splitResult[1];
	}
	
	private void extractDescription(){
		int index = input.indexOf("-");
		if (index != 0){
			_desc = input.substring(0, index).trim();
			int size = input.length();
			input = input.substring(index, size).trim();
		}
	}
	
	private void processInfo(String param){
		param = param.trim();
		if (param.isEmpty()){
			return;
		}
		_info = param;
	}
	
	/**
	 * =======================================DEPRECATED=================================================================
	 */
	/* Helper methods for delimited string */
	/**
	 * @deprecated
	 */
	private void extractTaskID() {
		/*
		String[] split = input.split(STRING_SPACE);
		_taskID = split[0];
		
		String newInput = STRING_EMPTY;
		for (int i=1; i<split.length; i++){
			newInput += split[i] + STRING_SPACE;
		}
		input = newInput;
		*/
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Edit.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\EmptyDescException.java
	 */


package com.taskpad.input;


import java.util.logging.Logger;

public class EmptyDescException extends Exception {

	/**
	 * generated
	 */
	private static final long serialVersionUID = 886846093768153430L;

	private static final String MESSAGE = "Error: Please enter a description";
	private static Logger logger = Logger.getLogger("TaskPad");

	
	public EmptyDescException(){
		super(MESSAGE);
		logger.info(MESSAGE);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\EmptyDescException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\EmptyStringException.java
	 */


package com.taskpad.input;


import java.util.logging.Logger;

public class EmptyStringException extends Exception {
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = 1091219745520768583L;
	
	private static final String MESSAGE = "Error: Empty String after command";
	
	private static Logger logger = Logger.getLogger("TaskPad");
	
	public EmptyStringException(){
		super(MESSAGE);
		logger.info(MESSAGE);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\EmptyStringException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\ErrorMessages.java
	 */


package com.taskpad.input;

/** Class for all Input error messages for Input Handling
 * 
 */

public class ErrorMessages {
	
	private static final String MESSAGE_EMPTY_INPUT = "Error: Empty input";
	private static String MESSAGE_TIME_ERROR = "Error: Invalid time format: %s. Time format should be hh:mm or hhmm";
	private static final String MESSAGE_INVALID_CONFIRM_INPUT = "Error: Invalid confirmation. Please enter Y or N";
	private static final String MESSAGE_INVALID_TIME = "Invalid time parameter";
	private static final String MESSAGE_INVALID_TASKID = "Invalid Task ID";
	
	private ErrorMessages(){
	}

	protected static void timeErrorMessage(String input){
		String errorMessage = String.format(MESSAGE_TIME_ERROR, input);
		InputManager.outputToGui(errorMessage);
	}
	
	protected static void invalidTimeMessage(){
		InputManager.outputToGui(MESSAGE_INVALID_TIME);
	}
	
	protected static void emptyInputMessage(){
		InputManager.outputToGui(String.format(MESSAGE_EMPTY_INPUT));
	}
	
	protected static void invalidConfirmationInput(){
		InputManager.outputToGui(MESSAGE_INVALID_CONFIRM_INPUT);
	}
	
	protected static void invalidTaskIDMessage(){
		InputManager.outputToGui(MESSAGE_INVALID_TASKID);
	}

	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\ErrorMessages.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Help.java
	 */


/* 
 * This is the class for the command HELP 
 * 
 * Current syntax: help
 * 
 * Output: Output frame shows list of commands and their syntax
 */


package com.taskpad.input;

import java.awt.Color;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map.Entry;


public class Help {

	private static LinkedHashMap<String, String> helpCommands;
	
	private static String KEY_START = "TASKPAD HELP";
	private static String KEY_ADD_TASK = "ADD TASK";
	private static String KEY_ADD_INFO_TASK = "ADD INFO TO TASK";
	private static String KEY_ADD_REM_TASK = "ADD REMINDER";
	private static String KEY_ALARM = "ALARM";
	private static String KEY_CLEAR_DATA = "CLEAR MEMORY";
	private static String KEY_CLEAR_SCREEN = "CLEAR SCREEN";
	private static String KEY_DELETE_TASK = "DELETE TASK";
	private static String KEY_EDIT_TASK = "EDIT TASK DESCRIPTION";
	private static String KEY_EXIT = "EXIT PROGRAM";
	private static String KEY_LIST = "LIST TASKS"; 
	private static String KEY_MARK_DONE = "MARK TASK AS DONE";
	private static String KEY_SEARCH = "SEARCH TASKS";
	private static String KEY_UNDO_LAST_DONE = "UNDO LAST DONE";
	private static String KEY_REDO = "REDO";
	
	protected Help(){
		helpCommands  = new LinkedHashMap<String, String>();
		initialiseCommands();
		outputHelp();
	}
	
	private static void initialiseCommands(){
		helpCommands.put(KEY_START, "Here's a list of commands TaskPad can perform!");
		helpCommands.put(KEY_ADD_TASK, "add <desc> -d <deadline> -s <start time>,<start date> -e <end time>,<end date>");
		helpCommands.put(KEY_ALARM, "alarm <desc> <number> <time unit>");
		helpCommands.put(KEY_CLEAR_DATA, "clc");
		helpCommands.put(KEY_CLEAR_SCREEN, "screen");
		helpCommands.put(KEY_DELETE_TASK, "del <taskID>");
		helpCommands.put(KEY_MARK_DONE, "done <taskID>");
		helpCommands.put(KEY_EDIT_TASK, "edit <taskID> <new desc>");
		helpCommands.put(KEY_ADD_INFO_TASK, "info <taskID> <info>");
		helpCommands.put(KEY_SEARCH, "search <keyword>");
		helpCommands.put(KEY_LIST, "ls <parameter (done, undone, all, dateline)>");
		helpCommands.put(KEY_ADD_REM_TASK, "rem <taskID> <date> <time>");
		helpCommands.put(KEY_UNDO_LAST_DONE, "undo");
		helpCommands.put(KEY_REDO, "redo");
		helpCommands.put(KEY_EXIT, "exit");
	}
	
	protected void outputHelp(){
		InputManager.clearScreen();
		Iterator<Entry<String, String>> it = helpCommands.entrySet().iterator();
		while (it.hasNext()){
			Entry<String, String> entry = it.next();
			formatOutput(entry.getKey(), entry.getValue());
		}		
	}
	
	private static void formatOutput(String key, String value){
		InputManager.outputFormatString(key, Color.BLUE, false);
		InputManager.outputFormatString(value + "\n", Color.BLACK, false);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Help.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Input.java
	 */


package com.taskpad.input;

import java.util.Map;

public class Input {
	
	private static Map<String,String> parameters;
	private static String command;
	
	public Input(String command, Map<String,String> parameters){
		Input.parameters = parameters;
		Input.command = command;
	}
	
	public String getCommand(){
		return Input.command;
	}
	
	public Map<String,String> getParameters(){
		return Input.parameters;
	}
	
	public void addParameter(String parameter, String value){
		Input.parameters.put(parameter, value);
	}
	
	protected void showAll(){
		for (Map.Entry<String, String> entry : parameters.entrySet()){
			System.out.println(entry.getKey() + " " + entry.getValue());
		}
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Input.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InputMain.java
	 */


package com.taskpad.input;

import java.util.logging.Logger;

import com.taskpad.input.CommandTypes.CommandType;

public class InputMain {

	private static final String MESSAGE_INVALID_COMMAND = "Invalid Command: %s ";
	
	private static final String STRING_EMPTY = "";
			
	private static boolean hasCheckedFlexi = false;
		
	private static Logger logger = Logger.getLogger("TaskPad");
	
	protected static String receiveInput(String input){
		hasCheckedFlexi = false;
		input = input.trim();
		String outputString = STRING_EMPTY;

		if (errorIfNoInput(input)){
			ErrorMessages.emptyInputMessage();
		}
		
		String inputCopy = input;
		String commandTypeString = parseInput(inputCopy);
		CommandTypes.CommandType commandType = determineCommandType(commandTypeString);
		logger.info("Command: " + commandType.toString());
		
		if (isValidCommandType(commandType)){		
			commandTypeString = removeFirstWord(input);
			outputString = commandType.toString() + " " + commandTypeString;
			performCommand (commandType, commandTypeString, input);
			
		} else if (hasCheckedFlexi){
			invalidCommand(input);
			outputString += commandType.toString();
			
		} else if (!hasCheckedFlexi){
			hasCheckedFlexi = true;
			outputString = flexiCommand(input);
		}
		return outputString;
	}
	
	private static boolean errorIfNoInput(String input) {
		return input.equals(STRING_EMPTY);
	}

	private static boolean isValidCommandType(CommandType commandType) {
		return !commandType.equals(CommandType.INVALID);
	}

	private static void performCommand(CommandType commandType, String commandTypeString, String input) {
		switch(commandType){
			case ADD:
				CommandQueue.getInstance().Add(commandTypeString, input);
				break;
			case ALARM:
				CommandQueue.getInstance().Alarm(commandTypeString, input);
				break;
			case ADD_INFO:
				CommandQueue.getInstance().addInfoTask(commandTypeString, input);
				break;
			case ADD_REM:
				CommandQueue.getInstance().addRemTask(commandTypeString, input);
				break;
			case LIST:
				CommandQueue.getInstance().listTask(commandTypeString, input);
				break;
			case CLEAR_ALL:
				CommandQueue.getInstance().clearAllTasks();
				break;
			case CLEAR_SCREEN:
				InputManager.clearScreen();
				break;
			case DELETE:
				CommandQueue.getInstance().deleteTask(commandTypeString, input);
				break;
			case DONE:
				CommandQueue.getInstance().doneTask(commandTypeString, input);
				break;
			case EDIT:
				CommandQueue.getInstance().editTask(commandTypeString, input);
				break;
			case SEARCH:
				CommandQueue.getInstance().searchTask(commandTypeString, input);
				break;
			case STOP:
				CommandQueue.getInstance().stopAlarm(commandTypeString, input);
				break;
			case SHOW_REM:
				CommandQueue.getInstance().showRem();
				break;
			case HELP:
				CommandQueue.getInstance().Help();
				break;
			case EXIT:
				CommandQueue.getInstance().Exit();
				break;
			case REDO:
				CommandQueue.getInstance().redoTask();
				break;
			case UNDO:
				CommandQueue.getInstance().undoLast();
				break;
			default:
				invalidCommand(commandTypeString);
				break;
		}
	}

	private static String flexiCommand(String input) {
		hasCheckedFlexi = true; 
		CommandType command = CommandQueue.findFlexi(input);
		logger.info("Flexicommands: " + command.toString());
		
		if (isValidCommandType(command)){
			String inputString = replaceCommandWord(input, command);
			performCommand(command, inputString, input);
			
			return command.toString() + " " + inputString;
		} else {
			//throw new EmptyStringException();
			invalidCommand(input);
			return command.toString();
		}
	}
	
	private static String replaceCommandWord (String input, CommandType command){
		String desc = STRING_EMPTY;
		String[] splitInput = input.split(" ");
		String[] commandVariations = CommandQueue.getInstance().getFlexiMatch(command);
		
		String commandVar = findCommandVariationInString(commandVariations, splitInput);
		desc = replaceCommandStr(commandVar, splitInput);
		
		return desc;
	}
	
	private static String replaceCommandStr(String commandVar,
			String[] splitInput) {
		String desc = STRING_EMPTY;
		for (int i=0; i<splitInput.length; i++){
			if (isNotCommandString(commandVar, splitInput, i)){
				desc += splitInput[i] + " ";
			}
		}
		return desc;
	}

	private static String findCommandVariationInString(String[] commandVariations, 
			String[] splitInput){
		
		for (int i = 0; i < splitInput.length; i++){
			for (int j = 0; j < commandVariations.length; j++){
				if (isEqualStrings(splitInput[i], commandVariations[j])){
					return commandVariations[j];
				}
			}
		}
		return null;
	}

	private static boolean isEqualStrings(String inputString, String command){
		return inputString.toUpperCase().equals(command);
	}
	
	private static boolean isNotCommandString(String commandVar,
			String[] splitInput, int i) {
		return !splitInput[i].toUpperCase().equals(commandVar.toString());
	}
	
	private static void invalidCommand(String input) {
		InputManager.outputToGui(String.format(MESSAGE_INVALID_COMMAND, input));	
	}

	private static CommandTypes.CommandType determineCommandType(String commandTypeString) {
		String commandToFind = getFirstWord(commandTypeString);
		CommandTypes.CommandType commandType = CommandQueue.find(commandToFind);
		
		return commandType;
	}

	private static String parseInput(String input) {
		if (isInvalidCommand(input)){
			return invalidInput(input);
		}
		
		String commandTypeString = getFirstWord(input);
		return commandTypeString;			
	}
	
	/* Helper methods for parsing commands */ 
	private static boolean isInvalidCommand(String userCommand) {
		if (userCommand.trim().equals(STRING_EMPTY)){
			return true;
		}
		return false;
	}
	
	private static String invalidInput(String input) {
		return String.format(MESSAGE_INVALID_COMMAND, input);
	}
	
	private static String removeFirstWord(String input) {
		return input.replaceFirst(getFirstWord(input), STRING_EMPTY).trim();
	}
	
	private static String getFirstWord(String input) {
		String commandTypeString = input.trim().split("\\s+")[0];
		return commandTypeString;
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InputMain.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InputManager.java
	 */


/** This class is used for calling APIs from other packages
 * 
 */

package com.taskpad.input;

import java.awt.Color;
import java.util.ArrayList;
import java.util.logging.Logger;

import com.taskpad.storage.DataManager;
import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.execute.ExecutorManager;
import com.taskpad.execute.InvalidTaskIdException;
import com.taskpad.ui.GuiManager;


public class InputManager {
	
	private static final String STATUS_CLEAR = "Clear GUI Screen";
	private static final String STATUS_EXECUTOR = "Passed to Executor";
	private static final String STATUS_EXIT = "Exit program";
	private static final String STATUS_GUI_OUTPUT = "Output to GUI: %s";
	
	private static final String STRING_NULL = "";
	
	private static boolean _isDebug = false;
	private static ArrayList<Input> _debugStor = null;
	
	protected static final Logger LOGGER = Logger.getLogger("TaskPad");

	
	public static String receiveFromGui(String inputString){
		String outputString = STRING_NULL;
		outputString = InputMain.receiveInput(inputString);
		return outputString;
	}

	protected static String outputToGui(String outputString){
		if (!_isDebug){
			GuiManager.callOutput(outputString);
		}else {
			System.out.println(String.format(STATUS_GUI_OUTPUT, outputString));
		}
		return String.format(STATUS_GUI_OUTPUT, outputString);
	}
	
	protected static String outputFormatString(String outputString, Color c, boolean isBold){
		GuiManager.showSelfDefinedMessage(outputString, c, isBold);
		return String.format(STATUS_GUI_OUTPUT, outputString);
	}
	
	protected static String callGuiExit(){
		GuiManager.callExit();
		return STATUS_EXIT;
	}
	
	protected static String clearScreen(){
		if (!_isDebug){
			GuiManager.clearOutput();
		}else {
			System.out.println(STATUS_CLEAR);
		}
		return STATUS_CLEAR;
	}
	
	protected static String getStartDateAndTimeForTask(int taskId) throws InvalidTaskIdException{
		if (_isDebug && _debugStor != null){
			taskId--;
			if (taskId >= _debugStor.size() || taskId < 0){
				throw new InvalidTaskIdException();
			}
			
			Input storedID = _debugStor.get(taskId);
			String startDate = storedID.getParameters().get("START DATE");
			String startTime = storedID.getParameters().get("START TIME");
			if (startDate == null || startTime == null){
				return null;
			}
			
			return startDate + " " + startTime;
		}
		
		return ExecutorManager.getStartDateAndTimeForTask(taskId);
	}
	
	protected static String getEndDateAndTimeForTask(int taskId) throws InvalidTaskIdException{
		if (_isDebug && _debugStor != null){
			taskId--;
			if (taskId >= _debugStor.size() || taskId < 0){
				throw new InvalidTaskIdException();
			}
			
			Input storedID = _debugStor.get(taskId);
			String endDate = storedID.getParameters().get("END DATE");
			String endTime = storedID.getParameters().get("END TIME");
			if (endDate == null || endTime == null){
				return null;
			}
			
			return endDate + " " + endTime;
		}
		
		return ExecutorManager.getEndDateAndTimeForTask(taskId);
	}
	
	protected static String getDeadlineForTask(int taskId) throws InvalidTaskIdException{
		if (_isDebug && _debugStor != null){
			taskId--;
			if (taskId >= _debugStor.size() || taskId < 0){
				throw new InvalidTaskIdException();
			}
			
			Input storedID = _debugStor.get(taskId);
			String deadline = storedID.getParameters().get("DEADLINE");
			
			return deadline;
		}
		
		return ExecutorManager.getDeadlineForTask(taskId);
	}
	
	/**
	 * compare the input date with startTime and now
	 * @param now
	 * @param startEarliest
	 * @param dateLatest
	 * @return Date: null if smaller or equal, original date if bigger
	 */
	protected static String checkDateAndTimeWithStart(String startEarliest,
			String dateLatest) {
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		return datm.checkDateAndTimeWithStart(startEarliest, dateLatest);
	}
	
	protected static void passToExecutor(Input input, String fullInput){
		if (!_isDebug){
			ExecutorManager.receiveFromInput(input, fullInput);
			LOGGER.info(STATUS_EXECUTOR);
		} else {
			formatInputForTest(input);
		}
	}
	
	private static void formatInputForTest(Input input){
		input.showAll();
	}
	
	protected static int retrieveNumberOfTasks(){
		return DataManager.retrieveNumberOfTasks();
	}
	
	public static void setDebug(boolean debug){
		_isDebug = debug;
	}
	
	public static void setDebug(boolean debug, ArrayList<Input> debugStor){
		setDebug(debug);
		_debugStor = debugStor;
	}
	
	/**
	 * CompareDateAndTime(String, String) : compare two date and time, 
	 * can accept date only. Return -2, if it is not date or date and time
	 * @param firstDateString the first date you want to compare
	 * @param secondDateString the second date you want to compare
	 * @return int: if int > 0, first is bigger; int < 0, first is smaller; int = 0, both are equal
	 */
	public static int compareDateAndTime(String firstDateString, String secondDateString){
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		return datm.compareDateAndTime(firstDateString, secondDateString);
	}
	
	/**
	 * compareDateAndTime(String) : compare the user's date and today 23:59
	 * can accept date only. Return -2, if it is not date or date and time
	 * @param dateString the date you want to compare
	 * @return int: if int > 0, first is bigger; int < 0, first is smaller; int = 0, both are equal
	 */
	public static int compareDateAndTime(String dateString){
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		return datm.compareDateAndTime(dateString);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InputManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InvalidParameterException.java
	 */


package com.taskpad.input;



import java.util.logging.Logger;

public class InvalidParameterException extends Exception {
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = -5161609461075304008L;
	private static final String MESSAGE = "Error: Invalid Number of Parameters. Type Help if you need! :) ";
	
	private static Logger logger = Logger.getLogger("TaskPad");

	public InvalidParameterException(String message) {
		super(MESSAGE);
		logger.info(MESSAGE);
	}
	
	public InvalidParameterException(){
		super(MESSAGE);
		logger.info(MESSAGE);
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\InvalidParameterException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\List.java
	 */


/**
 * This class creates a List Object
 * 
 * Current syntax for list: list <argument>
 * 
 * Returns input object
 */



package com.taskpad.input;

import java.util.HashMap;
import java.util.Map;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidDateException;

public class List extends Command{

	private static String COMMAND_LIST = "LIST";
	private static String PARAMETER_LIST_KEY = "KEY";
	private static String PARAMETER_DEADLINE = "DEADLINE";
	private String parameterList = "";
	
	private static final String[] PARAMETER_VALID_LIST = {"ALL", "DONE", "UNDONE"};
	private Map<String, String[]> parametersMap;
	
	private static final String MESSAGE_INVALID_PARAMETER = "Error: Invalid List Parameter. Type help if you need! :)";
	
	private static int NUMBER_ARGUMENTS = 1;
	
	private boolean _isDeadline = false;
	
	public List(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_LIST);
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		
		parametersMap = new HashMap<String, String[]>();
		initialiseParametersMap();
		_isDeadline = false;
	}

	@Override
	protected boolean commandSpecificRun() {
		//input = DateAndTimeManager.getInstance().formatDateAndTimeInString(input);
		if(checkIfDateline()){
			return true; 
		}
		
		if (isInvalidListParameter()){
			outputInvalidParameter();
			return false;
		}else {
			return true;	
		}
	}

	//Initialise default value
	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_LIST_KEY, "");
		putOneParameter(PARAMETER_DEADLINE, "");
	}

	@Override
	protected void putInputParameters() {
		if (_isDeadline){
			putOneParameter(PARAMETER_DEADLINE, parameterList);		
		} else{
			putOneParameter(PARAMETER_LIST_KEY, parameterList);		
		}
	}
	
	@Override
	protected boolean checkIfIncorrectArguments(){
		return false;
	}	

	/* This method sets the default parameter ALL to the list parameter
	 * 	 
	 * @return false 
	 */
	
	@Override
	protected boolean checkIfEmptyString(){
		if(isEmptyString()){
			input = PARAMETER_VALID_LIST[0];
		}
		return false;
	}
	
	private void initialiseParametersMap(){
		initialiseAllVariations();
		initialiseDoneVariations();
		initialiseUndoneVariations();
	}
	
	private boolean isInvalidListParameter(){
		String listVariations[];
		
		for (Map.Entry<String, String[]> entry : parametersMap.entrySet()){
			listVariations = entry.getValue();
			for (int i=0; i<listVariations.length; i++){
				if (isInputFound(listVariations[i])){
					parameterList = entry.getKey();
					return false;
				}
			}
		}
		return true;
	}
	
	private boolean isInputFound(String value){
		if (value.equalsIgnoreCase(input)){
			return true;
		}
		return false;
	}
	
	/**
	 * For listing by deadline 
	 * Check if Dateline then input into map
	 * @return isDeadline
	 */
	private boolean checkIfDateline() {		
		try {
			String deadline = DateAndTimeManager.getInstance().parseDate(input);
			//putOneParameter(PARAMETER_LIST_KEY, deadline);
			parameterList = deadline;
			_isDeadline = true;
		} catch (InvalidDateException e) {
			//GuiManager.callOutput(e.getMessage());
			_isDeadline = false;
		}
		
		return _isDeadline;
	}
	
	private void initialiseAllVariations(){
		String[] allVariations = {"ALL", "EVERYTHING", "WHOLE", "-A", "-AL"};
		parametersMap.put(PARAMETER_VALID_LIST[0], allVariations);
	}
	
	private void initialiseDoneVariations(){
		String[] doneVariations = {"DONE", "COMPLETED", "FINISHED", "FINISH", "-D"};
		parametersMap.put(PARAMETER_VALID_LIST[1], doneVariations);
	}
	
	private void initialiseUndoneVariations(){
		String[] undoneVariations = {"UNDONE", "INCOMPLETE", "UNFINISH", "UNFINISHED", "-UD"};
		parametersMap.put(PARAMETER_VALID_LIST[2], undoneVariations);
	}
	
	private void outputInvalidParameter(){
		InputManager.outputToGui(MESSAGE_INVALID_PARAMETER);
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\List.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Redo.java
	 */


package com.taskpad.input;



public class Redo extends Command{
	
	private final static String COMMAND_REDO = "REDO";
	private static String PARAMETER_REDO = "";

	public Redo(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_REDO);
	}
	
	@Override
	public void run(){
		clearInputParameters();
		initialiseParametersToNull();
		putInputParameters();
		createInputObject();
		passObjectToExecutor();
	}

	@Override
	protected boolean commandSpecificRun() {
		return true;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_REDO, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_REDO, "");		
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Redo.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Search.java
	 */


package com.taskpad.input;



import java.util.ArrayList;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidQuotesException;

public class Search extends Command{
	
	private static final String STRING_DELIMITERS = "&";
	private static final String COMMAND_SEARCH = "SEARCH";
	private static final int NUMBER_ARGUMENTS = 1;
	
	private static String PARAMETER_KEYWORD = "KEYWORD";
	private static String _keyword;
	
	private static String PARAMETER_TIME = "TIME";
	private static String _time = null;

	public Search(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setNUMBER_ARGUMENTS(NUMBER_ARGUMENTS);
		setCOMMAND(COMMAND_SEARCH);
	}

	@Override
	public void run(){
		try {
			if (checkIfEmptyString()){
				return; 
			}
		} catch (EmptyStringException e) {
			InputManager.outputToGui(e.getMessage());
			return;
		}
		
		initialiseParametersToNull();
		commandSpecificRun();
		putInputParameters();
		createInputObject();
		passObjectToExecutor();
	}
	
	@Override
	protected boolean commandSpecificRun() {
		_keyword = input;
		
		extractTime();
		
		//checkAndInputDeadline();
		
		return true;
	}

	/**
	 * replaced checkAndInputDeadline();
	 * get _time varaible
	 */
	private void extractTime() {
		DateAndTimeManager datm = DateAndTimeManager.getInstance();
		try {
			ArrayList<String> timesArray = datm.searchTimeAndDate(input);
			_time = getTime(timesArray);
		} catch (InvalidQuotesException e) {
			_time = null;
		}
		//System.out.println(_time);
	}

	private String getTime(ArrayList<String> timesArray) {
		StringBuffer timeBuilder = new StringBuffer();
		for (int i = 0; i < timesArray.size(); i++){
			String token = timesArray.get(i);
			timeBuilder.append(token + STRING_DELIMITERS);
		}
		int deleteIdx = timeBuilder.lastIndexOf(STRING_DELIMITERS);
		
		if (deleteIdx > -1){
			timeBuilder.deleteCharAt(deleteIdx);
		}
		
		return timeBuilder.toString().trim();
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_KEYWORD, "");
		putOneParameter(PARAMETER_TIME, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_KEYWORD, _keyword);
		
		if (_time != null){
			putOneParameter(PARAMETER_TIME, _time);
		}
	}
	

	@Override
	protected boolean checkIfIncorrectArguments(){
		return false;
	}
	
	/**
	 * @deprecated
	 */
	@SuppressWarnings("unused")
	private void checkAndInputDeadline(){	
		try {
			_keyword += DateAndTimeManager.getInstance().formatDateAndTimeInString(input);
		} catch (InvalidQuotesException e) {
			InputManager.outputToGui(e.getMessage());
			return;
		}
		
		/*
		for (int i=0; i<splitInput.length; i++){
			dateObject = DateAndTimeManager.getInstance().findDate(splitInput[i].trim());
			if (dateObject != null){
				_keyword += " " + dateObject.getParsedDate();
			}
		}
		*/
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Search.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\TaskIDException.java
	 */


package com.taskpad.input;

import java.util.logging.Logger;

/**
 * Exception for when TaskID larger than number of tasks in storage
 *
 */


public class TaskIDException extends Exception {
	
	/**
	 * generated
	 */
	private static final long serialVersionUID = -1929853963909529411L;
	private static final String MESSAGE = "Error: Invalid TaskID";
	
	private static Logger logger = Logger.getLogger("TaskPad");
	
	public TaskIDException(){
		super(MESSAGE);
		logger.info(MESSAGE);
	}
	
	public TaskIDException(String message){
		super(MESSAGE + ": " + message);
		logger.info(MESSAGE);
	}
	
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\TaskIDException.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Undo.java
	 */


package com.taskpad.input;



public class Undo extends Command{

	private final static String COMMAND_UNDO = "UNDO";
	
	private static String PARAMETER_UNDO = "";
	
	public Undo(String input, String fullInput) {
		super(input, fullInput);
	}
	
	@Override
	protected void initialiseOthers(){
		setCOMMAND(COMMAND_UNDO);
	}

	@Override
	public void run(){
		clearInputParameters();
		initialiseParametersToNull();
		putInputParameters();
		createInputObject();
		passObjectToExecutor();
	}
	
	@Override
	protected boolean commandSpecificRun() {
		return true;
	}

	@Override
	protected void initialiseParametersToNull() {
		putOneParameter(PARAMETER_UNDO, "");
	}

	@Override
	protected void putInputParameters() {
		putOneParameter(PARAMETER_UNDO, "");
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\input\Undo.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\LogManager.java
	 */


package com.taskpad.launcher;



import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;


/** This class is to set up global logging to a file
 */
public class LogManager {

	private static String _taskpad = "TaskPad";
	
	//Lynnette: try using Logger.GLOBAL_LOGGER_NAME instead of our hard coded name. :) 
	private static Logger _logger = Logger.getLogger(_taskpad);
	private static FileHandler _fh;
	
	private static LogManager _logManager = new LogManager();
	
	private LogManager(){
		
	}
	
	protected static LogManager getInstance(){
		return _logManager;
	}
	
	protected void setUpGlobalLogger(){
		//Set up logging to file 

		createFileName();
		
		try{
			createFileHandler();
			createAndSetFormatter();
			initializeLogger();
		} catch (SecurityException e){
			e.printStackTrace();
		} catch (IOException e){
			e.printStackTrace();
		}
		
		/*
		//Redirect System.out
		File file = new File(pattern);
	    PrintStream outPS = null;
		try {
			outPS = new PrintStream(
		         new BufferedOutputStream(
		            new FileOutputStream(file, true)));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}  // append is true
		System.setErr(outPS);    // redirect System.err
		System.setOut(outPS);
		*/
	}
	
	private static void initializeLogger() {
		_logger.addHandler(_fh);
	}

	private static void createAndSetFormatter() {
		SimpleFormatter simpleFormatter = new SimpleFormatter();
		_fh.setFormatter(simpleFormatter);
	}

	private static void createFileHandler() throws IOException {
		_fh = new FileHandler(_taskpad + ".log");
	}
	
	private static void createFileName(){
		_taskpad = _taskpad + "_" + getCurrentDate();
		_taskpad.replaceAll("/", "");
		_taskpad.replaceAll(":", "");
	}
	
	private static String getCurrentDate(){
		SimpleDateFormat formater = new SimpleDateFormat("dd.MM.yyyy");
		Date today = new Date();
		return formater.format(today);
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\launcher\LogManager.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestCommands.java
	 */


package com.taskpad.tests;

/**
 * This class is to test the command words
 */

import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.input.CommandQueue;
import com.taskpad.input.CommandTypes;
import com.taskpad.input.CommandTypes.CommandType;

public class TestCommands {
	
	/**
	 * Testing Invalid commands
	 */
	
	@Test
	public void testCommandInvalid(){
		testFindValueCommand(CommandType.INVALID, "");
		testFindValueCommand(CommandType.INVALID, " ");
		testFindValueCommand(CommandType.INVALID, "hello");
		testFindValueCommand(CommandType.INVALID, "HELLO");
		testFindValueCommand(CommandType.INVALID, "\n");
	}
	
	/**
	 * Testing add commands
	 */
	@Test
	public void testCommandAdd(){
		testFindValueCommand(CommandType.ADD, "add");
		testFindValueCommand(CommandType.ADD, "ADD");
		testFindValueCommand(CommandType.ADD, "aDd");
		testFindValueCommand(CommandType.ADD, "aDD");
		
		testFindValueCommand(CommandType.ADD, "new");
		testFindValueCommand(CommandType.ADD, "NEW");
		testFindValueCommand(CommandType.ADD, "neW");
		testFindValueCommand(CommandType.ADD, "NeW");

		testFindValueCommand(CommandType.ADD, "create");
		testFindValueCommand(CommandType.ADD, "CREATE");
		testFindValueCommand(CommandType.ADD, "cReaTe");
		testFindValueCommand(CommandType.ADD, "cREATe");

		testFindValueCommand(CommandType.ADD, "insert");
		testFindValueCommand(CommandType.ADD, "INSERT");
		testFindValueCommand(CommandType.ADD, "iNseRt");
		testFindValueCommand(CommandType.ADD, "InSErT");
	}
	
	/**
	 * Testing add info command
	 */
	
	@Test
	public void testCommandAddInfo(){
		testFindValueCommand(CommandType.ADD_INFO, "ADDINFO");
		testFindValueCommand(CommandType.ADD_INFO, "addinfo");
		testFindValueCommand(CommandType.ADD_INFO, "addINFO");

		testFindValueCommand(CommandType.ADD_INFO, "INFO");
		testFindValueCommand(CommandType.ADD_INFO, "info");
		testFindValueCommand(CommandType.ADD_INFO, "INfo");

		testFindValueCommand(CommandType.ADD_INFO, "INFORMATION");
		testFindValueCommand(CommandType.ADD_INFO, "INFORMATIN");
		testFindValueCommand(CommandType.ADD_INFO, "INFORMATN");

		testFindValueCommand(CommandType.ADD_INFO, "ADDDESC");
		
		testFindValueCommand(CommandType.ADD_INFO, "CREATEDESC");
		
		testFindValueCommand(CommandType.ADD_INFO, "CREATEINFO");

	}
	
	/**
	 * Test add reminder
	 */
	@Test
	public void testCommandAddRem(){
		testFindValueCommand(CommandType.ADD_REM, "ADDR");
		
		testFindValueCommand(CommandType.ADD_REM, "REMIND");

		testFindValueCommand(CommandType.ADD_REM, "REMINDER");

		testFindValueCommand(CommandType.ADD_REM, "REMAINDER");
		testFindValueCommand(CommandType.ADD_REM, "ADDREM");

	}
	
	/**
	 * Test alarm
	 */
	@Test
	public void testCommandAlarm(){
		testFindValueCommand(CommandType.ALARM, "ALARM");
		
		testFindValueCommand(CommandType.ALARM, "ADDALARM");
		
		testFindValueCommand(CommandType.ALARM, "SETALARM");

		testFindValueCommand(CommandType.ALARM, "CREATEALARM");
		
		testFindValueCommand(CommandType.ALARM, "RING");
		
		testFindValueCommand(CommandType.ALARM, "SETTIMER");
	}
	
	/**
	 * Test stop alarm
	 */
	@Test
	public void testCommandStop(){
		testFindValueCommand(CommandType.STOP, "STOP");
		testFindValueCommand(CommandType.STOP, "STOPP");
		testFindValueCommand(CommandType.STOP, "STO");
	}
	
	/**
	 * Test clear data
	 */
	@Test
	public void testCommandClear(){
		testFindValueCommand(CommandType.CLEAR_ALL, "CLEAR");
		testFindValueCommand(CommandType.CLEAR_ALL, "CLR");
		testFindValueCommand(CommandType.CLEAR_ALL, "CLC");
		testFindValueCommand(CommandType.CLEAR_ALL, "CLEAN");
		testFindValueCommand(CommandType.CLEAR_ALL, "CLEARALL");
	}
	
	/**
	 * Test clear screen
	 */
	@Test
	public void testCommandClearScr(){
		testFindValueCommand(CommandType.CLEAR_SCREEN, "CLCSR");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "CLCSCR");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "SCREEN");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "CLEARSCR");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "CLEARSCREEN");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "CLEARSC");
	}
	
	/**
	 * Test Delete
	 */
	@Test
	public void testCommandDelete(){
		testFindValueCommand(CommandType.DELETE, "DELETE");
		testFindValueCommand(CommandType.DELETE, "DEL");
		testFindValueCommand(CommandType.DELETE, "REMOVE");
		testFindValueCommand(CommandType.DELETE, "REM");
	}
	
	/**
	 * Test edit 
	 */
	@Test
	public void testCommandEdit(){
		testFindValueCommand(CommandType.EDIT, "EDIT");
		testFindValueCommand(CommandType.EDIT, "CHANGE");
		testFindValueCommand(CommandType.EDIT, "ED");
	}
	
	/**
	 * Test search
	 */
	@Test
	public void testCommandSearch(){
		testFindValueCommand(CommandType.SEARCH, "SEARCH");
		testFindValueCommand(CommandType.SEARCH, "FIND");
	}
	
	/**
	 * Test list 
	 */
	@Test
	public void testCommandList(){
		testFindValueCommand(CommandType.LIST, "LIST");
		testFindValueCommand(CommandType.LIST, "LS");
		testFindValueCommand(CommandType.LIST, "LST");
		testFindValueCommand(CommandType.LIST, "SHOW");
		testFindValueCommand(CommandType.LIST, "DISPLAY");
	}
	
	/**
	 * Test redo
	 */
	@Test
	public void testCommandRedo(){
		testFindValueCommand(CommandType.REDO, "REDO");
		testFindValueCommand(CommandType.REDO, "RDO");
		testFindValueCommand(CommandType.REDO, "RE");
	}
	
	/**
	 * Test done
	 */
	@Test
	public void testCommandDone(){
		testFindValueCommand(CommandType.DONE, "DONE");
		testFindValueCommand(CommandType.DONE, "FINISH");
		testFindValueCommand(CommandType.DONE, "FINISHED");
		testFindValueCommand(CommandType.DONE, "COMPLETE");
		testFindValueCommand(CommandType.DONE, "COMPLETED");
	}
	
	/**
	 * Test undo
	 */
	@Test
	public void testCommandUndo(){
		testFindValueCommand(CommandType.UNDO, "UNDO");
		testFindValueCommand(CommandType.UNDO, "UN");
		testFindValueCommand(CommandType.UNDO, "UDO");
	}
	
	/**
	 * Test exit
	 */
	@Test
	public void testCommandExit(){
		testFindValueCommand(CommandType.EXIT, "EXIT");
		testFindValueCommand(CommandType.EXIT, "QUIT");
		testFindValueCommand(CommandType.EXIT, "CLOSE");
		testFindValueCommand(CommandType.EXIT, "END");
		testFindValueCommand(CommandType.EXIT, "SHUTDOWN");
	}
	
	/**
	 * Test help
	 */
	@Test
	public void testCommandHelp(){
		testFindValueCommand(CommandType.HELP, "HELP");
		testFindValueCommand(CommandType.HELP, "HLP");
		testFindValueCommand(CommandType.HELP, "MAN");
	}
	
	/** 
	 * Testing Any order of Commands
	 */
	@Test
	public void testCommand() {		
		//invalid
		testFindValueCommand(CommandType.INVALID, "");
		testFindValueCommand(CommandType.INVALID, " ");
		
		//valid commands
		testFindValueCommand(CommandType.ADD, "add");
		testFindValueCommand(CommandType.ADD, "NEw");
		testFindValueCommand(CommandType.ADD, "Create");
		testFindValueCommand(CommandType.ADD, "add ");
		
		testFindValueCommand(CommandType.DELETE, "delete");
		testFindValueCommand(CommandType.DELETE, "   del\n");
		testFindValueCommand(CommandType.DELETE, "   del");
		
		testFindValueCommand(CommandType.ADD_INFO, "ADDINFO");
		
		testFindValueCommand(CommandType.DONE, "done");
		
		testFindValueCommand(CommandType.CLEAR_ALL, "clr");
		
		testFindValueCommand(CommandType.EDIT, "edit");
		
		testFindValueCommand(CommandType.UNDO, "undo");
		
		testFindValueCommand(CommandType.SEARCH, "find");
		
		testFindValueCommand(CommandType.LIST, "ls");
		
		testFindValueCommand(CommandType.HELP, "HELP");
		
		testFindValueCommand(CommandType.EXIT, "quIT");
	}
	
	private void testFindValueCommand (CommandTypes.CommandType expected, String input){
		//new CommandTypes();
		CommandTypes.getInstance();
		assertEquals(expected, CommandQueue.find(input));
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestCommands.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDateParser.java
	 */


package com.taskpad.tests;


import static org.junit.Assert.*;

import java.text.ParseException;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidDateException;

/**
 * tested all possible paths in DateParser
 * but not tested all the formats yet
 *
 */
public class TestDateParser {
	private static final String DATE_TEST = "01/04/2014 00:01";
	private static final String DATE_INVALID = "Error: Invalid Date Entered";
	private DateAndTimeManager _dateParser = DateAndTimeManager.getInstance();
	
	/*We do equivalence partitioning*/
	/*We test dates with years*/
	@Test
	public void test1() {
		testDateCommand("11/11/14", "11/11/2014");
	}

	@Test
	public void test2() {
		testDateCommand("11-11-18", "11/11/2018");
	}
	
	@Test
	public void test3() {
		testDateCommand("11.11.2015", "11/11/2015");
	}
	
	@Test
	public void test4(){
		testDateCommand("20/03/14", "20/03/2014");
	}
	
	@Test
	public void test5(){
		testDateCommand("1 January", "01/01/2014");
	}
	
	@Test
	public void test6(){
		testDateCommand("Oct 18,16", "18/10/2016");
	}
	
	@Test
	public void test7(){
		testDateCommand("October 18,14", "18/10/2014");
	}
	
	@Test
	public void test8(){
		testDateCommand("Oct 18 , 14", "18/10/2014");
	}
	
	@Test
	public void test9(){
		testDateCommand("October 18 , 15", "18/10/2015");
	}
	
	@Test
	public void test10(){
		testDateCommand("Oct 18, 14", "18/10/2014");
	}
	
	@Test
	public void test11(){
		testDateCommand("October 18, 14", "18/10/2014");
	}
	
	@Test
	public void test12(){
		testDateCommand("18 Oct 16", "18/10/2016");
	}
	
	@Test
	public void test13(){
		testDateCommand("18 October 15", "18/10/2015");
	}
	
	@Test
	public void test14(){
		testDateCommand("18 Oct, 14", "18/10/2014");
	}
	
	@Test
	public void test15(){
		testDateCommand("18 October, 14", "18/10/2014");
	}
	
	@Test
	public void test16(){
		testDateCommand("18-Oct-15", "18/10/2015");
	}
	
	@Test
	public void test17(){
		testDateCommand("18-October-15", "18/10/2015");
	}
	
	@Test
	public void test18(){
		testDateCommand("18 Oct,15", "18/10/2015");
	}
	
	@Test
	public void test19(){
		testDateCommand("18 October,14", "18/10/2014");
	}
	
	@Test
	public void test20(){
		testDateCommand("18 10 , 14", "18/10/2014");
	}
	
	@Test
	public void test21(){
		testDateCommand("18 10, 16", "18/10/2016");
	}
	
	@Test
	public void test22(){
		testDateCommand("18/10/2015", "18/10/2015");
	}
	
	@Test
	public void test23(){
		testDateCommand("18-10-2015", "18/10/2015");
	}
	
	@Test
	public void test24(){
		testDateCommand("18.10.2015", "18/10/2015");
	}
	
	@Test
	public void test25(){
		testDateCommand("18Oct15", "18/10/2015");
	}
	
	@Test
	public void test26(){
		testDateCommand("1 Jun 15", "01/06/2015");
	}
	
	@Test 
	public void test27(){
		testDateCommand("1.6.15", "01/06/2015");
	}
	
	@Test
	public void test28(){
		testDateCommand("1.6.2015", "01/06/2015");
	}
	
	/*We test dates without year*/
	@Test
	public void test29(){
		testDateCommand("1/6", "01/06/2014");
	}
	
	@Test
	public void test30(){
		testDateCommand("1-6", "01/06/2014");
	}
	
	@Test
	public void test31(){
		testDateCommand("June 1", "01/06/2014");
	}
	
	@Test
	public void test32(){
		testDateCommand("1 Jun", "01/06/2014");
	}
	
	@Test
	public void test33(){
		testDateCommand("1Jun", "01/06/2014");
	}
	
	@Test
	public void test34(){
		testDateCommand("Jun1", "01/06/2014");
	}
	
	@Test
	public void test35(){
		testDateCommand("1/06", "01/06/2014");
	}
	
	@Test
	public void test36(){
		testDateCommand("1-06", "01/06/2014");
	}
	
	@Test
	public void test37(){
		testDateCommand("01/6", "01/06/2014");
	}
	
	@Test
	public void test38(){
		testDateCommand("01-6", "01/06/2014");
	}
	
	@Test
	public void test39(){
		testDateCommand("June 01", "01/06/2014");
	}
	
	@Test
	public void test40(){
		testDateCommand("01 Jun", "01/06/2014");
	}
	
	@Test
	public void test41(){
		testDateCommand("01Jun", "01/06/2014");
	}
	
	@Test
	public void test42(){
		testDateCommand("Jun01", "01/06/2014");
	}
	
	@Test
	public void test43(){
		testDateCommand("01/06", "01/06/2014");
	}
	
	@Test
	public void test44(){
		testDateCommand("01-06", "01/06/2014");
	}
	
	@Test
	public void test45(){
		testDateCommand("01-01", "01/01/2014");
	}
	
	
	
	
	
	
	/*We test invalid dates*/
	
	/*We only support date-month-year*/
	@Test
	public void invalid1(){
		testInvalidDateCommand("1993.1.6", DATE_INVALID);
	}
	
	@Test
	public void invalid2(){
		testInvalidDateCommand("1993 1 6", DATE_INVALID);
	}
	
	/*Boundary case: February have no date "30"*/
	@Test
	public void invalid3(){
		testInvalidDateCommand("30/02/15", DATE_INVALID);
	}
	
	/*We cannot support 6 digits stick together*/
	@Test
	public void invalid4() {
		testInvalidDateCommand("000000", DATE_INVALID);
	}
	
	/*And also we can't parse anything if user doesn't key in anything*/
	@Test
	public void invalid5() {
		testInvalidDateCommand("", DATE_INVALID);
	}
	
	@Test
	public void invalid6() {
		testInvalidDateCommand(" ", DATE_INVALID);
	}
	
	@Test
	public void invalid7(){
		testInvalidDateCommand(",", DATE_INVALID);
	}
	
	/*We can't parse "day" in dateparser*/
	@Test
	public void invalid8(){
		testInvalidDateCommand("Wed", DATE_INVALID);
	}
	
	@Test
	public void invalid9(){
		testInvalidDateCommand("Today", DATE_INVALID);
	}
	
	@Test
	public void invalid10(){
		testInvalidDateCommand("Oct1815", DATE_INVALID);
	}
	
	/*We cannot support 6 digits stick together*/
	@Test
	public void invalid11(){
		testInvalidDateCommand("18102015", DATE_INVALID);
	}
	
	@Test
	public void invalid12(){
		testInvalidDateCommand("15/18/10", DATE_INVALID);
	}
	
	@Test
	public void invalid14(){
		testInvalidDateCommand("40-18-10", DATE_INVALID);
	}
	
	@Test
	public void invalid15(){
		testInvalidDateCommand("40.18.10", DATE_INVALID);
	}
	
	@Test
	public void invalid16(){
		testInvalidDateCommand("40 18 10", DATE_INVALID);
	}
	
	@Test
	public void invalid17(){
		testInvalidDateCommand("40-18-Oct", DATE_INVALID);
	}
	
	@Test
	public void invalid18(){
		testInvalidDateCommand("16/10/Oct", DATE_INVALID);
	}
	
	@Test
	public void invalid19(){
		testInvalidDateCommand("15/10/oct", DATE_INVALID);
	}
	
	@Test
	public void invalid20(){
		testInvalidDateCommand("35.18.10", DATE_INVALID);
	}
	
	@Test
	public void invalid21(){
		testInvalidDateCommand("49 18 10", DATE_INVALID);
	}

	/*boundary case: when it is null*/
	@Test
	public void invalid22(){
		testInvalidDateCommand(null, DATE_INVALID);
	}
	
	@Test
	public void invalid23(){
		testInvalidDateCommand("100 October,14", DATE_INVALID);
	}
	
	@Test
	public void invalid24(){
		testInvalidDateCommand("1 1", DATE_INVALID);
	}
	
	@Test
	public void invalid25(){
		testInvalidDateCommand("18 10 15", DATE_INVALID);
	}
	
	@Test
	public void invalid26(){
		testInvalidDateCommand("01.06", DATE_INVALID);
	}
	
	@Test
	public void invalid27(){
		testInvalidDateCommand("01 06", DATE_INVALID);
	}
	
	/*test those exceptions*/
	@Test
	public void invalid28(){
		testInvalidDateCommand("01 02 2015", DATE_INVALID);
	}
	
	@Test
	public void invalid29(){
		testInvalidDateCommand("01.6", DATE_INVALID);
	}
	
	@Test
	public void invalid30(){
		testInvalidDateCommand("01 6", DATE_INVALID);
	}
	
	@Test
	public void invalid31(){
		testInvalidDateCommand("1.06", DATE_INVALID);
	}
	
	@Test
	public void invalid32(){
		testInvalidDateCommand("1 06", DATE_INVALID);
	}
	
	@Test
	public void invalid33(){
		testInvalidDateCommand("01 12", DATE_INVALID);
	}
	
	@Test
	public void invalid34(){
		testInvalidDateCommand("1.6", DATE_INVALID);
	}
	
	@Test
	public void invalid35(){
		testInvalidDateCommand("1 6", DATE_INVALID);
	}
	
	@Test
	public void invalid36(){
		testInvalidDateCommand("1 6 15", DATE_INVALID);
	}
	
	@Test 
	public void invalid37(){
		testInvalidDateCommand("Oct 18 15", DATE_INVALID);
	}
	
	@Test
	public void invalid38(){
		testInvalidDateCommand("October 18 14", DATE_INVALID);
	}
	
	private void testDateCommand(String input, String expected){
		setupDebug();
		try {
			assertEquals(_dateParser.parseDate(input), expected);
		} catch (InvalidDateException e) {
			fail();
		}
	}

	/**
	 * 
	 */
	private void setupDebug() {
		try {
			_dateParser.setDebug(DATE_TEST);
		} catch (ParseException e1) {
			fail();
		}
	}
	
	private void testInvalidDateCommand(String input, String expected){
		setupDebug();
		try{
			_dateParser.parseDate(input);
			fail();
		} catch (InvalidDateException e){
			assertEquals(e.getMessage(), expected);
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestDateParser.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestFlexiCommands.java
	 */


package com.taskpad.tests;



/**
 * This class is to test the commands not as the first word
 */

import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.input.CommandQueue;
import com.taskpad.input.CommandTypes;
import com.taskpad.input.CommandTypes.CommandType;

public class TestFlexiCommands {

	/**
	 * Test add in between words
	 */
	@Test
	public void testAdd() {
		testFindValueCommand(CommandType.ADD, "do CS2101 homework add ");
		testFindValueCommand(CommandType.ADD, "  add  ");
		testFindValueCommand(CommandType.ADD, "do add CS2101 homework");
		
		testFindValueCommand(CommandType.ADD, "do new CS2101 homework");
		testFindValueCommand(CommandType.ADD, "do CS2101 homework new");
		testFindValueCommand(CommandType.ADD, "do create CS2101 homework");
		testFindValueCommand(CommandType.ADD, "do insert CS2101 homework");
	}
	
	/**
	 * Testing add info in between words
	 */
	
	@Test
	public void testCommandAddInfo(){
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room addinfo");
		testFindValueCommand(CommandType.ADD_INFO, "venue addinfo meeting room");

		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room info");
		testFindValueCommand(CommandType.ADD_INFO, "venue info meeting room");
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room information");
		testFindValueCommand(CommandType.ADD_INFO, "venue information meeting room");
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room informatin");
		testFindValueCommand(CommandType.ADD_INFO, "venue informatin meeting room");
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room informatn");
		testFindValueCommand(CommandType.ADD_INFO, "venue informatn meeting room");
		
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room adddesc");
		testFindValueCommand(CommandType.ADD_INFO, "venue adddesc meeting room");
		
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room createdesc");
		testFindValueCommand(CommandType.ADD_INFO, "venue createdesc meeting room");
		
		testFindValueCommand(CommandType.ADD_INFO, "venue meeting room createinfo");
		testFindValueCommand(CommandType.ADD_INFO, "venue createinfo meeting room");
	}
	
	/**
	 * Test add reminder
	 */
	@Test
	public void testCommandAddRem(){
		testFindValueCommand(CommandType.ADD_REM, "today wash laundry ADDR");
		testFindValueCommand(CommandType.ADD_REM, "today addr wash laundry");
		
		testFindValueCommand(CommandType.ADD_REM, "today wash laundry remind");
		testFindValueCommand(CommandType.ADD_REM, "today remind wash laundry");

		testFindValueCommand(CommandType.ADD_REM, "today reminder wash laundry");
		testFindValueCommand(CommandType.ADD_REM, "today wash laundry reminder");

		testFindValueCommand(CommandType.ADD_REM, "today wash laundry remainder");
		testFindValueCommand(CommandType.ADD_REM, "today remainder wash laundry");
		
		testFindValueCommand(CommandType.ADD_REM, "today addrem wash laundry");
		testFindValueCommand(CommandType.ADD_REM, "today wash laundry addrem");
	}
	
	/**
	 * Test alarm
	 */
	@Test
	public void testCommandAlarm(){
		testFindValueCommand(CommandType.ALARM, "wash dishes ALARM");
		testFindValueCommand(CommandType.ALARM, "wash ALARM dishes");
		
		testFindValueCommand(CommandType.ALARM, "wash dishes ring");
		testFindValueCommand(CommandType.ALARM, "wash ring dishes");
		
		testFindValueCommand(CommandType.ALARM, "wash dishes ADDALARM");
		testFindValueCommand(CommandType.ALARM, "wash addALARM dishes");
		
		testFindValueCommand(CommandType.ALARM, "wash dishes setALARM");
		testFindValueCommand(CommandType.ALARM, "wash SETALARM dishes");
		
		testFindValueCommand(CommandType.ALARM, "wash dishes createALARM");
		testFindValueCommand(CommandType.ALARM, "wash CREATEALARM dishes");
		
		testFindValueCommand(CommandType.ALARM, "wash dishes setTImer");
		testFindValueCommand(CommandType.ALARM, "wash setTIMER dishes");
	}
	
	/**
	 * Test stop alarm
	 */
	@Test
	public void testCommandStop(){
		testFindValueCommand(CommandType.STOP, "STOP it now!!!");
		testFindValueCommand(CommandType.STOP, "now STOP");
		testFindValueCommand(CommandType.STOP, "hurry STOP la.");
		
		testFindValueCommand(CommandType.STOP, "now STOPP");
		testFindValueCommand(CommandType.STOP, "hurry STOPP la.");
		
		testFindValueCommand(CommandType.STOP, "now STO");
		testFindValueCommand(CommandType.STOP, "hurry STO la.");
	}
	
	/**
	 * Test clear data
	 */
	@Test
	public void testCommandClear(){
		testFindValueCommand(CommandType.CLEAR_ALL, "all data CLEAR");
		testFindValueCommand(CommandType.CLEAR_ALL, "just CLR");
		testFindValueCommand(CommandType.CLEAR_ALL, "all CLC data");
		testFindValueCommand(CommandType.CLEAR_ALL, "i want it CLEAN");
		testFindValueCommand(CommandType.CLEAR_ALL, "hurry and CLEARALL");
	}
	
	/**
	 * Test clear screen
	 */
	@Test
	public void testCommandClearScr(){
		testFindValueCommand(CommandType.CLEAR_SCREEN, "the output frame CLCSR");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "output CLCSCR now");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "i want an empty SCREEN");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "output CLEARSCR now");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "hurry and CLEARSCREEN");
		testFindValueCommand(CommandType.CLEAR_SCREEN, "please refresh CLEARSC");
	}
	
	/**
	 * Test Delete
	 */
	@Test
	public void testCommandDelete(){
		testFindValueCommand(CommandType.DELETE, "task 1 DELETE");
		testFindValueCommand(CommandType.DELETE, "task DEL now");
		testFindValueCommand(CommandType.DELETE, "task 1 REMOVE");
		testFindValueCommand(CommandType.DELETE, "task REM now");
	}
	
	/**
	 * Test edit 
	 */
	@Test
	public void testCommandEdit(){
		testFindValueCommand(CommandType.EDIT, "description must EDIT");
		testFindValueCommand(CommandType.EDIT, "i CHANGE me");
		testFindValueCommand(CommandType.EDIT, "description to ED");
	}
	
	/**
	 * Test search
	 */
	@Test
	public void testCommandSearch(){
		testFindValueCommand(CommandType.SEARCH, "homework SEARCH");
		testFindValueCommand(CommandType.SEARCH, "homework FIND");
		testFindValueCommand(CommandType.SEARCH, "i cant FIND my homework");
	}
	
	/**
	 * Test list 
	 */
	@Test
	public void testCommandList(){
		testFindValueCommand(CommandType.LIST, "all LIST");
		testFindValueCommand(CommandType.LIST, "-d LS");
		testFindValueCommand(CommandType.LIST, "all LST");
		testFindValueCommand(CommandType.LIST, "undone SHOW");
		testFindValueCommand(CommandType.LIST, "-al DISPLAY");
	}
	
	/**
	 * Test done
	 */
	@Test
	public void testCommandDone(){
		testFindValueCommand(CommandType.DONE, "1 DONE");
		testFindValueCommand(CommandType.DONE, "2 FINISH");
		testFindValueCommand(CommandType.DONE, "3 FINISHED");
		testFindValueCommand(CommandType.DONE, "4 COMPLETE");
		testFindValueCommand(CommandType.DONE, "5 COMPLETED");
	}
	
	private void testFindValueCommand (CommandTypes.CommandType expected, String input){
		//new CommandTypes();
		CommandTypes.getInstance();
		assertEquals(expected, CommandQueue.findFlexi(input));
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestFlexiCommands.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestGui.java
	 */


package com.taskpad.tests;

import static org.junit.Assert.*;

import java.awt.AWTException;
import java.awt.Robot;
import java.awt.event.InputEvent;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.text.ParseException;

import javax.swing.SwingUtilities;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.input.InputManager;
import com.taskpad.launcher.TaskPadMain;
import com.taskpad.ui.GuiManager;

/**
 *
 * This JUnit Test case tests the whole system using GUI testing.
 *
 */
public class TestGui {
	private final ByteArrayOutputStream _outContent = new ByteArrayOutputStream();

	private String _expected;
	
	private DateAndTimeManager _datm = DateAndTimeManager.getInstance();

	@Test
	public void test() {
		setUpStream();

		setUpGuiManager();
		setUpDateTimeDebug("12/04/2014 09:00");
		InputManager.setDebug(false, null);
		runTaskPad();

		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				boolean hasReminder = GuiManager.isTableActive();

				assertTrue(GuiManager.getInputFrameVisibility());
				if (hasReminder) {
					assertTrue(GuiManager.getTableVisibility());
					assertFalse(GuiManager.getOutputFrameVisibility());
				} else {
					assertFalse(GuiManager.getTableVisibility());
					assertTrue(GuiManager.getOutputFrameVisibility());
				}

			}

		});


		try {
			Robot bot = new Robot();

			autoWait(bot);
			
			/* To reset Eclipse's data */
			clear(bot);
			
			/* Standard commands */
			addFloatingTask(bot);
			addDeadlineTaskStandard(bot);
			addStartEndTaskStandard(bot);
			
			addInfoTask(bot);
			
			markTaskDone(bot);
			
			/* Flexi commands */
			addFloatingTask2(bot);
			addDeadlineTaskFlexi(bot);
			addStartEndTaskFlexi(bot);
			
			editDesc(bot);
			editDesc2(bot);
			editDeadline(bot);
			editStart(bot);
			editEnd(bot);
			
			//Cannot add rem, if not when run, the thing changes
			//addrem(bot);
			
			/* Alternative words */
			listTask(bot);
			delTask(bot);
			remTask(bot);
			
			newTask(bot);
			
			searchTask(bot);
			findTask(bot);
			
			listTask(bot);
			markTaskDone2(bot);
			listDone(bot);
			
			/* Non strict ordering */		
			findTask(bot);
			addTaskNonStrict(bot);
			markDoneNonStrict(bot);
			
			/* set alarm to ring */
			alarmOneSec(bot);
			alarmRings(bot);
			alarmStop(bot);
			
			bot.delay(3000);
			
		} catch (AWTException e) {
			e.printStackTrace();
		}

	}

	private void alarmStop(Robot bot) {
		type(bot, "stop\n");
		bot.delay(1000);
		_expected = "Stopping Alarm";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void alarmRings(Robot bot) {
		bot.delay(1000);
		_expected = "ALARM!! stopping demo";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void alarmOneSec(Robot bot) {
		type(bot, "alarm stopping demo 3s\n");
		bot.delay(1000);
		_expected = "Creating alarm... alarm stopping demo 3s";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void markDoneNonStrict(Robot bot) {
		type(bot, "6 done\n");
		bot.delay(1000);
		_expected = "Task ID:		6"
				+ "\n\nDescription:	cs2106 lab \n\n" 
				+ "Deadline:		23:59 13/04/2014\n\n"
				+ "Status:		Done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void addTaskNonStrict(Robot bot) {
		type(bot, "cs2106 lab due tomorrow add\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		6"
				+ "\n\nDescription:	cs2106 lab \n\n" 
				+ "Deadline:		23:59 13/04/2014\n\n"
				+ "Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void listDone(Robot bot) {
		type(bot, "list done\n");
		bot.delay(2000);
		_expected = "Listing finished tasks...";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}
	
	private void markTaskDone2(Robot bot) {
		type(bot, "done 1\n");
		bot.delay(1000);
		_expected = "Task ID:		1"
				+ "\n\nDescription:	do developer guide\n\n" 
				+ "Deadline:		23:59 25/04/2014\n\n"
				+"Status:		Done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void listTask(Robot bot) {
		type(bot, "list\n");
		bot.delay(2000);
		_expected = "Listing all tasks...";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void findTask(Robot bot) {
		type(bot, "find meeting \n");
		bot.delay(1000);
		_expected = "No task found.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void searchTask(Robot bot) {
		type(bot, "search tutorial \n");
		bot.delay(1000);
		_expected = "";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void newTask(Robot bot) {
		type(bot, "new ST2334 tutorial 11\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		5"
				+ "\n\nDescription:	st2334 tutorial 11 \n\n" 
				+ "Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void remTask(Robot bot) {
		type(bot, "rem 2\n");
		bot.delay(1000);
		_expected = "'team meeting' deleted";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void delTask(Robot bot) {
		type(bot, "del 1\n");
		bot.delay(1000);
		_expected = "'do video presentation ' deleted";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	@SuppressWarnings("unused")
	private void addrem(Robot bot) {
		type(bot, "addrem 6 2pm\n");
		bot.delay(1000);
		_expected = "Reminder added!  6: 12/04/2014 14:00";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void editEnd(Robot bot) {
		type(bot, "edit 6 end 5pm\n");
		bot.delay(1000);
		_expected = "TASK 6 EDITED: \n\n"
				+ "Task ID:		6\n\n"
				+ "Description:	movie date \n\n" 
				+ "Start:		14:00 12/04/2014\n\n" 
				+ "End:		17:00 12/04/2014\n\n"
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void editStart(Robot bot) {
		type(bot, "edit 6 start 2pm\n");
		bot.delay(1000);
		_expected = "TASK 6 EDITED: \n\n"
				+ "Task ID:		6\n\n"
				+ "Description:	movie date \n\n" 
				+ "Start:		14:00 12/04/2014\n\n" 
				+ "End:		15:00 12/04/2014\n\n"
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void editDesc2(Robot bot) {
		type(bot, "edit 4 desc dinner with mum, dad and sis\n");
		bot.delay(1000);
		_expected = "TASK 4 EDITED: \n\n"
				+ "Task ID:		4\n\n"
				+ "Description:	dinner with mum , dad and sis\n\n" 
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void editDeadline(Robot bot) {
		type(bot, "edit 5 deadline tomorrow\n");
		bot.delay(1000);
		_expected = "TASK 5 EDITED: \n\n"
				+ "Task ID:		5\n\n"
				+ "Description:	do cheat sheet \n\n"
				+ "Deadline:		23:59 13/04/2014\n\n"
				+ "Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void editDesc(Robot bot) {
		type(bot, "edit 4 dinner with mum and dad\n");
		bot.delay(1000);
		_expected = "TASK 4 EDITED: \n\n"
				+ "Task ID:		4\n\n"
				+ "Description:	dinner with mum and dad\n\n" 
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}
	
	private void addStartEndTaskFlexi(Robot bot) {
		type(bot, "add movie date from 1pm to 3pm\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		6"
				+ "\n\nDescription:	movie date \n\n" 
				+ "Start:		13:00 12/04/2014\n\n"
				+ "End:		15:00 12/04/2014\n\n"
				+ "Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void addDeadlineTaskFlexi(Robot bot) {
		type(bot, "add do cheat sheet by next next thursday\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		5"
				+ "\n\nDescription:	do cheat sheet \n\n" 
				+ "Deadline:		23:59 24/04/2014\n\n"
				+ "Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);		
	}

	private void addFloatingTask2(Robot bot) {
		type(bot, "add dinner with mum\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		4"
				+ "\n\nDescription:	dinner with mum \n\n" 
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);		
	}

	private void markTaskDone(Robot bot) {
		type(bot, "done 1\n");
		bot.delay(1000);
		_expected = "Task ID:		1"
				+ "\n\nDescription:	do video presentation \n\n" 
				+"Status:		Done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}
	
	private void addInfoTask(Robot bot) {
		type(bot, "addinfo 3 venue Meeting Room 20\n");
		bot.delay(1000);
		_expected = "Task ID:		3"
				+ "\n\nDescription:	" + "team meeting\n\nStart:		15:00 26/04/2014\n\n" 
				+ "End:		16:00 26/04/2014\n\n" 
				+ "Details:		venue meeting room 20\n\n"
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void addStartEndTaskStandard(Robot bot) {
		type(bot, "add team meeting -s 26/04/2014 3pm -e 26/04/2014 4pm\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		3"
				+ "\n\nDescription:	" + "team meeting\n\nStart:		15:00 26/04/2014\n\n" 
				+ "End:		16:00 26/04/2014\n\n" 
				+"Status:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);		
	}

	private void autoWait(Robot bot) {
		bot.setAutoDelay(40);
		bot.setAutoWaitForIdle(true);
		bot.delay(2000);
	}

	private void addDeadlineTaskStandard(Robot bot) {
		type(bot, "add do developer guide -d 25/04/2014\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		2"
				+ "\n\nDescription:	" + "do developer guide\n\nDeadline:		23:59 25/04/2014\n\nStatus:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(2000);
	}

	private void addFloatingTask(Robot bot) {
		type(bot, "add do video presentation\n");
		bot.delay(1000);
		_expected = "Task Successfully Added!\n\n\nTask ID:		1"
				+ "\n\nDescription:	" + "do video presentation \n\nStatus:		Not done.";
		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(3000);
	}

	private void clear(Robot bot) {
		type(bot, "clear\n");
		bot.delay(1000);
		_expected += "All tasks have been deleted. You can use undo to get them back.";

		assertEquals(_expected, _outContent.toString().trim());
		cleanUpStreams();
		bot.delay(3000);
	}

	private void runTaskPad() {
		TaskPadMain.runProgram();

		_expected = "Welcome to Taskpad! Type a command or type \"help\"\n\n"
				+ "Today\'s Tasks \n\n"
				+ "Showing your tasks and reminders...\n\n"
				+ "Nothing to show.\n\n\n";
	}

	private void setUpGuiManager() {
		GuiManager.setDebug(true);
		GuiManager.setGui(true);
	}
	
	private void setUpDateTimeDebug(String dateString){
		try {
			_datm.setDebug(dateString);
		} catch (ParseException e) {
			//wrong date causes failed
			fail();
		}
	}

	private void setUpStream() {
		System.setOut(new PrintStream(_outContent));
	}

	private void cleanUpStreams() {
		_outContent.reset();
	}

	@SuppressWarnings("unused")
	private void leftClick(Robot robot) {
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
		robot.delay(200);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
		robot.delay(200);
	}

	@SuppressWarnings("unused")
	private void type(Robot robot, int i) {
		robot.delay(40);
		robot.keyPress(i);
		robot.keyRelease(i);
	}

	private void type(Robot robot, String s) {
		byte[] bytes = s.getBytes();
		for (byte b : bytes) {
			int code = b;
			// keycode only handles [A-Z] (which is ASCII decimal [65-90])
			if (code > 96 && code < 123)
				code = code - 32;
			robot.delay(40);
			robot.keyPress(code);
			robot.keyRelease(code);
		}
	}
}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestGui.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestInput.java
	 */


package com.taskpad.tests;



/**
 * This class is to test the input object passed to executor
 */

import static org.junit.Assert.*;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.input.Input;
import com.taskpad.input.InputManager;

public class TestInput {

	private static final String DEBUG_DATE = "10/04/2014 00:00";
	private final ByteArrayOutputStream _outContent = new ByteArrayOutputStream();
	
	
	/**
	 * ToDo: alarm not fully being able to test with output streams
	 */
	
	public void testClear(){
		setUpStream();
		testInputString("Output to GUI: \r\nConfirm clear data? (Y/N)", "Clear");
		testInputString("NULL ", "Y");
	}
	
	@Test
	public void testAddInfo(){
		setUpStream();
		testInputString("TASKID 1\r\nINFO venue : meeting room", "addinfo 1 venue: meeting room");
	}
	
	@Test
	public void testAddRem(){
		setUpStream();
		testInputString("Output to GUI: Reminder added!  1: 23/04/2015 16:00\r\n"
				+ "TIME 16:00\r\nDATE 23/04/2015\r\nTASKID 1", "addrem 1 23/04/2015 16:00");
	}
	
	@Test
	public void testAlarm(){
		setUpStream();
		testInputString("Output to GUI: Creating alarm... alarm collect laundry 30 min", "alarm collect laundry 30 min");
	}
	
	public void testStopAlarm(){
		setUpStream();
		testInputString("", "STOP");
	}
	
	public void testClearScr(){
		setUpStream();
		testInputString("Output to GUI:\r\nConfirm clear screen? (Y/N)", "screen");
		testInputString("Clear GUI Screen", "Y");
	}
	
	@Test
	public void testDelete(){
		setUpStream();
		testInputString("KEYWORD \r\nTASKID 1", "Del 1");
		testInputString("KEYWORD hello\r\nTASKID ", "Del hello");
	}
	
	@Test
	public void testEdit(){
		setUpStream();
		testInputString("DESC new\r\nTASKID 1"
				, "Edit 1 new description");
		
		testInputString("Output to GUI: Warning: TaskID is not in standard position\r\n"
				+ "DESC new\r\n"
				+ "TASKID 1"
				, "Edit one new description");
		
		testInputString("Output to GUI: Warning: TaskID is not in standard position\r\n"
				+ "Output to GUI: Error: Invalid TaskID",
				"Edit one one new description, a, dead 10/04/2014");
		
		testInputString("TASKID 1"
				, "Edit 1 desc");
		
		testInputString("END TIME 23:59\r\n"
				+ "START TIME 00:00\r\n"
				+ "DEADLINE 23:59 13/04/2014\r\n"
				+ "START DATE 10/04/2014\r\n"
				+ "DESC a\r\n"
				+ "TASKID 1\r\n"
				+ "END DATE 14/04/2014"
				, "Edit 1 desc a, end Monday, start today, dead Sunday");

		testInputString("Output to GUI: Warning: TaskID is not in standard position\r\n"
				+ "Output to GUI: BY a Sunday is not a valid date\r\n"
				+ "END TIME 23:59\r\n"
				+ "START TIME 00:00\r\n"
				+ "START DATE 10/04/2014\r\n"
				+ "DESC . a\r\n"
				+ "TASKID 1\r\n"
				+ "END DATE 14/04/2014"
				, "Edit one. desc a, end Monday, start today, dead a Sunday");
		
		testInputString("Output to GUI: Error: Empty Input"
				, "Edit");
		
		testInputString("Output to GUI: Error: Invalid Number of Parameters. Type Help if you need! :) "
				, "Edit aa");
		
		testInputString("Output to GUI: Warning: TaskID is not in standard position\r\n"
				+ "Output to GUI: Error: Invalid TaskID"
				, "Edit aa nn");
		
		testInputString("DESC nn\r\n" 
				+ "TASKID 1"
				, "Edit 1 nn");
		
		testInputString("START TIME 19:00\r\n"
				+ "START DATE 03/08/2014\r\n"
				+ "TASKID 1"
				, "Edit 1 start 19:00 03/08/2014");
		
		testInputString("START TIME 00:00\r\n"
				+ "START DATE 11/04/2014\r\n"
				+ "TASKID 1"
				, "Edit 1 start 1 day");
		
		testInputString("START TIME 16:00\r\n"
				+ "START DATE 11/04/2014\r\n"
				+ "TASKID 1"
				, "Edit 1 start 4pm tmr");
		
  		testInputString("Output to GUI: TO a Monday is not a valid date\r\n"
  				+ "Output to GUI: BY a that day is not a valid date\r\n"
  				+ "Output to GUI: WARNING: has 3 start date and time\r\n"
			+ "Output to GUI: WARNING: has 3 end date and time\r\n"
			+ "Output to GUI: WARNING: has 3 deadline\r\n"
			+ "END TIME \r\n"
			+ "START TIME 00:00\r\n"
			+ "DEADLINE 23:59 14/04/2014\r\n"
			+ "START DATE 10/04/2014\r\n"
			+ "DESC a\r\n"
			+ "TASKID 1\r\n"
			+ "END DATE "
			, "Edit 1 desc a, end Monday, start today, start ,end ,dead Sunday, dead Monday"
			+ ", end a Monday, dead a that day, start a today");
	}
	
	@Test
	public void testSearch(){
		setUpStream();
		testInputString("TIME \r\nKEYWORD dragon potions", "search dragon potions");
		testInputString("TIME 15/04/2014\r\nKEYWORD 15/04/2014", "search 15/04/2014");
	}
	
	@Test
	public void testList(){
		setUpStream();
		testInputString("DEADLINE \r\nKEY ALL", "list all");
		testInputString("DEADLINE \r\nKEY DONE", "list done");
		testInputString("DEADLINE \r\nKEY UNDONE", "list undone");
		testInputString("DEADLINE 31/03/2016\r\nKEY ", "list 31/03/2016");
	}
	
	@Test
	public void testDone(){
		setUpStream();
		testInputString("TASKID 1", "done 1");
	}
	
	@Test
	public void testAdd1(){
		setUpStream();
		testInputString("START TIME 08:00\r\nEND TIME 11:00\r\n"
				+ "START DATE 11/11/2015\r\nDESC  aaa 1\r\nEND DATE 11/11/2015\r\n"
				+ "DEADLINE DATE 23:59 11/11/2015", 
				"add 1 -s 8am, 11/11/15 -d 11/11/15 -e 11am, 11/11/15 \" aaa\"");
	}
	
	
	private void testInputString(String expected, String input){
		setupDebugDate(DEBUG_DATE);
		ArrayList<Input> debugStor = setupDebugStorage();
		InputManager.setDebug(true, debugStor);
		//assertEquals(description, expected, InputManager.receiveFromGui(input));
		InputManager.receiveFromGui(input);
		assertEquals(expected + "\r\n", _outContent.toString());
		cleanUpStreams();
	}

	/**
	 * @return
	 */
	private ArrayList<Input> setupDebugStorage() {
		ArrayList<Input> debugStor = new ArrayList<Input>();
		Map<String, String> param = new HashMap<String, String>();
		param.put("DESC", "AAA");
		Input newInput = new Input("ADD", param);
		debugStor.add(newInput);
		return debugStor;
	}

	/**
	 * @throws ParseException
	 */
	private void setupDebugDate(String dateString) {
		try {
			DateAndTimeManager.getInstance().setDebug(dateString);
		} catch (ParseException e) {
			fail();
		}
	}
	
	private void setUpStream(){
		System.setOut(new PrintStream(_outContent));
	}
	
	private void cleanUpStreams(){
		_outContent.reset();
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestInput.java





	/**
	 * origin: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestTimeParser.java
	 */


package com.taskpad.tests;

/**
 * This unit test class tests the Time Parser
 * ensure 100% coverage
 */

import static org.junit.Assert.*;

import org.junit.Test;

import com.taskpad.dateandtime.DateAndTimeManager;
import com.taskpad.dateandtime.InvalidTimeException;
import com.taskpad.dateandtime.TimeErrorException;

public class TestTimeParser {
	
	private DateAndTimeManager _timeParser = DateAndTimeManager.getInstance();
	
	private static final String MESSAGE_INVALID = "Error: Invalid time entered";
	private static final String MESSAGE_TIME = "Error: Invalid Time supplied: ";

	/**
	 * Test AM strings 
	 */

	@Test
	public void AMtest1() {
		testTimeCommand("08:00", "8am");
	}

	@Test
	public void AMtest2(){
		testTimeCommand("08:00", "8 am");
	}
	
	@Test
	public void AMtest3(){
		testTimeCommand("00:00", "12AM");
	}
	
	@Test
	public void AMtest4(){
		testTimeCommand("08:15", "8.15 am");
	}
	
	@Test
	public void AMtest5(){
		testTimeCommand("08:00", "8.00am");
	}
	
	@Test
	public void AMtest6(){
		testTimeCommand("08:15", "815am");
	}
	
	@Test
	public void AMtest7(){
		testTimeCommand("08:15", "815 am");
	}
	
	/*test if statement in convertMillisecondsToTime*/
	@Test
	public void AMtest8(){
		testTimeCommand("01:01", "1.01 A");
	}
	
	@Test
	public void AMtest9(){
		testTimeCommand("00:15", "1215am");
	}
	
	@Test
	public void AMtest10(){
		testTimeCommand("00:15", "12:15a");
	}
	
	@Test
	public void AMtest11(){
		testTimeCommand("11:00", "11am");
	}
	
	@Test
	public void AMtest12(){
		testTimeCommand("10:00", "10am");
	}
	
	/**
	 * Test PM strings 
	 */
	@Test
	public void PMtest1(){
		testTimeCommand("20:00", "8pm");
	}
	
	@Test
	public void PMtest2(){
		testTimeCommand("20:00", "8 pm");
	}
	
	/*boundary case: case that failed in OP2*/
	@Test
	public void PMtest3(){
		testTimeCommand("12:00", "12pm");
	}
	
	@Test
	public void PMtest4(){
		testTimeCommand("12:00", "12 Pm ");
	}
	
	@Test
	public void PMtest5(){
		testTimeCommand("20:15", "20;15");
	}
	
	@Test
	public void PMtest6(){
		testTimeCommand("20:15", "815 pm");
	}
	
	@Test
	public void PMtest7(){
		testTimeCommand("12:15", "1215 pm");
	}
	
	@Test
	public void PMtest8(){
		testTimeCommand("23:15", "1115 p");
	}
	
	/**
	 * Test word strings 
	 */
	
	@Test
	public void wordTest1(){
		testTimeCommand("00:00", "morning");
	}
	
	@Test
	public void wordTest2(){
		testTimeCommand("00:00", "morn");
	}
	
	@Test
	public void wordTest3(){
		testTimeCommand("12:00", "aft");
	}
	
	@Test
	public void wordTest4(){
		testTimeCommand("12:00", "afternoon");
	}
	
	@Test
	public void wordTest5(){
		testTimeCommand("12:00", "noon");
	}
	
	@Test
	public void wordTest6(){
		testTimeCommand("17:00", "evening");
	}
	
	@Test
	public void wordTest7(){
		testTimeCommand("17:00", "eve");
	}
	
	@Test
	public void wordTest8(){
		testTimeCommand("19:00", "night");
	}
	
	@Test
	public void wordTest9(){
		testTimeCommand("19:00", "ngt");
	}
	
	@Test
	public void wordTest10(){
		testTimeCommand("00:00", "MORN");
	}
	
	@Test
	public void wordTest11(){
		testTimeCommand("00:00", "MORNING");
	}
	
	@Test
	public void wordTest12(){
		testTimeCommand("12:00", "AFT");
	}
	
	@Test
	public void wordTest13(){
		testTimeCommand("12:00", "NOON");
	}
	
	@Test
	public void wordTest14(){
		testTimeCommand("19:00", "NiGHt");
	}
	
	@Test
	public void wordTest15(){
		testTimeCommand("00:00", "MidNiGHt");
	}
	
	@Test
	public void standardTest1(){
		testTimeCommand("19:00", "19:00");
	}
	
	@Test
	public void standardTest2(){
		testTimeCommand("00:00", "00:00");
	}
	
	/**
	 * Test unsupported cases
	 * @param expected
	 * @param input
	 */
	
	@Test
	public void invalid1(){
		testInvalidTimeCommand(MESSAGE_INVALID, "");
	}
	
	@Test
	public void invalid2(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 0800", "0800");
	}
	
	@Test
	public void invalid3(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 2000", "2000");
	}
	
	@Test
	public void invalid4(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 20.15", "20.15");
	}
	
	public void invalid5(){
		testInvalidTimeCommand(MESSAGE_INVALID, null);
	}

	@Test
	public void invalid6(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 0am", "0 Am");
	}
	
	/*below test case are to test checkIfInvalidTimeString*/
	@Test
	public void invalid7(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": -100am", "-100 Am");
	}
	
	@Test
	public void invalid8(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": -10am", "-10 Am");
	}
	
	@Test
	public void invalid9(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 0-1am", "0-1 Am");
	}
	
	@Test
	public void invalid10(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 1400am", "1400 Am");
	}
	
	@Test
	public void invalid11(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 1199am", "1199 Am");
	}
	
	@Test
	public void invalid12(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 0000pm", "0000 pm");
	}
	
	@Test
	public void invalid13(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 000pm", "000 pm");
	}
	/*above test case are to test checkIfInvalidTimeString*/
	
	@Test
	public void invalid14(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 00.15", "00.15");
	}
	
	@Test
	public void invalid15(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 00am", "00 Am");
	}
	
	@Test
	public void invalid16(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 00p", "00 p");
	}
	
	@Test
	public void invalid17(){
		testInvalidTimeCommand(MESSAGE_TIME + "24:00", "24:00");
	}
	

	@Test
	public void invalid18(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 111aaa111", "111aaa111");
	}
	
	@Test
	public void invalid19(){
		testInvalidTimeCommand(MESSAGE_INVALID + ": 11:00ak", "11:00ak");
	}
	
	private void testTimeCommand (String expected, String input){
		try {
			assertEquals(expected, DateAndTimeManager.getInstance().parseTimeInput(input));
		} catch (TimeErrorException | InvalidTimeException e) {
			fail();
		}
	}
	
	private void testInvalidTimeCommand(String expected, String input){
		try {
			_timeParser.parseTimeInput(input);
			fail();
		} catch (TimeErrorException | InvalidTimeException e) {
			assertEquals(e.getMessage(), expected);
			e.printStackTrace();
		}
	}

}

	// End of segment: C:\Users\Charbby\OneDrive\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestTimeParser.java





