//@author: a0105788u



	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\CommandRecord.java
	 */


package com.taskpad.data;

import java.util.LinkedList;

public class CommandRecord {
	// private static String previousCommand;
	private static LinkedList<String> commandsForUndo = new LinkedList<String>();
	private static LinkedList<String> commandsForRedo = new LinkedList<String>();
	
	public static void pushForUndo(String command) {
		// previousCommand = command;
		commandsForUndo.push(command);
	}
	
	public static String popForUndo() throws NoPreviousCommandException {
		if (commandsForUndo.size() < 1) {
			throw new NoPreviousCommandException();
		}
		return commandsForUndo.pop();
	}
	
	public static void pushForRedo(String command) {
		// previousCommand = command;
		commandsForRedo.push(command);
	}
	
	public static String popForRedo() throws NoPreviousCommandException {
		if (commandsForRedo.size() < 1) {
			throw new NoPreviousCommandException();
		}
		return commandsForRedo.pop();
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\CommandRecord.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\DataFileStack.java
	 */


package com.taskpad.data;

import java.util.LinkedList;

public class DataFileStack {
	public static final String FILE = ".data.xml";
	// public static final String FILE_PREV = ".data_prev.xml";
	public static LinkedList<String> undoStack = new LinkedList<String>();
	public static LinkedList<String> redoStack = new LinkedList<String>();
	
	// private static boolean previousIsValid = false;
	
	/*
	public static boolean isValidPrevious() {
		return previousIsValid;
	}
	
	public static void setPreviousIsValid(boolean isValid) {
		previousIsValid = isValid;
	}
	*/
	
	public static String requestDataFile() {
		return ".data" + undoStack.size() + ".xml";
	}
	
	public static void pushForUndo(String file) {
		// previousCommand = command;
		undoStack.push(file);
	}
	
	public static String popForUndo() throws NoPreviousFileException {
		if (undoStack.size() < 1) {
			throw new NoPreviousFileException();
		}
		return undoStack.pop();
	}
	
	public static void pushForRedo(String file) {
		redoStack.push(file);
	}
	
	public static String popForRedo() throws NoPreviousFileException {
		if (redoStack.size() < 1) {
			throw new NoPreviousFileException();
		}
		return redoStack.pop();
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\DataFileStack.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\DataManager.java
	 */


package com.taskpad.data;


import java.io.File;
import java.io.FileNotFoundException;
//import java.io.IOException;
import java.util.LinkedList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
//import org.xml.sax.SAXException;


import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class DataManager {

	public DataManager(){
	}
	
	public static int retrieveNumberOfTasks(){
		int numberOfTasks = retrieve(DataFileStack.FILE).size();
		return numberOfTasks;
	}
	
	public static void initializeXml(){
		// do nothing
		/*
		LinkedList<Task> tasks = new LinkedList<Task>();
		DataManager.storeBack(tasks, DataFile.FILE);
		DataManager.storeBack(tasks, DataFile.FILE_PREV);
		*/
	}
		
	public static TaskList retrieve(String file) {
		TaskList listOfTasks = new TaskList();
		
		try {
			File fXmlFile = new File(file);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(fXmlFile);
			
			doc.getDocumentElement().normalize();
			
			NodeList nList = doc.getElementsByTagName("Task");
			
			// System.out.println("nList.length = " + nList.getLength());
			for (int i = 0; i < nList.getLength(); i++) {
				Node taskNode = nList.item(i);
		 
				if (taskNode.getNodeType() == Node.ELEMENT_NODE) {
					Element task = (Element) taskNode;
					
					String description;
					String deadline;
					String startDate;
					String startTime;
					String endDate;
					String endTime;
					String venue;
					String details;
					int done;
					
					if (task.getElementsByTagName("description").item(0) != null) {
						description = task.getElementsByTagName("description").item(0).getTextContent();
					} else {
						return listOfTasks; // description cannot be null
					}
					
					if(task.getElementsByTagName("deadline").item(0) != null) {
						deadline = task.getElementsByTagName("deadline").item(0).getTextContent();
					} else {
						deadline = null;
					}
					
					if (task.getElementsByTagName("start_date").item(0) != null) {
						startDate = task.getElementsByTagName("start_date").item(0).getTextContent();
					} else {
						startDate = null;
					}
					
					if (task.getElementsByTagName("start_time").item(0) != null) {
						startTime = task.getElementsByTagName("start_time").item(0).getTextContent();
					} else {
						startTime = null;
					}
					
					if (task.getElementsByTagName("end_date").item(0) != null) {
						endDate = task.getElementsByTagName("end_date").item(0).getTextContent();
					} else {
						endDate = null;
					}
					
					if (task.getElementsByTagName("end_time").item(0) != null) {
						endTime = task.getElementsByTagName("end_time").item(0).getTextContent();
					} else {
						endTime = null;
					}
					
					if (task.getElementsByTagName("venue").item(0) != null) {
						venue = task.getElementsByTagName("venue").item(0).getTextContent();
					} else {
						venue = null;
					}
					
					if(task.getElementsByTagName("details").item(0) != null) {
						details = task.getElementsByTagName("details").item(0).getTextContent();
					} else {
						details = null;
					}
					
					assert(task.getElementsByTagName("done") != null);
					done = Integer.parseInt(task.getElementsByTagName("done").item(0).getTextContent());
					
					listOfTasks.add(new Task(description, deadline, startDate,
							startTime, endDate, endTime, venue, details, done));
				}
			}
			
			return listOfTasks;
	    } catch (FileNotFoundException e) {
			TaskList tasks = new TaskList();
			DataManager.storeBack(tasks, file);
			return tasks;
	    } catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return listOfTasks;
		
	}
	
	public static void storeBack(TaskList taskList, String file) {
		try {
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			docFactory.setNamespaceAware(true);
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
	 
			// root elements
			Document doc = docBuilder.newDocument();
			Element rootElement = doc.createElement("TaskPad");
			doc.appendChild(rootElement);
	 
			for(int i = 0; i < taskList.size(); i++) {
				Task taskInList = taskList.get(i);
				int id = i + 1;
				Element task = doc.createElement("Task");
				rootElement.appendChild(task);
				task.setAttribute("id", Integer.toString(id));
				
				if(taskInList.getDescription() != null) {
					Element description = doc.createElement("description");
					description.appendChild(doc.createTextNode(taskInList.getDescription()));
					task.appendChild(description);
				}
				
				if(taskInList.getDeadline() != null) {
					Element deadlineDay = doc.createElement("deadline");
					deadlineDay.appendChild(doc.createTextNode(taskInList.getDeadline()));
					task.appendChild(deadlineDay);
				}
				
				if (taskInList.getStartDate() != null) {
					Element startDate = doc.createElement("start_date");
					startDate.appendChild(doc.createTextNode(taskInList.getStartDate()));
					task.appendChild(startDate);
				}
				
				if (taskInList.getStartTime() != null) {
					Element startTime = doc.createElement("start_time");
					startTime.appendChild(doc.createTextNode(taskInList.getStartTime()));
					task.appendChild(startTime);
				}
				
				if (taskInList.getEndDate() != null) {
					Element endDate = doc.createElement("end_date");
					endDate.appendChild(doc.createTextNode(taskInList.getEndDate()));
					task.appendChild(endDate);
				}
				
				if (taskInList.getEndTime() != null) {
					Element endTime = doc.createElement("end_time");
					endTime.appendChild(doc.createTextNode(taskInList.getEndTime()));
					task.appendChild(endTime);
				}
				
				if (taskInList.getDetails() != null) {
					Element details = doc.createElement("details");
					details.appendChild(doc.createTextNode(taskInList.getDetails()));
					task.appendChild(details);
				}
				
				Element done = doc.createElement("done");
				done.appendChild(doc.createTextNode(Integer.toString(taskInList.getDone())));
				task.appendChild(done);
				
			}
				
			// write the content into xml file
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(file));
			
			transformer.transform(source, result);
	 
		} catch (ParserConfigurationException pce) {
			pce.printStackTrace();
		} catch (TransformerException tfe) {
		  	tfe.printStackTrace();
		}
	
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\DataManager.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\NoPreviousCommandException.java
	 */


package com.taskpad.data;

public class NoPreviousCommandException extends Exception {

}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\NoPreviousCommandException.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\NoPreviousFileException.java
	 */


package com.taskpad.data;

public class NoPreviousFileException extends Exception {
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\data\NoPreviousFileException.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactory.java
	 */


package com.taskpad.execute;

import java.util.LinkedList;
import java.util.logging.Logger;

import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.NoPreviousCommandException;
import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class CommandFactory {
	private static final String FEEDBACK_NO_TASK_FOUND = "No task is found.";
	private static final String FEEDBACK_NO_TASK_WITH_DEADLINE = "No task with deadline in the database.";
	private static final String FEEDBACK_NO_TASK = "No task found.";
	private static final String FEEDBACK_NO_FINISHED_TASK = "No finished task found.";
	private static final String LOGGING_ADDING_TASK = "adding task: %s";
	private static final String FEEDBACK_NO_UNDONE_TASK = "No undone task found.";
	private static final String FEEDBACK_CLEAR = "All tasks have been deleted. You can use undo to get them back.";
	private static final String FEEDBACK_CANNOT_UNDO = "You don't have things to undo.";
	private static final String STRING_NEWLINE = "\n";
	private static Logger logger = Logger.getLogger("TaskPad");
	
	protected static void add(String description, String deadline, String startDate,
			String startTime, String endDate,
			String endTime, String venue) {
		logger.info(String.format(LOGGING_ADDING_TASK, description));
		
		TaskList listOfTasks = CommandFactoryBackend.archiveForUndo();
		
		Task taskAdded = CommandFactoryBackend.addTask(description, deadline, startDate, startTime,
				endDate, endTime, venue, listOfTasks);
		
		int taskId = listOfTasks.size();
		OutputToGui.output(STRING_NEWLINE);
		OutputToGui.generateFeedbackForAdd(taskId, taskAdded);
	}
	
	protected static void listUndone() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		LinkedList<Integer> tasks = CommandFactoryBackend.getUndoneTasks(listOfTasks);
		
		if (tasks.size() == 0) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_NO_UNDONE_TASK);
		} else {
			// OutputToGui.output(STRING_NEWLINE);
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}
		
	}

	protected static void listDone() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);

		LinkedList<Integer> tasks = CommandFactoryBackend.getFinishedTasks(listOfTasks);
		
		if (tasks.size() == 0) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_NO_FINISHED_TASK);
		} else {
			// OutputToGui.output(STRING_NEWLINE);
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}
	}

	protected static void listAll() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);

		LinkedList<Integer> tasks = CommandFactoryBackend.getAllTasks(listOfTasks);
		
		if (tasks.size() == 0) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_NO_TASK);
		} else {
			// OutputToGui.output(STRING_NEWLINE);
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}
	}

	/*
	protected static void listByDeadline() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		LinkedList<Integer> tasks = CommandFactoryBackend.sortByDeadline(listOfTasks);
		
		if (tasks.size() == 0) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_NO_TASK_WITH_DEADLINE);
		} else {
			// OutputToGui.output(STRING_NEWLINE);
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}		
	}
	*/
	
	protected static void undo() {
		try {
			String previousFile = CommandFactoryBackend.updateDataForUndo();		
			String command = CommandFactoryBackend.updateCommandRecordForUndo(previousFile);
			
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output("Undo of '" + command + "' completed.");
		} catch (NoPreviousFileException e) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_CANNOT_UNDO);
		} catch (NoPreviousCommandException e) {
			// should never come to this
		}
	}
	
	protected static void redo() {
		try {
			String previousFile = CommandFactoryBackend.updateDataForRedo();
			String command = CommandFactoryBackend.updateCommandRecordForRedo(previousFile);
			
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output("Redo of '" + command + "' completed.");
		} catch (NoPreviousFileException e) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output("You don't have things to redo.");
		} catch (NoPreviousCommandException e) {
			// should never come to this
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	protected static void search(String keywordsString, String timeString) {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		String[] keywords = keywordsString.split(" ");
		String[] times = timeString.split("&");
		LinkedList<Integer> results = CommandFactoryBackend.getSearchResult(listOfTasks, keywords, times);
		
		// pass feedback to GUI
		// OutputToGui.output(STRING_NEWLINE);
		// OutputToGui.output("Number of tasks found: " + results.size() + "\n\n");
		// OutputToGui.outputColorTextForTasks(results, listOfTasks);
		
		if (results.size() == 0) {
			OutputToGui.output(STRING_NEWLINE);
			OutputToGui.output(FEEDBACK_NO_TASK_FOUND);
		} else {
			// OutputToGui.output(STRING_NEWLINE);
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(results, listOfTasks);
		}	
		
	}

	protected static void edit(String taskIdString, String description, String deadline) {
		TaskList listOfTasks = CommandFactoryBackend.archiveForUndo();
		
		Task task = CommandFactoryBackend.editTask(taskIdString, description, deadline,
				listOfTasks);
		
		// pass feedback to gui
		OutputToGui.output("TASK " + taskIdString + " EDITED: " + STRING_NEWLINE);
		/*
		if(description != null && !description.equals("")) {
			OutputToGui.output("'" + taskHistory + "' changed to '" 
				+ OutputToGui.generateTitleForOneTask(taskIdString, description) + "'");
		}
		*/
		int taskid = Integer.parseInt(taskIdString);
		OutputToGui.outputColorTextForOneTask(taskid, task);
	}

	protected static void markAsDone(String taskIdString) {
		TaskList listOfTasks = CommandFactoryBackend.archiveForUndo();

		Task task = CommandFactoryBackend.markTaskAsDone(taskIdString, listOfTasks);

		OutputToGui.output(STRING_NEWLINE);
		OutputToGui.outputColorTextForOneTask(
				Integer.parseInt(taskIdString), task);
	}

	protected static void clear() {
		CommandFactoryBackend.archiveForUndo();	
		CommandFactoryBackend.clearTasks();
		
		// pass feedback to gui
		OutputToGui.output(STRING_NEWLINE);
		OutputToGui.output(FEEDBACK_CLEAR);
	}

	protected static void addInfo(String taskIdString, String info) {
		TaskList listOfTasks = CommandFactoryBackend.archiveForUndo();
		
		int index = getIndexById(taskIdString);
		Task task = CommandFactoryBackend.addInfoToTask(info, listOfTasks, index);
		
		OutputToGui.output(STRING_NEWLINE);
		OutputToGui.outputColorTextForOneTask(index + 1, task);
	}

	protected static int getIndexById(String taskIdString) {
		return Integer.parseInt(taskIdString) - 1;
	}
	
	protected static void delete(String taskIdString) {		
		TaskList listOfTasks = CommandFactoryBackend.archiveForUndo();
		
		int indexOfTask = Integer.parseInt(taskIdString) - 1;	
		assert(indexOfTask < listOfTasks.size());
		
		Task taskDeleted = CommandFactoryBackend.deleteTask(listOfTasks, indexOfTask);
		
		OutputToGui.output(STRING_NEWLINE);

		OutputToGui.output(OutputToGui.generateFeedbackForDelete(taskDeleted));
	}


}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactory.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactoryBackend.java
	 */


package com.taskpad.execute;

import java.util.LinkedList;

import com.taskpad.storage.CommandRecord;
import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.NoPreviousCommandException;
import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class CommandFactoryBackend {
	/**
	 * ACCENDING_ORDER: a comparator used to sort Task by their dates.
	 * 
	 */
	/*
	protected static final Comparator<Task> ACCENDING_ORDER = new Comparator<Task>() {
		/**
		 * compare: compare two tasks' Date
		 * 
		 * @param e1
		 *            : task1
		 * @param e2
		 *            : task2
		 * @return int
		 */
	/*	@Override
		public int compare(Task e1, Task e2) {
			SimpleDateFormat dateConverter = new SimpleDateFormat(
					"dd/MM/yyyy HH:mm");
			Date d1, d2;
			try {
				d1 = dateConverter.parse(e1.getDeadline() + e1.getEndTime());
				d2 = dateConverter.parse(e2.getDeadline() + e2.getEndTime());
			} catch (ParseException e) {
				System.err.println(e.getMessage());
				return 0;
			}
			return d1.compareTo(d2);
		}
	};
	*/
	
	protected static Task addTask(String description, String deadline,
			String startDate, String startTime, String endDate, String endTime,
			String venue, TaskList listOfTasks) {
		Task taskToAdd = new Task(description, deadline, startDate,
				startTime, endDate, endTime, venue);
		listOfTasks.add(taskToAdd);

		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
		return taskToAdd;
	}
	
	protected static LinkedList<Integer> getUndoneTasks(TaskList listOfTasks) {
		LinkedList<Integer> tasks = new LinkedList<Integer>();
		for (int index = 0; index < listOfTasks.size(); index++) {
			Task task = listOfTasks.get(index);
			if (task.getDone() == 1) {
				continue;
			}
			tasks.add(index);
		}
		return tasks;
	}
	
	protected static LinkedList<Integer> getFinishedTasks(TaskList listOfTasks) {
		LinkedList<Integer> tasks = new LinkedList<Integer>();
		for (int index = 0; index < listOfTasks.size(); index++) {
			Task task = listOfTasks.get(index);
			if (task.getDone() == 0) {
				continue;
			}
			tasks.add(index);
		}
		return tasks;
	}

	protected static LinkedList<Integer> getAllTasks(TaskList listOfTasks) {
		LinkedList<Integer> tasks = new LinkedList<Integer>();
		for (int index = 0; index < listOfTasks.size(); index++) {
			tasks.add(index);
		}
		return tasks;
	}

	protected static String updateDataForUndo() throws NoPreviousFileException {
		TaskList currentListOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		String previousFile = DataFileStack.popForUndo();
		TaskList previousListOfTasks = DataManager.retrieve(previousFile);
		
		DataManager.storeBack(previousListOfTasks, DataFileStack.FILE);
		DataManager.storeBack(currentListOfTasks, previousFile);
		
		DataFileStack.pushForRedo(previousFile);
		
		return previousFile;
	}
	
	protected static String updateCommandRecordForUndo(String previousFile)
			throws NoPreviousCommandException {
		String command = CommandRecord.popForUndo();
		CommandRecord.pushForRedo(command);
		
		return command;
	}
	
	protected static String updateDataForRedo() throws NoPreviousFileException {
		TaskList currentListOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		String previousFile = DataFileStack.popForRedo();
		TaskList previousListOfTasks = DataManager.retrieve(previousFile);
		
		DataManager.storeBack(previousListOfTasks, DataFileStack.FILE);
		DataManager.storeBack(currentListOfTasks, previousFile);
		
		DataFileStack.pushForUndo(previousFile);
		
		return previousFile;
	}
	
	protected static String updateCommandRecordForRedo(String previousFile)
			throws NoPreviousCommandException {
		String command = CommandRecord.popForRedo();
		CommandRecord.pushForUndo(command);
		
		return command;
	}

	protected static LinkedList<Integer> getSearchResult(TaskList listOfTasks,
			String[] keywords, String[] times) {
		LinkedList<Integer> results = new LinkedList<Integer>();
		
		for(int index = 0; index < listOfTasks.size(); index++) {
			Task task = listOfTasks.get(index);
			
			String description = task.getDescription();
			String details = task.getDetails();	
			if(details == null) {
				details = "";
			}
			
			boolean isCandidate = false;
			
			isCandidate = containsKeywords(keywords, description, details);
			isCandidate = isCandidate || containsTimes(times, task);
			
			if(isCandidate) {
				results.add(index);
			}
		}
		return results;
	}

	private static boolean containsKeywords(String[] keywords,
			String description, String details) {
		boolean isCandidate = true;
		for(String keyword: keywords) {
			if(!description.contains(keyword) && !details.contains(keyword)) {
				isCandidate = false;
			}
		}
		return isCandidate;
	}

	private static boolean containsTimes(String[] timesOrDates, Task task) {
		String deadline = task.getDeadline();
		String startDate = task.getStartDate();
		String startTime = task.getStartTime();
		String endDate = task.getEndDate();
		String endTime = task.getEndTime();
		
		for(String timeOrDate: timesOrDates) {
			if(timeOrDate.trim().equals("")) {
				continue;
			}
			// check deadline
			if(deadline != null && deadline.contains(timeOrDate)) {
				return true;
			}
			
			// check start/end time
			String time = "";
			String date = "";
			if(timeOrDate.contains(" ")) {
				// time + date
				String[] timeAndDate = timeOrDate.split(" ");
				time = timeAndDate[0];
				date = timeAndDate[1];
				
				if(startDate != null && startDate.equals(date) 
						&& startTime != null && startTime.equals(time)) {
					return true;
				}
				if(endDate != null && endDate.equals(date) 
						&& endTime != null && endTime.equals(time)) {
					return true;
				}
				
			} else {
				// only date
				date = timeOrDate;
				if(startDate != null && startDate.equals(date)) {
					return true;
				}
				if(endDate != null && endDate.equals(date)) {
					return true;
				}
			}
			
		}
		
		return false;
	}
	
	protected static Task editTask(String taskIdString,
			String description, String deadline, TaskList listOfTasks) {
		Task task = getTaskById(listOfTasks, taskIdString);
		// String taskHistory = OutputToGui.generateTitleForOneTask(taskIdString, task.getDescription());
		
		if(description != null && !description.equals("")) {
			task.setDescription(description);
		}
		if(deadline != null && !deadline.equals("")) {
			task.setDeadline(deadline);
		}
		
		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
		return task;
	}
	
	protected static Task markTaskAsDone(String taskIdString, TaskList listOfTasks) {
		Task task = getTaskById(listOfTasks, taskIdString);
		task.setDone();
		
		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
		return task;
	}
	
	protected static Task getTaskById(TaskList listOfTasks, String taskIdString) {
		int taskId = Integer.parseInt(taskIdString);
		int index = taskId - 1;
		Task task = listOfTasks.get(index);
		return task;
	}
	
	protected static void clearTasks() {
		TaskList listOfTasks;
		listOfTasks = new TaskList();
		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
	}
	
	protected static TaskList archiveForUndo() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		
		// request a file for archive purpose
		String fileRecord = DataFileStack.requestDataFile();
		DataManager.storeBack(listOfTasks, fileRecord);
		
		DataFileStack.pushForUndo(fileRecord);
		
		return listOfTasks;
	}
	
	protected static Task addInfoToTask(String info, TaskList listOfTasks,
			int index) {
		Task task = listOfTasks.get(index);
		
		if(task.getDetails() == null) {
			task.setDetails(info);
		} else {
			String details = task.getDetails();
			details += ("\n" + info);
			task.setDetails(details);
		}
		
		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
		return task;
	}
	
	protected static Task deleteTask(TaskList listOfTasks, int indexOfTask) {
		Task taskDeleted = listOfTasks.get(indexOfTask);
		listOfTasks.remove(indexOfTask);
		
		DataManager.storeBack(listOfTasks, DataFileStack.FILE);
		return taskDeleted;
	}

	/*
	public static LinkedList<Integer> sortByDeadline(TaskList listOfTasks) {
		LinkedList<Task> tasks = listOfTasks.getList();
		
		HashMap<Task, Integer> dictionaryForTaskIndex = new HashMap<Task, Integer>();
		for(int i = 0; i < tasks.size(); i++) {
			dictionaryForTaskIndex.put(tasks.get(i), i);
		}
		
		Collections.sort(tasks, ACCENDING_ORDER);
		
		LinkedList<Integer> result = new LinkedList<Integer>();
		for(int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			int index = dictionaryForTaskIndex.get(task);
			result.add(index);
		}
		
		return result;
	}
	*/
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactoryBackend.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactoryStub.java
	 */


package com.taskpad.execute;

public class CommandFactoryStub extends CommandFactory{
	protected static void outputToGui(String feedback) {
		System.out.println(feedback);
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\CommandFactoryStub.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorManager.java
	 */


package com.taskpad.execute;

import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Logger;

import com.taskpad.storage.CommandRecord;
import com.taskpad.ui.GuiManager;
import com.taskpad.input.Input;

public class ExecutorManager {
	private static final String MESSAGE_SHOWING_REMINDER = "Showing tasks due today & overdue tasks...";
	
	private static Logger logger = Logger.getLogger("TaskPad");
	
	public static void showReminder() {
		OutputToGui.output(MESSAGE_SHOWING_REMINDER);
		
		Timer timer = new Timer();
		
		timer.schedule(new TimerTask() {
			  @Override
			  public void run() {
					Reminder.showReminderForToday();
					Reminder.showReminderForOverdue();
			  }
		}, 2*1000);
		
	}
	public static void receiveFromInput(Input input, String command) {
		String commandType = input.getCommand();
		logger.info("Executor: "+ command);
		Map<String, String> parameters = input.getParameters();
		
		switch (commandType) {
		case "ADD":
			CommandFactory.add(parameters.get("DESC"), parameters.get("DEADLINE DATE"),
					parameters.get("START DATE"), parameters.get("START TIME"),
					parameters.get("END DATE"), parameters.get("END TIME"),
					parameters.get("VENUE"));
			
			CommandRecord.pushForUndo(command);
			break;
		case "DELETE":
			CommandFactory.delete(parameters.get("TASKID"));
			CommandRecord.pushForUndo(command);
			break;
		case "ADDINFO":
			CommandFactory.addInfo(parameters.get("TASKID"), parameters.get("INFO"));
			CommandRecord.pushForUndo(command);
			break;
		case "CLEAR":
			CommandFactory.clear();
			CommandRecord.pushForUndo(command);
			break;
		case "DONE":
			CommandFactory.markAsDone(parameters.get("TASKID"));
			CommandRecord.pushForUndo(command);
			break;
		case "EDIT":
			CommandFactory.edit(parameters.get("TASKID"), parameters.get("DESC"),
					parameters.get("DEADLINE"));
			CommandRecord.pushForUndo(command);
			break;
		case "SEARCH":
			logger.info("Search keyword: " + parameters.get("KEYWORD"));
			CommandFactory.search(parameters.get("KEYWORD"), parameters.get("TIME"));
			break;
		case "UNDO":
			CommandFactory.undo();
			break;
		case "REDO":
			CommandFactory.redo();
			break;
		case "LIST":
			list(parameters.get("KEY"));
			break;
		}
	}

	private static void list(String option) {
		GuiManager.clearOutput();
		switch(option) {
		case "ALL":
			logger.info("Listing all tasks...");
			GuiManager.callOutput("Listing all tasks...");
			CommandFactory.listAll();
			break;
		case "DONE":
			logger.info("Listing finished tasks...");
			GuiManager.callOutput("Listing finished tasks...");
			CommandFactory.listDone();
			break;
		case "UNDONE":
			logger.info("Listing undone tasks...");
			GuiManager.callOutput("Listing undone tasks...");
			CommandFactory.listUndone();
			break;
		}	
	}

}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorManager.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorTestDriver.java
	 */


package com.taskpad.execute;

import java.util.HashMap;
import java.util.LinkedList;

import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.TaskList;

public class ExecutorTestDriver {
	/* 
	 * Methods in CommandFactoryBackend are not public
	 * Offer public access for testing purpose
	 */
	
	public static void addTask(HashMap<String, String> parameters, TaskList list) {
		CommandFactoryBackend.addTask(parameters.get("DESC"), parameters.get("DEADLINE"),
				parameters.get("START DATE"), parameters.get("START TIME"),
				parameters.get("END DATE"), parameters.get("END TIME"),
				parameters.get("VENUE"), list);
	}

	public static LinkedList<Integer> getAllTasksFromBackend(TaskList list) {
		return CommandFactoryBackend.getAllTasks(list);
	}
	
	public static LinkedList<Integer> getUndoneTasksFromBackend(TaskList list) {
		return CommandFactoryBackend.getUndoneTasks(list);
	}

	public static LinkedList<Integer> getFinishedTasksFromBackend(TaskList list) {
		return CommandFactoryBackend.getFinishedTasks(list);
	}

	public static void deleteTask(TaskList list, int index) {
		CommandFactoryBackend.deleteTask(list, index);
		
	}

	public static void clearTasks() {
		CommandFactoryBackend.clearTasks();		
	}

	public static void archiveForUndo() {
		CommandFactoryBackend.archiveForUndo();		
	}

	public static void updateDataForUndo() throws NoPreviousFileException {
		CommandFactoryBackend.updateDataForUndo();
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\ExecutorTestDriver.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\OutputToGui.java
	 */


package com.taskpad.execute;

import java.awt.Color;
import java.util.LinkedList;

import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;
import com.taskpad.ui.GuiManager;

public class OutputToGui {
	protected static void output(String feedback) {
		GuiManager.callOutputNoLine(feedback + "\n");
	}
	
	protected static void outputTable(LinkedList<Integer> candidates, TaskList listOfTasks) {
		String[][] tableArray = generate2dArrayForTasks(candidates, listOfTasks);
		GuiManager.callTable(tableArray);
	}
	
	protected static String[][] generate2dArrayForTasks(LinkedList<Integer> candidates, TaskList listOfTasks) {
		int numberOfTasks = candidates.size();
		String[][] result = new String[numberOfTasks][7];
		/*
		for(int i = 0; i < numberOfTasks; i++) {
			for(int j = 0; j < 6; j++) {
				result[i][j] = "";
			}
		}
		*/
		int index = 0;
		for(int next: candidates) {
			int taskId = next + 1;
			Task task = listOfTasks.get(next);
			result = fillIn2dArrayForOneTask(result, taskId, index, task);
			index++;
		}		
		
		return result;
	}
	
	private static String[][] fillIn2dArrayForOneTask(String[][] result, int taskId, int index, Task task) {		
		result[index][0] = "" + taskId;
		result[index][1] = task.getDescription();
		
		if(task.getDeadline() == null || task.getDeadline().equals("")) {
			result[index][2] = "-";
		} else {
			result[index][2] = task.getDeadline();
		}
		
		if(task.getStartTime() == null || task.getStartTime().equals("")) {
			if(task.getStartDate() == null || task.getStartDate().equals("")) {
				result[index][3] = "-";
			} else {
				result[index][3] = task.getStartDate();
			}
		} else {
			if(task.getStartDate() == null || task.getStartDate().equals("")) {
				result[index][3] = task.getStartTime();
			} else {
				result[index][3] = task.getStartTime() + " " + task.getStartDate();
			}			
		}

		if(task.getEndTime() == null || task.getEndTime().equals("")) {
			if(task.getEndDate() == null || task.getEndDate().equals("")) {
				result[index][4] = "-";
			} else {
				result[index][4] = task.getEndDate();
			}
		} else {
			if(task.getEndDate() == null || task.getEndDate().equals("")) {
				result[index][4] = task.getEndTime();
			} else {
				result[index][4] = task.getEndTime() + " " + task.getEndDate();
			}			
		}
		
		if(task.getDetails() == null || task.getDetails().trim().equals("")) {
			result[index][5] = "-";
		} else {
			result[index][5] = task.getDetails();
		}
		
		if(task.getDone() == 1) {
			result[index][6] = "Done";
		} else {
			result[index][6] = "Not done yet";
		}
		
		return result;
	}

	protected static void outputColorTextForTasks(LinkedList<Integer> candidates, TaskList listOfTasks) {
		for(int next: candidates) {
			int taskId = next + 1;
			outputColorTextForOneTask(taskId, listOfTasks.get(next));
			output("\n\n");
		}	
	}
	protected static void outputColorTextForOneTask(int taskId, Task task) {
		String text = "";
		
		text = "Task ID:\t\t" + taskId;
		GuiManager.showSelfDefinedMessage(text, new Color(16,78,139), false); 
		/*
		text =  taskId + "\n";
		GuiManager.showSelfDefinedMessage(text, Color.blue, false);
		*/
		
		/*
		text = "Description:\t";
		GuiManager.showSelfDefinedMessage(text, Color.green, true);
		*/
		text = "Description:\t" + task.getDescription();		
		GuiManager.showSelfDefinedMessage(text, Color.MAGENTA, false);
		
		if (task.getDeadline() != null && !task.getDeadline().equals("")) {
			/*
			text = "Deadline:\t";
			GuiManager.showSelfDefinedMessage(text, Color.pink, true);
			*/
			text = "Deadline:\t\t" + task.getDeadline();
			GuiManager.showSelfDefinedMessage(text, Color.orange, false);
		}
		
		String start = "";
		if (task.getStartTime() != null && !task.getStartTime().equals("")) {
			start += task.getStartTime();
		}
		if (task.getStartDate() != null && !task.getStartDate().equals("")) {
			start += (" " + task.getStartDate());
		}
		if (!start.equals("")) {
			/*
			text += "Start:\t";
			GuiManager.showSelfDefinedMessage(text, Color.yellow, true);
			*/
			text = "Start:\t\t" + start;
			GuiManager.showSelfDefinedMessage(text, Color.blue, false);
		}
		
		String end = "";
		if (task.getEndTime() != null && !task.getEndTime().equals("")) {
			end += task.getEndTime();
		}
		if (task.getEndDate() != null && !task.getEndDate().equals("")) {
			end += (" " + task.getEndDate());
		}
		if (!end.equals("")) {
			/*
			text += "End:\t";
			GuiManager.showSelfDefinedMessage(text, Color.orange, true);
			*/
			text = "End:\t\t" + end;
			GuiManager.showSelfDefinedMessage(text, Color.blue, false);
		}
		
		/*
		if (task.getVenue() != null && !task.getVenue().equals("")) {
			text += "Venue: " + task.getVenue() + "\n";
		}
		*/
		
		if (task.getDetails() != null && !task.getDetails().equals("")) {
			/*
			text = "Details:\t";
			GuiManager.showSelfDefinedMessage(text, Color.red, true);
			*/
			text = "Details:\t\t" + task.getDetails();
			GuiManager.showSelfDefinedMessage(text, new Color(76, 0, 153), false);
		}
		
		/*
		text = "Done or not:\t";
		GuiManager.showSelfDefinedMessage(text, Color.gray, true);
		*/
		if (task.getDone() == 0) {
			text = "Status:\t\tNot done.";
		} else {
			text = "Status:\t\tDone.";
		}
		GuiManager.showSelfDefinedMessage(text, Color.blue, true);
		
	}

	protected static void generateFeedbackForAdd(int taskId, Task taskAdded) {
		//return OutputToGui.generateTextForOneTask(taskId, taskAdded);
		//OutputToGui.output("Task Successfully Added!\n");
		GuiManager.showSelfDefinedMessage("Task Successfully Added!\n", new Color(25,20,147), false);
		OutputToGui.outputColorTextForOneTask(taskId, taskAdded);
	}
	
	protected static String generateFeedbackForDelete(Task taskDeleted) {
		return "'" + taskDeleted.getDescription() + "' " + "deleted."; 
	}
	
	protected static String generateTextForTasks(LinkedList<Integer> candidates, TaskList listOfTasks) {
		String text = "";
		for(int next: candidates) {
			int taskId = next + 1;
			text += generateTextForOneTask(taskId, listOfTasks.get(next));
			text += "\n\n";
		}
		return text;
	}
	
	protected static String generateTitleForOneTask(String taskIdString,
			String description) {
		return taskIdString + ". " + description;
	}
	
	protected static String generateTextForOneTask(int taskId, Task task) {
		String text = "";
		
		text += "Task ID: " + taskId + "\n";
		text += "Description: " + task.getDescription() + "\n";
		
		if (task.getDeadline() != null && !task.getDeadline().equals("")) {
			text += "Deadline: " + task.getDeadline() + "\n";
		}
		
		String start = "";
		if (task.getStartTime() != null && !task.getStartTime().equals("")) {
			start += task.getStartTime();
		}
		if (task.getStartDate() != null && !task.getStartDate().equals("")) {
			start += (" " + task.getStartDate());
		}
		if (!start.equals("")) {
			text += "Start: " + start + "\n";
		}
		
		String end = "";
		if (task.getEndTime() != null && !task.getEndTime().equals("")) {
			end += task.getEndTime();
		}
		if (task.getEndDate() != null && !task.getEndDate().equals("")) {
			end += (" " + task.getEndDate());
		}
		if (!end.equals("")) {
			text += "End: " + end + "\n";
		}
		
		if (task.getVenue() != null && !task.getVenue().equals("")) {
			text += "Venue: " + task.getVenue() + "\n";
		}
		
		if (task.getDetails() != null && !task.getDetails().equals("")) {
			text += "Details: " + task.getDetails() + "\n";
		}
		
		if (task.getDone() == 0) {
			text += "Not done.";
		} else {
			text += "Done.";
		}
		
		return text;
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\OutputToGui.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\Reminder.java
	 */


package com.taskpad.execute;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;

import com.taskpad.input.InputManager;
import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class Reminder {
	private static final String FEEDBACK_NO_TASK_DUE_TODAY = "No task due today.";
	private static final String FEEDBACK_NO_OVERDUE = "No overdue task.";
	
	protected static void showReminderForToday() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		LinkedList<Integer> tasks = getTasksDueToday();
		if(tasks.size() == 0) {
			OutputToGui.output(FEEDBACK_NO_TASK_DUE_TODAY);
		} else {
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}
	}
	
	protected static void showReminderForOverdue() {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		LinkedList<Integer> tasks = getOverdueTasks();
		
		if(tasks.size() == 0) {
			OutputToGui.output(FEEDBACK_NO_OVERDUE);
		} else {
			// OutputToGui.outputColorTextForTasks(tasks, listOfTasks);
			OutputToGui.outputTable(tasks, listOfTasks);
		}
	}

	protected static LinkedList<Integer> getTasksDueToday() {
		LinkedList<Integer> results = new LinkedList<Integer>();
		
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		String dateString = sdf.format(date);
		
		TaskList allTasks = DataManager.retrieve(DataFileStack.FILE);
		for (int i = 0; i < allTasks.size(); i++) {
			Task task = allTasks.get(i);
			String deadline = task.getDeadline();
			if(deadline != null && deadline.contains(dateString)) {
				results.add(i);
			}
		}
		
		return results;
	}
	
	protected static LinkedList<Integer> getOverdueTasks() {
		/*
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		String today = sdf.format(date);	
		Task taskDueToday = new Task("dummy", today, "", "", "", "", null);
		*/
		
		TaskList list = DataManager.retrieve(DataFileStack.FILE);
				
		LinkedList<Integer> result = new LinkedList<Integer>();
		
		for(int i = 0; i < list.size(); i++) {
			Task task = list.get(i);
			int compareToToday = InputManager.compareDateAndTime(task.getDeadline());
			if(compareToToday == -1 || compareToToday == 0) {
				result.add(i);
			}
		}
		
		return result;
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\Reminder.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\TaskDeadlineComparator.java
	 */


package com.taskpad.execute;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;

import com.taskpad.storage.Task;

public class TaskDeadlineComparator implements Comparator<Task>{
	/**
	 * compare: compare two tasks' Date
	 * 
	 * @param e1
	 *            : task1
	 * @param e2
	 *            : task2
	 * @return int
	 */
	@Override
	public int compare(Task e1, Task e2) {
		SimpleDateFormat dateConverter = new SimpleDateFormat(
				"dd/MM/yyyy HH:mm");
		Date d1, d2;
		try {
			d1 = dateConverter.parse(e1.getDeadline() + e1.getEndTime());
			d2 = dateConverter.parse(e2.getDeadline() + e2.getEndTime());
		} catch (ParseException e) {
			System.err.println(e.getMessage());
			return 0;
		}
		return d1.compareTo(d2);
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\execute\TaskDeadlineComparator.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\CommandRecord.java
	 */


package com.taskpad.storage;



import java.util.LinkedList;

public class CommandRecord {
	// private static String previousCommand;
	private static LinkedList<String> commandsForUndo = new LinkedList<String>();
	private static LinkedList<String> commandsForRedo = new LinkedList<String>();
	
	public static void pushForUndo(String command) {
		// previousCommand = command;
		commandsForUndo.push(command);
	}
	
	public static String popForUndo() throws NoPreviousCommandException {
		if (commandsForUndo.size() < 1) {
			throw new NoPreviousCommandException();
		}
		return commandsForUndo.pop();
	}
	
	public static void pushForRedo(String command) {
		// previousCommand = command;
		commandsForRedo.push(command);
	}
	
	public static String popForRedo() throws NoPreviousCommandException {
		if (commandsForRedo.size() < 1) {
			throw new NoPreviousCommandException();
		}
		return commandsForRedo.pop();
	}	// dummy
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\CommandRecord.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\DataFileStack.java
	 */


package com.taskpad.storage;



import java.util.LinkedList;

public class DataFileStack {
	public static final String FILE = ".data.xml";
	// public static final String FILE_PREV = ".data_prev.xml";
	public static LinkedList<String> undoStack = new LinkedList<String>();
	public static LinkedList<String> redoStack = new LinkedList<String>();
	
	// private static boolean previousIsValid = false;
	
	/*
	public static boolean isValidPrevious() {
		return previousIsValid;
	}
	
	public static void setPreviousIsValid(boolean isValid) {
		previousIsValid = isValid;
	}
	*/
	
	public static String requestDataFile() {
		return ".data" + (undoStack.size() + redoStack.size()) + ".xml";
	}
	
	public static void pushForUndo(String file) {
		// previousCommand = command;
		undoStack.push(file);
	}
	
	public static String popForUndo() throws NoPreviousFileException {
		if (undoStack.size() < 1) {
			throw new NoPreviousFileException();
		}
		return undoStack.pop();
	}
	
	public static void pushForRedo(String file) {
		redoStack.push(file);
	}
	
	public static String popForRedo() throws NoPreviousFileException {
		if (redoStack.size() < 1) {
			throw new NoPreviousFileException();
		}
		return redoStack.pop();
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\DataFileStack.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\DataManager.java
	 */


package com.taskpad.storage;


import java.io.File;
import java.io.FileNotFoundException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class DataManager {

	public DataManager(){
		
	}
	
	public static int retrieveNumberOfTasks(){
		int numberOfTasks = retrieve(DataFileStack.FILE).size();
		return numberOfTasks;
	}
	
	public static void initializeXml(){
		// do nothing
		/*
		LinkedList<Task> tasks = new LinkedList<Task>();
		DataManager.storeBack(tasks, DataFile.FILE);
		DataManager.storeBack(tasks, DataFile.FILE_PREV);
		*/
	}
		
	public static TaskList retrieve(String file) {
		TaskList listOfTasks = new TaskList();
		
		try {
			File fXmlFile = new File(file);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(fXmlFile);
			
			doc.getDocumentElement().normalize();
			
			NodeList nList = doc.getElementsByTagName("Task");
			
			// System.out.println("nList.length = " + nList.getLength());
			for (int i = 0; i < nList.getLength(); i++) {
				Node taskNode = nList.item(i);
		 
				if (taskNode.getNodeType() == Node.ELEMENT_NODE) {
					Element task = (Element) taskNode;
					
					String description;
					String deadline;
					String startDate;
					String startTime;
					String endDate;
					String endTime;
					String venue;
					String details;
					int done;
					
					if (task.getElementsByTagName("description").item(0) != null) {
						description = task.getElementsByTagName("description").item(0).getTextContent();
					} else {
						return listOfTasks; // description cannot be null
					}
					
					if(task.getElementsByTagName("deadline").item(0) != null) {
						deadline = task.getElementsByTagName("deadline").item(0).getTextContent();
					} else {
						deadline = null;
					}
					
					if (task.getElementsByTagName("start_date").item(0) != null) {
						startDate = task.getElementsByTagName("start_date").item(0).getTextContent();
					} else {
						startDate = null;
					}
					
					if (task.getElementsByTagName("start_time").item(0) != null) {
						startTime = task.getElementsByTagName("start_time").item(0).getTextContent();
					} else {
						startTime = null;
					}
					
					if (task.getElementsByTagName("end_date").item(0) != null) {
						endDate = task.getElementsByTagName("end_date").item(0).getTextContent();
					} else {
						endDate = null;
					}
					
					if (task.getElementsByTagName("end_time").item(0) != null) {
						endTime = task.getElementsByTagName("end_time").item(0).getTextContent();
					} else {
						endTime = null;
					}
					
					if (task.getElementsByTagName("venue").item(0) != null) {
						venue = task.getElementsByTagName("venue").item(0).getTextContent();
					} else {
						venue = null;
					}
					
					if(task.getElementsByTagName("details").item(0) != null) {
						details = task.getElementsByTagName("details").item(0).getTextContent();
					} else {
						details = null;
					}
					
					assert(task.getElementsByTagName("done") != null);
					done = Integer.parseInt(task.getElementsByTagName("done").item(0).getTextContent());
					
					listOfTasks.add(new Task(description, deadline, startDate,
							startTime, endDate, endTime, venue, details, done));
				}
			}
			
			return listOfTasks;
	    } catch (FileNotFoundException e) {
			TaskList tasks = new TaskList();
			DataManager.storeBack(tasks, file);
			return tasks;
	    } catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return listOfTasks;
		
	}
	
	public static void storeBack(TaskList taskList, String file) {
		try {
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			docFactory.setNamespaceAware(true);
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
	 
			// root elements
			Document doc = docBuilder.newDocument();
			Element rootElement = doc.createElement("TaskPad");
			doc.appendChild(rootElement);
	 
			for(int i = 0; i < taskList.size(); i++) {
				Task taskInList = taskList.get(i);
				int id = i + 1;
				Element task = doc.createElement("Task");
				rootElement.appendChild(task);
				task.setAttribute("id", Integer.toString(id));
				
				if(taskInList.getDescription() != null) {
					Element description = doc.createElement("description");
					description.appendChild(doc.createTextNode(taskInList.getDescription()));
					task.appendChild(description);
				}
				
				if(taskInList.getDeadline() != null) {
					Element deadlineDay = doc.createElement("deadline");
					deadlineDay.appendChild(doc.createTextNode(taskInList.getDeadline()));
					task.appendChild(deadlineDay);
				}
				
				if (taskInList.getStartDate() != null) {
					Element startDate = doc.createElement("start_date");
					startDate.appendChild(doc.createTextNode(taskInList.getStartDate()));
					task.appendChild(startDate);
				}
				
				if (taskInList.getStartTime() != null) {
					Element startTime = doc.createElement("start_time");
					startTime.appendChild(doc.createTextNode(taskInList.getStartTime()));
					task.appendChild(startTime);
				}
				
				if (taskInList.getEndDate() != null) {
					Element endDate = doc.createElement("end_date");
					endDate.appendChild(doc.createTextNode(taskInList.getEndDate()));
					task.appendChild(endDate);
				}
				
				if (taskInList.getEndTime() != null) {
					Element endTime = doc.createElement("end_time");
					endTime.appendChild(doc.createTextNode(taskInList.getEndTime()));
					task.appendChild(endTime);
				}
				
				if (taskInList.getDetails() != null) {
					Element details = doc.createElement("details");
					details.appendChild(doc.createTextNode(taskInList.getDetails()));
					task.appendChild(details);
				}
				
				Element done = doc.createElement("done");
				done.appendChild(doc.createTextNode(Integer.toString(taskInList.getDone())));
				task.appendChild(done);
				
			}
				
			// write the content into xml file
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(new File(file));
			
			transformer.transform(source, result);
	 
		} catch (ParserConfigurationException pce) {
			pce.printStackTrace();
		} catch (TransformerException tfe) {
		  	tfe.printStackTrace();
		}
	
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\DataManager.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\NoPreviousCommandException.java
	 */



package com.taskpad.storage;

public class NoPreviousCommandException extends Exception {

}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\NoPreviousCommandException.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\NoPreviousFileException.java
	 */


package com.taskpad.storage;


public class NoPreviousFileException extends Exception {

}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\NoPreviousFileException.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\Task.java
	 */


package com.taskpad.storage;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;


public class Task{
	private String description;
	private String deadline;
	private String startDate;
	private String startTime;
	private String endDate;
	private String endTime;
	private String venue; 
	private String details;
	private int done;	// 0 for undone, 1 for done
	
	public Task(String description, String deadline, String startDate, String startTime,
			String endDate, String endTime, String venue) {
		this.description = description;
		this.deadline = deadline;
		this.startDate = startDate;
		this.startTime = startTime;
		this.endDate = endDate;
		this.endTime = endTime;
		this.venue = venue;
		this.done = 0;
	}

	public Task(String description, String deadline, String startDate, String startTime,
			String endDate, String endTime, String venue,
			String details, int done) {
		this.description = description;
		this.deadline = deadline;
		this.startDate = startDate;
		this.startTime = startTime;
		this.endDate = endDate;
		this.endTime = endTime;
		this.details = details;
		this.venue = venue;
		this.done = done;
	}
	
	public String getDescription() {
		return description;
	}
	
	public String getDeadline() {
		return deadline;
	}

	public String getStartDate() {
		return startDate;
	}
	
	public String getStartTime() {
		return startTime;
	}

	public String getEndDate() {
		return endDate;
	}
	
	public String getEndTime() {
		return endTime;
	}
	
	public String getVenue() {
		return venue;
	}

	public String getDetails() {
		return details;
	}

	public int getDone() {
		return done;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public void setDone() {
		this.done = 1;
	}

	public void setDescription(String description) {
		this.description = description;
	}
	
	public void setDeadline(String deadline) {
		this.deadline = deadline;
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\Task.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\TaskList.java
	 */


package com.taskpad.storage;



import java.util.LinkedList;

public class TaskList {
	private LinkedList<Task> list;
	
	public TaskList() {
		list = new LinkedList<Task>();
	}
	
	public LinkedList<Task> getList() {
		return list;
	}
	
	public void add(Task task) {
		list.add(task);
	}
	
	public Task get(int index) {
		return list.get(index);
	}
	
	public int size() {
		return list.size();
	}
	
	public void remove(int index) {
		list.remove(index);
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\storage\TaskList.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutor.java
	 */


package com.taskpad.tests;



import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.LinkedList;

import org.junit.Test;

import com.taskpad.execute.ExecutorTestDriver;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class TestExecutor {	
	
	@Test
	public void testList() {
		/*
		 * only test 0, 1, 2 here
		 */
		TaskList list = new TaskList();
		LinkedList<Integer> result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 0);
		
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 1);
		
		ExecutorTestDriver.addTask(parameters, list);
		result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 2);

		Task task = list.get(0);
		task.setDone();
		result = ExecutorTestDriver.getUndoneTasksFromBackend(list);
		assertEquals(result.size(), 1);
		
		result = ExecutorTestDriver.getFinishedTasksFromBackend(list);
		assertEquals(result.size(), 1);
	}
	
	@Test
	public void testDelete() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.addTask(parameters, list);
		
		ExecutorTestDriver.deleteTask(list, 0);
		assertEquals(list.size(), 1);
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutor.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutorDataForDebugging.java
	 */


package com.taskpad.tests;

import java.util.HashMap;
import java.util.LinkedList;
//import java.util.Map;




import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.TaskList;
import com.taskpad.execute.ExecutorManager;
import com.taskpad.input.Input;
import com.taskpad.storage.Task;

/**
 * TestExecutorData
 * 
 * This class is for debugging purpose only
 *
 */




public class TestExecutorDataForDebugging {
	private static void commandTest() {
		LinkedList<Task> tasks = new LinkedList<Task>();
		//DataManager.storeBack(tasks, DataFileStack.FILE);
		// DataManager.storeBack(tasks, DataFileStack.FILE_PREV);
		
		String input = "add do homework";
		HashMap<String, String> map = new HashMap<String, String>();
		map.put("DESC", "do homework");
		Input inputObj = new Input("ADD", map);
		ExecutorManager.receiveFromInput(inputObj,input);
		
		/*
		String input1 = "ls";
		HashMap<String, String> map1 = new HashMap<String, String>();
		map1.put("KEY", "ALL");
		Input inputObj1 = new Input("LIST", map1);
		ExecutorManager.receiveFromInput(inputObj1,input1);
		
		String input2 = "addinfo 1 with Jean";
		HashMap<String, String> map2 = new HashMap<String, String>();
		map2.put("TASKID", "1");
		map2.put("INFO", "with Jean");
		Input inputObj2 = new Input("ADDINFO", map2);
		ExecutorManager.receiveFromInput(inputObj2,input2);
		*/
		
		String input3 = "undo";
		HashMap<String, String> map3 = new HashMap<String, String>();
		Input inputObj3 = new Input("UNDO", map3);
		ExecutorManager.receiveFromInput(inputObj3,input3);		
		
		String input4 = "add do your homework";
		HashMap<String, String> map4 = new HashMap<String, String>();
		map4.put("DESC", "do your homework");
		Input inputObj4 = new Input("ADD", map4);
		ExecutorManager.receiveFromInput(inputObj4,input4);
		
		String input1 = "ls";
		HashMap<String, String> map1 = new HashMap<String, String>();
		map1.put("KEY", "ALL");
		Input inputObj1 = new Input("LIST", map1);
		ExecutorManager.receiveFromInput(inputObj1,input1);
	}
	
	private static void dataRetrievalTest() {
		DataManager.retrieve("test_data.xml");
	}
	
	private static void dataStoreBackTest() {
		LinkedList<Task> tasks = new LinkedList<Task>();
		//DataManager.storeBack(tasks, "test_data.xml");
	}
	
	private static void parameterizedStringTest() {
		String LOGGING_ADDING_TASK = "adding task: %s";
		String description = "sth";
		System.out.println(String.format(LOGGING_ADDING_TASK, description));
	}
	
	private static void addTasks() {
		TaskList list = DataManager.retrieve(DataFileStack.FILE);
		for(int i = 0; i < 20; i++) {		
			list.add(new Task("some task", null, null, null, null, null, null));
		}
		DataManager.storeBack(list, DataFileStack.FILE);
	}
	
	public static void main(String args[]) {
		addTasks();
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutorDataForDebugging.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutorStorage.java
	 */


package com.taskpad.tests;


import static org.junit.Assert.*;

import java.util.HashMap;

import org.junit.Test;

import com.taskpad.data.DataFileStack;
import com.taskpad.data.DataManager;
import com.taskpad.execute.ExecutorTestDriver;
import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class TestExecutorStorage {
	
	@Test
	public void testAddFloatingTask() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		assertEquals(DataManager.retrieveNumberOfTasks(), 1);
		
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(listOfTasks.size(), 1);
		
		Task task = listOfTasks.get(0);
		assertEquals(task.getDescription(), "do homework 1");
		
		/* 
		 * There is usually no need to test that all other attributes are null/empty
		 * They are unlikely to be dealt with differently 
		 * Only testing deadline and venue here
		 */
		assertTrue(task.getDeadline() == null || task.getDeadline().equals(""));
		assertTrue(task.getVenue() == null || task.getVenue().equals(""));
	}

	@Test
	public void testAddTaskWithDeadline() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		parameters.put("DEADLINE", "02/03/2014");
		
		ExecutorTestDriver.addTask(parameters, list);
		assertEquals(DataManager.retrieveNumberOfTasks(), 1);
		
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(listOfTasks.size(), 1);
		
		Task task = listOfTasks.get(0);
		assertEquals(task.getDescription(), "do homework 1");
		assertEquals(task.getDeadline(), "02/03/2014");
		
		/* 
		 * There is usually no need to test that all other attributes are null/empty
		 * They are unlikely to be dealt with differently 
		 * Only testing deadline and venue here
		 */
		assertTrue(task.getStartTime() == null || task.getStartTime().equals(""));
		assertTrue(task.getVenue() == null || task.getVenue().equals(""));		
	}
	
	@Test
	public void testClear() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.addTask(parameters, list);
		
		DataManager.storeBack(list, DataFileStack.FILE);
		
		ExecutorTestDriver.clearTasks();
		list = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(list.size(), 0);
	}
	
	@Test
	public void testUndo() throws NoPreviousFileException {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.archiveForUndo();
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.archiveForUndo();
		
		ExecutorTestDriver.updateDataForUndo();
		
		list = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(list.size(), 1);
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestExecutorStorage.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestStorage.java
	 */


package com.taskpad.tests;



import static org.junit.Assert.*;

import org.junit.Test;
import org.xml.sax.SAXParseException;

import com.taskpad.storage.CommandRecord;
import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.NoPreviousCommandException;
import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class TestStorage {

	@Test(expected = NoPreviousCommandException.class)
	public void testCommandRecord() throws NoPreviousCommandException {
		CommandRecord.pushForUndo("add do homework 1");
		CommandRecord.pushForUndo("delete 1");
		try {
			assert(CommandRecord.popForUndo().equals("delete 1"));
		} catch (NoPreviousCommandException e) {
			fail("Fail to pop from CommandRecord undoStack");
		}
		
		CommandRecord.pushForRedo("delete 1");
		try {
			CommandRecord.popForRedo();
		} catch (NoPreviousCommandException e) {
			fail("Fail to pop from CommandRecord redoStack");
		}
		
		/* should throw NoPreviousCommandException */
		CommandRecord.popForRedo();
	}
	
	@Test
	public void TestDataFileStack() {
		DataFileStack.pushForUndo(".data0.xml");
		try {
			DataFileStack.popForUndo();
		} catch (NoPreviousFileException e) {
			fail("Fail to pop from DataFileStack undoStack");
		}
		DataFileStack.pushForRedo(".data0.xml");
		assert(DataFileStack.requestDataFile().equals(".data1.xml"));
		DataFileStack.pushForUndo(".data1.xml");
		assert(DataFileStack.requestDataFile().equals(".data2.xml"));
	}

	@Test(expected = SAXParseException.class)
	public void TestDataManager() {
		/* 
		 * Only testing 0, 1, 2 tasks here,
		 * since 2 or more are unlikely to be dealt with differently
		 */
		TaskList list = new TaskList();
		DataManager.storeBack(list, DataFileStack.FILE);
		assert(DataManager.retrieveNumberOfTasks() == 0);
		
		list.add(new Task("some task", null, null, null, null, null, null));
		DataManager.storeBack(list, DataFileStack.FILE);
		assert(DataManager.retrieveNumberOfTasks() == 1);
		
		list.add(new Task("some task", null, null, null, null, null, null));
		DataManager.storeBack(list, DataFileStack.FILE);
		assert(DataManager.retrieveNumberOfTasks() == 2);
		
		TaskList currentList = DataManager.retrieve(DataFileStack.FILE);
		Task task = currentList.get(0);
		assert(task.getDescription().equals("some task"));
		/* 
		 * There is usually no need to test that all other attributes are null/empty
		 * They are unlikely to be dealt with differently 
		 * Only testing deadline and venue here
		 */
		assert(task.getDeadline() == null);
		assert(task.getVenue() == null);
		
		/* partition: existing file */
		TaskList testList = DataManager.retrieve(DataFileStack.FILE);
		assert(testList.size() > 0);
		
		/* partition: non-existing file */
		testList = DataManager.retrieve("test.xml");
		assert(testList.size() == 0);
		
		/* partition: empty string as file name */
		testList = DataManager.retrieve("");	// should throw SAXParseException
		
	}
	
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestStorage.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSystem.java
	 */


package com.taskpad.tests;



import com.taskpad.input.InputManager;
import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.TaskList;

public class TestSystem {
	public static void main(String args[]) {
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		int oldSize = listOfTasks.size();
		InputManager.receiveFromGui("add watch movie -d 31/05/2015");
		listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		System.out.println(listOfTasks.size());
	}
}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSystem.java





	/**
	 * origin: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSystemTest.java
	 */


package com.taskpad.tests;



import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.LinkedList;

import org.junit.Test;

import com.taskpad.execute.ExecutorTestDriver;
import com.taskpad.input.InputManager;
import com.taskpad.storage.DataFileStack;
import com.taskpad.storage.DataManager;
import com.taskpad.storage.NoPreviousFileException;
import com.taskpad.storage.Task;
import com.taskpad.storage.TaskList;

public class TestSystemTest {

	@Test
	public void testAddFloatingTask() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		assertEquals(DataManager.retrieveNumberOfTasks(), 1);
		
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(listOfTasks.size(), 1);
		
		Task task = listOfTasks.get(0);
		assertEquals(task.getDescription(), "do homework 1");
		
		/* 
		 * There is usually no need to test that all other attributes are null/empty
		 * They are unlikely to be dealt with differently 
		 * Only testing deadline and venue here
		 */
		assertTrue(task.getDeadline() == null || task.getDeadline().equals(""));
		assertTrue(task.getVenue() == null || task.getVenue().equals(""));
	}

	@Test
	public void testAddTaskWithDeadline() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		parameters.put("DEADLINE", "02/03/2014");
		
		ExecutorTestDriver.addTask(parameters, list);
		assertEquals(DataManager.retrieveNumberOfTasks(), 1);
		
		TaskList listOfTasks = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(listOfTasks.size(), 1);
		
		Task task = listOfTasks.get(0);
		assertEquals(task.getDescription(), "do homework 1");
		assertEquals(task.getDeadline(), "02/03/2014");
		
		/* 
		 * There is usually no need to test that all other attributes are null/empty
		 * They are unlikely to be dealt with differently 
		 * Only testing deadline and venue here
		 */
		assertTrue(task.getStartTime() == null || task.getStartTime().equals(""));
		assertTrue(task.getVenue() == null || task.getVenue().equals(""));		
	}
	
	@Test
	public void testList() {
		/*
		 * only test 0, 1, 2 here
		 */
		TaskList list = new TaskList();
		LinkedList<Integer> result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 0);
		
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 1);
		
		ExecutorTestDriver.addTask(parameters, list);
		result = ExecutorTestDriver.getAllTasksFromBackend(list);
		assertEquals(result.size(), 2);

		Task task = list.get(0);
		task.setDone();
		result = ExecutorTestDriver.getUndoneTasksFromBackend(list);
		assertEquals(result.size(), 1);
		
		result = ExecutorTestDriver.getFinishedTasksFromBackend(list);
		assertEquals(result.size(), 1);
	}
	
	@Test
	public void testDelete() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.addTask(parameters, list);
		
		ExecutorTestDriver.deleteTask(list, 0);
		assertEquals(list.size(), 1);
	}
	
	@Test
	public void testClear() {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.addTask(parameters, list);
		
		DataManager.storeBack(list, DataFileStack.FILE);
		
		ExecutorTestDriver.clearTasks();
		list = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(list.size(), 0);
	}
	
	/*
	@Test
	public void testUndo() throws NoPreviousFileException {
		TaskList list = new TaskList();
		HashMap<String, String> parameters = new HashMap<String, String>();
		parameters.put("DESC", "do homework 1");
		
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.archiveForUndo();
		ExecutorTestDriver.addTask(parameters, list);
		ExecutorTestDriver.archiveForUndo();
		
		ExecutorTestDriver.updateDataForUndo();
		
		list = DataManager.retrieve(DataFileStack.FILE);
		assertEquals(list.size(), 1);
	}
	*/

}

	// End of segment: C:\Users\Charbby\SkyDrive\Documents\NUS 2013 - 2014\CS2103 CS2103T SOFTWARE ENGINEERING\TaskPad-clone2\src\com\taskpad\tests\TestSystemTest.java





